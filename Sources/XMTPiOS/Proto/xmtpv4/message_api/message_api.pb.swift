// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: xmtpv4/message_api/message_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Message API for XMTP V4

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Query for envelopes, shared by query and subscribe endpoints
/// Either topics or originator_node_ids may be set, but not both
public struct Xmtp_Xmtpv4_MessageApi_EnvelopesQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Client queries
  public var topics: [Data] = []

  /// Node queries
  public var originatorNodeIds: [UInt32] = []

  public var lastSeen: Xmtp_Xmtpv4_Envelopes_Cursor {
    get {return _lastSeen ?? Xmtp_Xmtpv4_Envelopes_Cursor()}
    set {_lastSeen = newValue}
  }
  /// Returns true if `lastSeen` has been explicitly set.
  public var hasLastSeen: Bool {return self._lastSeen != nil}
  /// Clears the value of `lastSeen`. Subsequent reads from it will return its default value.
  public mutating func clearLastSeen() {self._lastSeen = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastSeen: Xmtp_Xmtpv4_Envelopes_Cursor? = nil
}

/// Batch subscribe to envelopes
public struct Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: Xmtp_Xmtpv4_MessageApi_EnvelopesQuery {
    get {return _query ?? Xmtp_Xmtpv4_MessageApi_EnvelopesQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Xmtp_Xmtpv4_MessageApi_EnvelopesQuery? = nil
}

/// Streamed response for batch subscribe - can be multiple envelopes at once
public struct Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var envelopes: [Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Query envelopes request
public struct Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: Xmtp_Xmtpv4_MessageApi_EnvelopesQuery {
    get {return _query ?? Xmtp_Xmtpv4_MessageApi_EnvelopesQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  public var limit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Xmtp_Xmtpv4_MessageApi_EnvelopesQuery? = nil
}

/// Query envelopes response
public struct Xmtp_Xmtpv4_MessageApi_QueryEnvelopesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var envelopes: [Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payerEnvelopes: [Xmtp_Xmtpv4_Envelopes_PayerEnvelope] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var originatorEnvelopes: [Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to retrieve the XIDs for the given addresses
public struct Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single request for a given address
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var identifier: String = String()

    public var identifierKind: Xmtp_Identity_Associations_IdentifierKind = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Response with the XIDs for the requested addresses
public struct Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single response for a given address
  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var identifier: String = String()

    public var inboxID: String {
      get {return _inboxID ?? String()}
      set {_inboxID = newValue}
    }
    /// Returns true if `inboxID` has been explicitly set.
    public var hasInboxID: Bool {return self._inboxID != nil}
    /// Clears the value of `inboxID`. Subsequent reads from it will return its default value.
    public mutating func clearInboxID() {self._inboxID = nil}

    public var identifierKind: Xmtp_Identity_Associations_IdentifierKind = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _inboxID: String? = nil
  }

  public init() {}
}

/// Request to get the newest envelope for a given topic
public struct Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to GetNewestEnvelopeRequest
public struct Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The newest envelope for the given topic OR null if there are no envelopes on the topic
  public var results: [Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var originatorEnvelope: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope {
      get {return _originatorEnvelope ?? Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope()}
      set {_originatorEnvelope = newValue}
    }
    /// Returns true if `originatorEnvelope` has been explicitly set.
    public var hasOriginatorEnvelope: Bool {return self._originatorEnvelope != nil}
    /// Clears the value of `originatorEnvelope`. Subsequent reads from it will return its default value.
    public mutating func clearOriginatorEnvelope() {self._originatorEnvelope = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _originatorEnvelope: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.xmtpv4.message_api"

extension Xmtp_Xmtpv4_MessageApi_EnvelopesQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvelopesQuery"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}topics\0\u{3}originator_node_ids\0\u{3}last_seen\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.topics) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.originatorNodeIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastSeen) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.topics.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.topics, fieldNumber: 1)
    }
    if !self.originatorNodeIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.originatorNodeIds, fieldNumber: 2)
    }
    try { if let v = self._lastSeen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_EnvelopesQuery, rhs: Xmtp_Xmtpv4_MessageApi_EnvelopesQuery) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.originatorNodeIds != rhs.originatorNodeIds {return false}
    if lhs._lastSeen != rhs._lastSeen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeEnvelopesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest, rhs: Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest) -> Bool {
    if lhs._query != rhs._query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeEnvelopesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}envelopes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.envelopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.envelopes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.envelopes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesResponse, rhs: Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesResponse) -> Bool {
    if lhs.envelopes != rhs.envelopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryEnvelopesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}query\0\u{1}limit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest, rhs: Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest) -> Bool {
    if lhs._query != rhs._query {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_QueryEnvelopesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryEnvelopesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}envelopes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.envelopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.envelopes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.envelopes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_QueryEnvelopesResponse, rhs: Xmtp_Xmtpv4_MessageApi_QueryEnvelopesResponse) -> Bool {
    if lhs.envelopes != rhs.envelopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishPayerEnvelopesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}payer_envelopes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.payerEnvelopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payerEnvelopes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payerEnvelopes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest, rhs: Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest) -> Bool {
    if lhs.payerEnvelopes != rhs.payerEnvelopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishPayerEnvelopesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}originator_envelopes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.originatorEnvelopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.originatorEnvelopes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originatorEnvelopes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesResponse, rhs: Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesResponse) -> Bool {
    if lhs.originatorEnvelopes != rhs.originatorEnvelopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInboxIdsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest, rhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}identifier_kind\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.identifierKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if self.identifierKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.identifierKind, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest.Request, rhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsRequest.Request) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.identifierKind != rhs.identifierKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInboxIdsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse, rhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}inbox_id\0\u{3}identifier_kind\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._inboxID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.identifierKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try { if let v = self._inboxID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.identifierKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.identifierKind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse.Response, rhs: Xmtp_Xmtpv4_MessageApi_GetInboxIdsResponse.Response) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._inboxID != rhs._inboxID {return false}
    if lhs.identifierKind != rhs.identifierKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNewestEnvelopeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}topics\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.topics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeRequest, rhs: Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeRequest) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNewestEnvelopeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}results\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse, rhs: Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}originator_envelope\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originatorEnvelope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originatorEnvelope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse.Response, rhs: Xmtp_Xmtpv4_MessageApi_GetNewestEnvelopeResponse.Response) -> Bool {
    if lhs._originatorEnvelope != rhs._originatorEnvelope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
