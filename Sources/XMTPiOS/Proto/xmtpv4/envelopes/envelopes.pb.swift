// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: xmtpv4/envelopes/envelopes.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Message API for XMTP V4

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The last seen entry per originator. Originators that have not been seen are omitted.
public struct Xmtp_Xmtpv4_Envelopes_Cursor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIDToSequenceID: Dictionary<UInt32,UInt64> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Data visible to the server that has been authenticated by the client.
public struct Xmtp_Xmtpv4_Envelopes_AuthenticatedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Do NOT reuse tag 1 — previously used by target_originator
  public var targetTopic: Data = Data()

  /// Do NOT reuse tag 4 — previously used by is_commit
  public var dependsOn: Xmtp_Xmtpv4_Envelopes_Cursor {
    get {return _dependsOn ?? Xmtp_Xmtpv4_Envelopes_Cursor()}
    set {_dependsOn = newValue}
  }
  /// Returns true if `dependsOn` has been explicitly set.
  public var hasDependsOn: Bool {return self._dependsOn != nil}
  /// Clears the value of `dependsOn`. Subsequent reads from it will return its default value.
  public mutating func clearDependsOn() {self._dependsOn = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dependsOn: Xmtp_Xmtpv4_Envelopes_Cursor? = nil
}

public struct Xmtp_Xmtpv4_Envelopes_ClientEnvelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var aad: Xmtp_Xmtpv4_Envelopes_AuthenticatedData {
    get {return _aad ?? Xmtp_Xmtpv4_Envelopes_AuthenticatedData()}
    set {_aad = newValue}
  }
  /// Returns true if `aad` has been explicitly set.
  public var hasAad: Bool {return self._aad != nil}
  /// Clears the value of `aad`. Subsequent reads from it will return its default value.
  public mutating func clearAad() {self._aad = nil}

  public var payload: Xmtp_Xmtpv4_Envelopes_ClientEnvelope.OneOf_Payload? = nil

  public var groupMessage: Xmtp_Mls_Api_V1_GroupMessageInput {
    get {
      if case .groupMessage(let v)? = payload {return v}
      return Xmtp_Mls_Api_V1_GroupMessageInput()
    }
    set {payload = .groupMessage(newValue)}
  }

  public var welcomeMessage: Xmtp_Mls_Api_V1_WelcomeMessageInput {
    get {
      if case .welcomeMessage(let v)? = payload {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessageInput()
    }
    set {payload = .welcomeMessage(newValue)}
  }

  public var uploadKeyPackage: Xmtp_Mls_Api_V1_UploadKeyPackageRequest {
    get {
      if case .uploadKeyPackage(let v)? = payload {return v}
      return Xmtp_Mls_Api_V1_UploadKeyPackageRequest()
    }
    set {payload = .uploadKeyPackage(newValue)}
  }

  public var identityUpdate: Xmtp_Identity_Associations_IdentityUpdate {
    get {
      if case .identityUpdate(let v)? = payload {return v}
      return Xmtp_Identity_Associations_IdentityUpdate()
    }
    set {payload = .identityUpdate(newValue)}
  }

  public var payerReport: Xmtp_Xmtpv4_Envelopes_PayerReport {
    get {
      if case .payerReport(let v)? = payload {return v}
      return Xmtp_Xmtpv4_Envelopes_PayerReport()
    }
    set {payload = .payerReport(newValue)}
  }

  public var payerReportAttestation: Xmtp_Xmtpv4_Envelopes_PayerReportAttestation {
    get {
      if case .payerReportAttestation(let v)? = payload {return v}
      return Xmtp_Xmtpv4_Envelopes_PayerReportAttestation()
    }
    set {payload = .payerReportAttestation(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case groupMessage(Xmtp_Mls_Api_V1_GroupMessageInput)
    case welcomeMessage(Xmtp_Mls_Api_V1_WelcomeMessageInput)
    case uploadKeyPackage(Xmtp_Mls_Api_V1_UploadKeyPackageRequest)
    case identityUpdate(Xmtp_Identity_Associations_IdentityUpdate)
    case payerReport(Xmtp_Xmtpv4_Envelopes_PayerReport)
    case payerReportAttestation(Xmtp_Xmtpv4_Envelopes_PayerReportAttestation)

  }

  public init() {}

  fileprivate var _aad: Xmtp_Xmtpv4_Envelopes_AuthenticatedData? = nil
}

/// Wraps client envelope with payer signature
public struct Xmtp_Xmtpv4_Envelopes_PayerEnvelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protobuf serialized
  public var unsignedClientEnvelope: Data = Data()

  public var payerSignature: Xmtp_Identity_Associations_RecoverableEcdsaSignature {
    get {return _payerSignature ?? Xmtp_Identity_Associations_RecoverableEcdsaSignature()}
    set {_payerSignature = newValue}
  }
  /// Returns true if `payerSignature` has been explicitly set.
  public var hasPayerSignature: Bool {return self._payerSignature != nil}
  /// Clears the value of `payerSignature`. Subsequent reads from it will return its default value.
  public mutating func clearPayerSignature() {self._payerSignature = nil}

  public var targetOriginator: UInt32 = 0

  public var messageRetentionDays: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payerSignature: Xmtp_Identity_Associations_RecoverableEcdsaSignature? = nil
}

/// For blockchain envelopes, these fields are set by the smart contract
public struct Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var originatorNodeID: UInt32 = 0

  public var originatorSequenceID: UInt64 = 0

  public var originatorNs: Int64 = 0

  public var payerEnvelopeBytes: Data = Data()

  /// The base fee for the message in picodollars
  public var baseFeePicodollars: UInt64 = 0

  /// The congestion fee for the message in picodollars
  public var congestionFeePicodollars: UInt64 = 0

  public var expiryUnixtime: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An alternative to a signature for blockchain payloads
public struct Xmtp_Xmtpv4_Envelopes_BlockchainProof: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Signed originator envelope
public struct Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protobuf serialized
  public var unsignedOriginatorEnvelope: Data = Data()

  public var proof: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope.OneOf_Proof? = nil

  public var originatorSignature: Xmtp_Identity_Associations_RecoverableEcdsaSignature {
    get {
      if case .originatorSignature(let v)? = proof {return v}
      return Xmtp_Identity_Associations_RecoverableEcdsaSignature()
    }
    set {proof = .originatorSignature(newValue)}
  }

  public var blockchainProof: Xmtp_Xmtpv4_Envelopes_BlockchainProof {
    get {
      if case .blockchainProof(let v)? = proof {return v}
      return Xmtp_Xmtpv4_Envelopes_BlockchainProof()
    }
    set {proof = .blockchainProof(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Proof: Equatable, Sendable {
    case originatorSignature(Xmtp_Identity_Associations_RecoverableEcdsaSignature)
    case blockchainProof(Xmtp_Xmtpv4_Envelopes_BlockchainProof)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.xmtpv4.envelopes"

extension Xmtp_Xmtpv4_Envelopes_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}node_id_to_sequence_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufUInt64>.self, value: &self.nodeIDToSequenceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeIDToSequenceID.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufUInt64>.self, value: self.nodeIDToSequenceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_Cursor, rhs: Xmtp_Xmtpv4_Envelopes_Cursor) -> Bool {
    if lhs.nodeIDToSequenceID != rhs.nodeIDToSequenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_AuthenticatedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticatedData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}target_topic\0\u{3}depends_on\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.targetTopic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dependsOn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetTopic.isEmpty {
      try visitor.visitSingularBytesField(value: self.targetTopic, fieldNumber: 2)
    }
    try { if let v = self._dependsOn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_AuthenticatedData, rhs: Xmtp_Xmtpv4_Envelopes_AuthenticatedData) -> Bool {
    if lhs.targetTopic != rhs.targetTopic {return false}
    if lhs._dependsOn != rhs._dependsOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_ClientEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientEnvelope"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}aad\0\u{3}group_message\0\u{3}welcome_message\0\u{3}upload_key_package\0\u{3}identity_update\0\u{3}payer_report\0\u{3}payer_report_attestation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._aad) }()
      case 2: try {
        var v: Xmtp_Mls_Api_V1_GroupMessageInput?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupMessage(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessageInput?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .welcomeMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .welcomeMessage(v)
        }
      }()
      case 4: try {
        var v: Xmtp_Mls_Api_V1_UploadKeyPackageRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .uploadKeyPackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .uploadKeyPackage(v)
        }
      }()
      case 5: try {
        var v: Xmtp_Identity_Associations_IdentityUpdate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .identityUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .identityUpdate(v)
        }
      }()
      case 6: try {
        var v: Xmtp_Xmtpv4_Envelopes_PayerReport?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .payerReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .payerReport(v)
        }
      }()
      case 7: try {
        var v: Xmtp_Xmtpv4_Envelopes_PayerReportAttestation?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .payerReportAttestation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .payerReportAttestation(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aad {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.payload {
    case .groupMessage?: try {
      guard case .groupMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .welcomeMessage?: try {
      guard case .welcomeMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .uploadKeyPackage?: try {
      guard case .uploadKeyPackage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .identityUpdate?: try {
      guard case .identityUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .payerReport?: try {
      guard case .payerReport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .payerReportAttestation?: try {
      guard case .payerReportAttestation(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_ClientEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_ClientEnvelope) -> Bool {
    if lhs._aad != rhs._aad {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_PayerEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayerEnvelope"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}unsigned_client_envelope\0\u{3}payer_signature\0\u{3}target_originator\0\u{3}message_retention_days\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unsignedClientEnvelope) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payerSignature) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.targetOriginator) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.messageRetentionDays) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unsignedClientEnvelope.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedClientEnvelope, fieldNumber: 1)
    }
    try { if let v = self._payerSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.targetOriginator != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetOriginator, fieldNumber: 3)
    }
    if self.messageRetentionDays != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageRetentionDays, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_PayerEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_PayerEnvelope) -> Bool {
    if lhs.unsignedClientEnvelope != rhs.unsignedClientEnvelope {return false}
    if lhs._payerSignature != rhs._payerSignature {return false}
    if lhs.targetOriginator != rhs.targetOriginator {return false}
    if lhs.messageRetentionDays != rhs.messageRetentionDays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsignedOriginatorEnvelope"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}originator_node_id\0\u{3}originator_sequence_id\0\u{3}originator_ns\0\u{3}payer_envelope_bytes\0\u{3}base_fee_picodollars\0\u{3}congestion_fee_picodollars\0\u{3}expiry_unixtime\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.originatorNodeID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.originatorSequenceID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.originatorNs) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payerEnvelopeBytes) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.baseFeePicodollars) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.congestionFeePicodollars) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.expiryUnixtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.originatorNodeID != 0 {
      try visitor.visitSingularUInt32Field(value: self.originatorNodeID, fieldNumber: 1)
    }
    if self.originatorSequenceID != 0 {
      try visitor.visitSingularUInt64Field(value: self.originatorSequenceID, fieldNumber: 2)
    }
    if self.originatorNs != 0 {
      try visitor.visitSingularInt64Field(value: self.originatorNs, fieldNumber: 3)
    }
    if !self.payerEnvelopeBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.payerEnvelopeBytes, fieldNumber: 4)
    }
    if self.baseFeePicodollars != 0 {
      try visitor.visitSingularUInt64Field(value: self.baseFeePicodollars, fieldNumber: 5)
    }
    if self.congestionFeePicodollars != 0 {
      try visitor.visitSingularUInt64Field(value: self.congestionFeePicodollars, fieldNumber: 6)
    }
    if self.expiryUnixtime != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiryUnixtime, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope) -> Bool {
    if lhs.originatorNodeID != rhs.originatorNodeID {return false}
    if lhs.originatorSequenceID != rhs.originatorSequenceID {return false}
    if lhs.originatorNs != rhs.originatorNs {return false}
    if lhs.payerEnvelopeBytes != rhs.payerEnvelopeBytes {return false}
    if lhs.baseFeePicodollars != rhs.baseFeePicodollars {return false}
    if lhs.congestionFeePicodollars != rhs.congestionFeePicodollars {return false}
    if lhs.expiryUnixtime != rhs.expiryUnixtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_BlockchainProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockchainProof"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transaction_hash\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transactionHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.transactionHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_BlockchainProof, rhs: Xmtp_Xmtpv4_Envelopes_BlockchainProof) -> Bool {
    if lhs.transactionHash != rhs.transactionHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OriginatorEnvelope"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}unsigned_originator_envelope\0\u{3}originator_signature\0\u{3}blockchain_proof\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unsignedOriginatorEnvelope) }()
      case 2: try {
        var v: Xmtp_Identity_Associations_RecoverableEcdsaSignature?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .originatorSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .originatorSignature(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Xmtpv4_Envelopes_BlockchainProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .blockchainProof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .blockchainProof(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unsignedOriginatorEnvelope.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedOriginatorEnvelope, fieldNumber: 1)
    }
    switch self.proof {
    case .originatorSignature?: try {
      guard case .originatorSignature(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .blockchainProof?: try {
      guard case .blockchainProof(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope) -> Bool {
    if lhs.unsignedOriginatorEnvelope != rhs.unsignedOriginatorEnvelope {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
