// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: keystore_api/v1/keystore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Message content encoding structures

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Application-specific error codes for the Keystore API.
public enum Xmtp_KeystoreApi_V1_ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case invalidInput // = 1
  case noMatchingPrekey // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .invalidInput
    case 2: self = .noMatchingPrekey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .invalidInput: return 1
    case .noMatchingPrekey: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xmtp_KeystoreApi_V1_ErrorCode] = [
    .unspecified,
    .invalidInput,
    .noMatchingPrekey,
  ]

}

/// JobType is used to specify the type of job the caller would like info on
public enum Xmtp_KeystoreApi_V1_JobType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case refreshV1 // = 1
  case refreshV2 // = 2
  case refreshPppp // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .refreshV1
    case 2: self = .refreshV2
    case 3: self = .refreshPppp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .refreshV1: return 1
    case .refreshV2: return 2
    case .refreshPppp: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xmtp_KeystoreApi_V1_JobType] = [
    .unspecified,
    .refreshV1,
    .refreshV2,
    .refreshPppp,
  ]

}

/// Wrapper class for errors from the Keystore API
public struct Xmtp_KeystoreApi_V1_KeystoreError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var code: Xmtp_KeystoreApi_V1_ErrorCode = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Decrypt a batch of messages using X3DH key agreement
public struct Xmtp_KeystoreApi_V1_DecryptV1Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_KeystoreApi_V1_DecryptV1Request.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single decryption request
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var payload: Xmtp_MessageContents_Ciphertext {
      get {return _payload ?? Xmtp_MessageContents_Ciphertext()}
      set {_payload = newValue}
    }
    /// Returns true if `payload` has been explicitly set.
    public var hasPayload: Bool {return self._payload != nil}
    /// Clears the value of `payload`. Subsequent reads from it will return its default value.
    public mutating func clearPayload() {self._payload = nil}

    public var peerKeys: Xmtp_MessageContents_PublicKeyBundle {
      get {return _peerKeys ?? Xmtp_MessageContents_PublicKeyBundle()}
      set {_peerKeys = newValue}
    }
    /// Returns true if `peerKeys` has been explicitly set.
    public var hasPeerKeys: Bool {return self._peerKeys != nil}
    /// Clears the value of `peerKeys`. Subsequent reads from it will return its default value.
    public mutating func clearPeerKeys() {self._peerKeys = nil}

    public var headerBytes: Data = Data()

    public var isSender: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _payload: Xmtp_MessageContents_Ciphertext? = nil
    fileprivate var _peerKeys: Xmtp_MessageContents_PublicKeyBundle? = nil
  }

  public init() {}
}

/// Response type for both V1 and V2 decryption requests
public struct Xmtp_KeystoreApi_V1_DecryptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Xmtp_KeystoreApi_V1_DecryptResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single decryption response
  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var response: Xmtp_KeystoreApi_V1_DecryptResponse.Response.OneOf_Response? = nil

    public var result: Xmtp_KeystoreApi_V1_DecryptResponse.Response.Success {
      get {
        if case .result(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_DecryptResponse.Response.Success()
      }
      set {response = .result(newValue)}
    }

    public var error: Xmtp_KeystoreApi_V1_KeystoreError {
      get {
        if case .error(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_KeystoreError()
      }
      set {response = .error(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Response: Equatable, Sendable {
      case result(Xmtp_KeystoreApi_V1_DecryptResponse.Response.Success)
      case error(Xmtp_KeystoreApi_V1_KeystoreError)

    }

    /// Wrapper object for success response
    public struct Success: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var decrypted: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

/// Decrypt a batch of messages using the appropriate topic keys
public struct Xmtp_KeystoreApi_V1_DecryptV2Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_KeystoreApi_V1_DecryptV2Request.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single decryption request
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var payload: Xmtp_MessageContents_Ciphertext {
      get {return _payload ?? Xmtp_MessageContents_Ciphertext()}
      set {_payload = newValue}
    }
    /// Returns true if `payload` has been explicitly set.
    public var hasPayload: Bool {return self._payload != nil}
    /// Clears the value of `payload`. Subsequent reads from it will return its default value.
    public mutating func clearPayload() {self._payload = nil}

    public var headerBytes: Data = Data()

    public var contentTopic: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _payload: Xmtp_MessageContents_Ciphertext? = nil
  }

  public init() {}
}

/// Encrypt a batch of messages using X3DH key agreement
public struct Xmtp_KeystoreApi_V1_EncryptV1Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_KeystoreApi_V1_EncryptV1Request.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single encryption request
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var recipient: Xmtp_MessageContents_PublicKeyBundle {
      get {return _recipient ?? Xmtp_MessageContents_PublicKeyBundle()}
      set {_recipient = newValue}
    }
    /// Returns true if `recipient` has been explicitly set.
    public var hasRecipient: Bool {return self._recipient != nil}
    /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
    public mutating func clearRecipient() {self._recipient = nil}

    public var payload: Data = Data()

    public var headerBytes: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _recipient: Xmtp_MessageContents_PublicKeyBundle? = nil
  }

  public init() {}
}

/// Response type for both V1 and V2 encryption requests
public struct Xmtp_KeystoreApi_V1_EncryptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Xmtp_KeystoreApi_V1_EncryptResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single encryption response
  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var response: Xmtp_KeystoreApi_V1_EncryptResponse.Response.OneOf_Response? = nil

    public var result: Xmtp_KeystoreApi_V1_EncryptResponse.Response.Success {
      get {
        if case .result(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_EncryptResponse.Response.Success()
      }
      set {response = .result(newValue)}
    }

    public var error: Xmtp_KeystoreApi_V1_KeystoreError {
      get {
        if case .error(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_KeystoreError()
      }
      set {response = .error(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Response: Equatable, Sendable {
      case result(Xmtp_KeystoreApi_V1_EncryptResponse.Response.Success)
      case error(Xmtp_KeystoreApi_V1_KeystoreError)

    }

    /// Wrapper object for success response
    public struct Success: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var encrypted: Xmtp_MessageContents_Ciphertext {
        get {return _encrypted ?? Xmtp_MessageContents_Ciphertext()}
        set {_encrypted = newValue}
      }
      /// Returns true if `encrypted` has been explicitly set.
      public var hasEncrypted: Bool {return self._encrypted != nil}
      /// Clears the value of `encrypted`. Subsequent reads from it will return its default value.
      public mutating func clearEncrypted() {self._encrypted = nil}

      public var senderHmac: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _encrypted: Xmtp_MessageContents_Ciphertext? = nil
    }

    public init() {}
  }

  public init() {}
}

/// Encrypt a batch of messages using the appropriate topic keys
public struct Xmtp_KeystoreApi_V1_EncryptV2Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_KeystoreApi_V1_EncryptV2Request.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single encryption request
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var payload: Data = Data()

    public var headerBytes: Data = Data()

    public var contentTopic: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Encrypt a message for yourself
public struct Xmtp_KeystoreApi_V1_SelfEncryptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_KeystoreApi_V1_SelfEncryptRequest.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request type
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var payload: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Response type for SelfEncryptRequest
public struct Xmtp_KeystoreApi_V1_SelfEncryptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Response type
  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var response: Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.OneOf_Response? = nil

    public var result: Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.Success {
      get {
        if case .result(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.Success()
      }
      set {response = .result(newValue)}
    }

    public var error: Xmtp_KeystoreApi_V1_KeystoreError {
      get {
        if case .error(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_KeystoreError()
      }
      set {response = .error(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Response: Equatable, Sendable {
      case result(Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.Success)
      case error(Xmtp_KeystoreApi_V1_KeystoreError)

    }

    /// Success response
    public struct Success: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var encrypted: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

/// SelfDecryptRequest
public struct Xmtp_KeystoreApi_V1_SelfDecryptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_KeystoreApi_V1_SelfDecryptRequest.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request type
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var payload: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Get the private preferences topic identifier
public struct Xmtp_KeystoreApi_V1_GetPrivatePreferencesTopicIdentifierResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create an invite payload, and store the topic keys in the Keystore
public struct Xmtp_KeystoreApi_V1_CreateInviteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Xmtp_MessageContents_InvitationV1.Context {
    get {return _context ?? Xmtp_MessageContents_InvitationV1.Context()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var recipient: Xmtp_MessageContents_SignedPublicKeyBundle {
    get {return _recipient ?? Xmtp_MessageContents_SignedPublicKeyBundle()}
    set {_recipient = newValue}
  }
  /// Returns true if `recipient` has been explicitly set.
  public var hasRecipient: Bool {return self._recipient != nil}
  /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
  public mutating func clearRecipient() {self._recipient = nil}

  public var createdNs: UInt64 = 0

  public var consentProof: Xmtp_MessageContents_ConsentProofPayload {
    get {return _consentProof ?? Xmtp_MessageContents_ConsentProofPayload()}
    set {_consentProof = newValue}
  }
  /// Returns true if `consentProof` has been explicitly set.
  public var hasConsentProof: Bool {return self._consentProof != nil}
  /// Clears the value of `consentProof`. Subsequent reads from it will return its default value.
  public mutating func clearConsentProof() {self._consentProof = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Xmtp_MessageContents_InvitationV1.Context? = nil
  fileprivate var _recipient: Xmtp_MessageContents_SignedPublicKeyBundle? = nil
  fileprivate var _consentProof: Xmtp_MessageContents_ConsentProofPayload? = nil
}

/// Response to a CreateInviteRequest
public struct Xmtp_KeystoreApi_V1_CreateInviteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversation: Xmtp_MessageContents_ConversationReference {
    get {return _conversation ?? Xmtp_MessageContents_ConversationReference()}
    set {_conversation = newValue}
  }
  /// Returns true if `conversation` has been explicitly set.
  public var hasConversation: Bool {return self._conversation != nil}
  /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
  public mutating func clearConversation() {self._conversation = nil}

  public var payload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversation: Xmtp_MessageContents_ConversationReference? = nil
}

/// Request to save a batch of invite messages to the Keystore
public struct Xmtp_KeystoreApi_V1_SaveInvitesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_KeystoreApi_V1_SaveInvitesRequest.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Mirrors xmtp.envelope schema
  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contentTopic: String = String()

    public var timestampNs: UInt64 = 0

    public var payload: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Response to a SaveInvitesRequest
public struct Xmtp_KeystoreApi_V1_SaveInvitesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single response
  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var response: Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.OneOf_Response? = nil

    public var result: Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.Success {
      get {
        if case .result(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.Success()
      }
      set {response = .result(newValue)}
    }

    public var error: Xmtp_KeystoreApi_V1_KeystoreError {
      get {
        if case .error(let v)? = response {return v}
        return Xmtp_KeystoreApi_V1_KeystoreError()
      }
      set {response = .error(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Response: Equatable, Sendable {
      case result(Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.Success)
      case error(Xmtp_KeystoreApi_V1_KeystoreError)

    }

    /// Wrapper object for success response
    public struct Success: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var conversation: Xmtp_MessageContents_ConversationReference {
        get {return _conversation ?? Xmtp_MessageContents_ConversationReference()}
        set {_conversation = newValue}
      }
      /// Returns true if `conversation` has been explicitly set.
      public var hasConversation: Bool {return self._conversation != nil}
      /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
      public mutating func clearConversation() {self._conversation = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _conversation: Xmtp_MessageContents_ConversationReference? = nil
    }

    public init() {}
  }

  public init() {}
}

/// CreateAuthTokenRequest is used to create an auth token for the XMTP API
public struct Xmtp_KeystoreApi_V1_CreateAuthTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestampNs: UInt64 {
    get {return _timestampNs ?? 0}
    set {_timestampNs = newValue}
  }
  /// Returns true if `timestampNs` has been explicitly set.
  public var hasTimestampNs: Bool {return self._timestampNs != nil}
  /// Clears the value of `timestampNs`. Subsequent reads from it will return its default value.
  public mutating func clearTimestampNs() {self._timestampNs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestampNs: UInt64? = nil
}

/// SaveV1ConversationsRequest is used to save a batch of conversations to the
/// built in persistence
public struct Xmtp_KeystoreApi_V1_SaveV1ConversationsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversations: [Xmtp_MessageContents_ConversationReference] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Placeholder response type for SaveV1Conversations
public struct Xmtp_KeystoreApi_V1_SaveV1ConversationsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for GetV2Conversations
public struct Xmtp_KeystoreApi_V1_GetConversationsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversations: [Xmtp_MessageContents_ConversationReference] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to check if the Keystore implementation has been setup for the given
/// wallet address Only used for MM Snap Keystore currently
public struct Xmtp_KeystoreApi_V1_GetKeystoreStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var walletAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to GetKeystoreStatusRequest
public struct Xmtp_KeystoreApi_V1_GetKeystoreStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Xmtp_KeystoreApi_V1_GetKeystoreStatusResponse.KeystoreStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the Keystore for the specified wallet address
  public enum KeystoreStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case uninitialized // = 1
    case initialized // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .uninitialized
      case 2: self = .initialized
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .uninitialized: return 1
      case .initialized: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Xmtp_KeystoreApi_V1_GetKeystoreStatusResponse.KeystoreStatus] = [
      .unspecified,
      .uninitialized,
      .initialized,
    ]

  }

  public init() {}
}

/// Used to initialize the Keystore with a private key bundle retrieved from the
/// client
public struct Xmtp_KeystoreApi_V1_InitKeystoreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bundle: Xmtp_KeystoreApi_V1_InitKeystoreRequest.OneOf_Bundle? = nil

  public var v1: Xmtp_MessageContents_PrivateKeyBundleV1 {
    get {
      if case .v1(let v)? = bundle {return v}
      return Xmtp_MessageContents_PrivateKeyBundleV1()
    }
    set {bundle = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Bundle: Equatable, Sendable {
    case v1(Xmtp_MessageContents_PrivateKeyBundleV1)

  }

  public init() {}
}

/// Response to the request to initialize the Keystore
public struct Xmtp_KeystoreApi_V1_InitKeystoreResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: Xmtp_KeystoreApi_V1_KeystoreError {
    get {return _error ?? Xmtp_KeystoreApi_V1_KeystoreError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Xmtp_KeystoreApi_V1_KeystoreError? = nil
}

/// SignDigestRequest is used to sign a digest with either the identity key
/// or a prekey
public struct Xmtp_KeystoreApi_V1_SignDigestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var digest: Data = Data()

  public var signer: Xmtp_KeystoreApi_V1_SignDigestRequest.OneOf_Signer? = nil

  public var identityKey: Bool {
    get {
      if case .identityKey(let v)? = signer {return v}
      return false
    }
    set {signer = .identityKey(newValue)}
  }

  public var prekeyIndex: UInt32 {
    get {
      if case .prekeyIndex(let v)? = signer {return v}
      return 0
    }
    set {signer = .prekeyIndex(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signer: Equatable, Sendable {
    case identityKey(Bool)
    case prekeyIndex(UInt32)

  }

  public init() {}
}

/// GetRefreshJobRequest is used to get the last run time of a refresh job
public struct Xmtp_KeystoreApi_V1_GetRefreshJobRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobType: Xmtp_KeystoreApi_V1_JobType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetRefreshJobResponse is used to return the last run time of a refresh job
public struct Xmtp_KeystoreApi_V1_GetRefreshJobResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastRunNs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetRefreshJobRequest is used to set the last run time of a refresh job
public struct Xmtp_KeystoreApi_V1_SetRefeshJobRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobType: Xmtp_KeystoreApi_V1_JobType = .unspecified

  public var lastRunNs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetRefreshJobResponse is an empty response type
public struct Xmtp_KeystoreApi_V1_SetRefreshJobResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A mapping of topics to their decrypted invitations
public struct Xmtp_KeystoreApi_V1_TopicMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: Dictionary<String,Xmtp_KeystoreApi_V1_TopicMap.TopicData> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TopicData wraps the invitation and the timestamp it was created
  public struct TopicData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var createdNs: UInt64 = 0

    public var peerAddress: String = String()

    public var invitation: Xmtp_MessageContents_InvitationV1 {
      get {return _invitation ?? Xmtp_MessageContents_InvitationV1()}
      set {_invitation = newValue}
    }
    /// Returns true if `invitation` has been explicitly set.
    public var hasInvitation: Bool {return self._invitation != nil}
    /// Clears the value of `invitation`. Subsequent reads from it will return its default value.
    public mutating func clearInvitation() {self._invitation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _invitation: Xmtp_MessageContents_InvitationV1? = nil
  }

  public init() {}
}

/// Used to get a mapping of conversation topics to their HMAC keys
public struct Xmtp_KeystoreApi_V1_GetConversationHmacKeysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A mapping of topics to their HMAC keys
public struct Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hmacKeys: Dictionary<String,Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeys> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// HmacKeyData wraps the HMAC key and the number of 30 day periods since epoch
  public struct HmacKeyData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var thirtyDayPeriodsSinceEpoch: Int32 = 0

    public var hmacKey: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// HmacKeys represents multiple HmacKeyData objects
  public struct HmacKeys: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeyData] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A mapping of message hashes to their private preferences action
public struct Xmtp_KeystoreApi_V1_PrivatePreferencesActionMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actions: Dictionary<String,Xmtp_MessageContents_PrivatePreferencesAction> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.keystore_api.v1"

extension Xmtp_KeystoreApi_V1_ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ERROR_CODE_UNSPECIFIED\0\u{1}ERROR_CODE_INVALID_INPUT\0\u{1}ERROR_CODE_NO_MATCHING_PREKEY\0")
}

extension Xmtp_KeystoreApi_V1_JobType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0JOB_TYPE_UNSPECIFIED\0\u{1}JOB_TYPE_REFRESH_V1\0\u{1}JOB_TYPE_REFRESH_V2\0\u{1}JOB_TYPE_REFRESH_PPPP\0")
}

extension Xmtp_KeystoreApi_V1_KeystoreError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeystoreError"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{1}code\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_KeystoreError, rhs: Xmtp_KeystoreApi_V1_KeystoreError) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_DecryptV1Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptV1Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_DecryptV1Request, rhs: Xmtp_KeystoreApi_V1_DecryptV1Request) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_DecryptV1Request.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_DecryptV1Request.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payload\0\u{3}peer_keys\0\u{3}header_bytes\0\u{3}is_sender\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerKeys) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.headerBytes) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._peerKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.headerBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.headerBytes, fieldNumber: 3)
    }
    if self.isSender != false {
      try visitor.visitSingularBoolField(value: self.isSender, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_DecryptV1Request.Request, rhs: Xmtp_KeystoreApi_V1_DecryptV1Request.Request) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs._peerKeys != rhs._peerKeys {return false}
    if lhs.headerBytes != rhs.headerBytes {return false}
    if lhs.isSender != rhs.isSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_DecryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_DecryptResponse, rhs: Xmtp_KeystoreApi_V1_DecryptResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_DecryptResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_DecryptResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_KeystoreApi_V1_DecryptResponse.Response.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .result(v)
        }
      }()
      case 2: try {
        var v: Xmtp_KeystoreApi_V1_KeystoreError?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .result?: try {
      guard case .result(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_DecryptResponse.Response, rhs: Xmtp_KeystoreApi_V1_DecryptResponse.Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_DecryptResponse.Response.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_DecryptResponse.Response.protoMessageName + ".Success"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}decrypted\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.decrypted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.decrypted.isEmpty {
      try visitor.visitSingularBytesField(value: self.decrypted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_DecryptResponse.Response.Success, rhs: Xmtp_KeystoreApi_V1_DecryptResponse.Response.Success) -> Bool {
    if lhs.decrypted != rhs.decrypted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_DecryptV2Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptV2Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_DecryptV2Request, rhs: Xmtp_KeystoreApi_V1_DecryptV2Request) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_DecryptV2Request.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_DecryptV2Request.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payload\0\u{3}header_bytes\0\u{3}content_topic\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.headerBytes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentTopic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.headerBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.headerBytes, fieldNumber: 2)
    }
    if !self.contentTopic.isEmpty {
      try visitor.visitSingularStringField(value: self.contentTopic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_DecryptV2Request.Request, rhs: Xmtp_KeystoreApi_V1_DecryptV2Request.Request) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.headerBytes != rhs.headerBytes {return false}
    if lhs.contentTopic != rhs.contentTopic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_EncryptV1Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptV1Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_EncryptV1Request, rhs: Xmtp_KeystoreApi_V1_EncryptV1Request) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_EncryptV1Request.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_EncryptV1Request.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}recipient\0\u{1}payload\0\u{3}header_bytes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recipient) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.headerBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.headerBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.headerBytes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_EncryptV1Request.Request, rhs: Xmtp_KeystoreApi_V1_EncryptV1Request.Request) -> Bool {
    if lhs._recipient != rhs._recipient {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.headerBytes != rhs.headerBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_EncryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_EncryptResponse, rhs: Xmtp_KeystoreApi_V1_EncryptResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_EncryptResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_EncryptResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_KeystoreApi_V1_EncryptResponse.Response.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .result(v)
        }
      }()
      case 2: try {
        var v: Xmtp_KeystoreApi_V1_KeystoreError?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .result?: try {
      guard case .result(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_EncryptResponse.Response, rhs: Xmtp_KeystoreApi_V1_EncryptResponse.Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_EncryptResponse.Response.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_EncryptResponse.Response.protoMessageName + ".Success"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}encrypted\0\u{3}sender_hmac\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._encrypted) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.senderHmac) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._encrypted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.senderHmac.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderHmac, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_EncryptResponse.Response.Success, rhs: Xmtp_KeystoreApi_V1_EncryptResponse.Response.Success) -> Bool {
    if lhs._encrypted != rhs._encrypted {return false}
    if lhs.senderHmac != rhs.senderHmac {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_EncryptV2Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptV2Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_EncryptV2Request, rhs: Xmtp_KeystoreApi_V1_EncryptV2Request) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_EncryptV2Request.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_EncryptV2Request.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payload\0\u{3}header_bytes\0\u{3}content_topic\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.headerBytes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentTopic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    if !self.headerBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.headerBytes, fieldNumber: 2)
    }
    if !self.contentTopic.isEmpty {
      try visitor.visitSingularStringField(value: self.contentTopic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_EncryptV2Request.Request, rhs: Xmtp_KeystoreApi_V1_EncryptV2Request.Request) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.headerBytes != rhs.headerBytes {return false}
    if lhs.contentTopic != rhs.contentTopic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SelfEncryptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelfEncryptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SelfEncryptRequest, rhs: Xmtp_KeystoreApi_V1_SelfEncryptRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SelfEncryptRequest.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_SelfEncryptRequest.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SelfEncryptRequest.Request, rhs: Xmtp_KeystoreApi_V1_SelfEncryptRequest.Request) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SelfEncryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelfEncryptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SelfEncryptResponse, rhs: Xmtp_KeystoreApi_V1_SelfEncryptResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_SelfEncryptResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .result(v)
        }
      }()
      case 2: try {
        var v: Xmtp_KeystoreApi_V1_KeystoreError?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .result?: try {
      guard case .result(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response, rhs: Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.protoMessageName + ".Success"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}encrypted\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encrypted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encrypted.isEmpty {
      try visitor.visitSingularBytesField(value: self.encrypted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.Success, rhs: Xmtp_KeystoreApi_V1_SelfEncryptResponse.Response.Success) -> Bool {
    if lhs.encrypted != rhs.encrypted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SelfDecryptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelfDecryptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SelfDecryptRequest, rhs: Xmtp_KeystoreApi_V1_SelfDecryptRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SelfDecryptRequest.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_SelfDecryptRequest.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SelfDecryptRequest.Request, rhs: Xmtp_KeystoreApi_V1_SelfDecryptRequest.Request) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetPrivatePreferencesTopicIdentifierResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPrivatePreferencesTopicIdentifierResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetPrivatePreferencesTopicIdentifierResponse, rhs: Xmtp_KeystoreApi_V1_GetPrivatePreferencesTopicIdentifierResponse) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_CreateInviteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInviteRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}context\0\u{1}recipient\0\u{3}created_ns\0\u{3}consent_proof\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recipient) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdNs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._consentProof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recipient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.createdNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdNs, fieldNumber: 3)
    }
    try { if let v = self._consentProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_CreateInviteRequest, rhs: Xmtp_KeystoreApi_V1_CreateInviteRequest) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs._recipient != rhs._recipient {return false}
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs._consentProof != rhs._consentProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_CreateInviteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInviteResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversation\0\u{1}payload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_CreateInviteResponse, rhs: Xmtp_KeystoreApi_V1_CreateInviteResponse) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SaveInvitesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveInvitesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SaveInvitesRequest, rhs: Xmtp_KeystoreApi_V1_SaveInvitesRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SaveInvitesRequest.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_SaveInvitesRequest.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}content_topic\0\u{3}timestamp_ns\0\u{1}payload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentTopic) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestampNs) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentTopic.isEmpty {
      try visitor.visitSingularStringField(value: self.contentTopic, fieldNumber: 1)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampNs, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SaveInvitesRequest.Request, rhs: Xmtp_KeystoreApi_V1_SaveInvitesRequest.Request) -> Bool {
    if lhs.contentTopic != rhs.contentTopic {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SaveInvitesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveInvitesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SaveInvitesResponse, rhs: Xmtp_KeystoreApi_V1_SaveInvitesResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_SaveInvitesResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .result(v)
        }
      }()
      case 2: try {
        var v: Xmtp_KeystoreApi_V1_KeystoreError?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .result?: try {
      guard case .result(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response, rhs: Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.protoMessageName + ".Success"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.Success, rhs: Xmtp_KeystoreApi_V1_SaveInvitesResponse.Response.Success) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_CreateAuthTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAuthTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timestamp_ns\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._timestampNs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestampNs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_CreateAuthTokenRequest, rhs: Xmtp_KeystoreApi_V1_CreateAuthTokenRequest) -> Bool {
    if lhs._timestampNs != rhs._timestampNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SaveV1ConversationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveV1ConversationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conversations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SaveV1ConversationsRequest, rhs: Xmtp_KeystoreApi_V1_SaveV1ConversationsRequest) -> Bool {
    if lhs.conversations != rhs.conversations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SaveV1ConversationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveV1ConversationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SaveV1ConversationsResponse, rhs: Xmtp_KeystoreApi_V1_SaveV1ConversationsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetConversationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConversationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conversations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetConversationsResponse, rhs: Xmtp_KeystoreApi_V1_GetConversationsResponse) -> Bool {
    if lhs.conversations != rhs.conversations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetKeystoreStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetKeystoreStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}wallet_address\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.walletAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.walletAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetKeystoreStatusRequest, rhs: Xmtp_KeystoreApi_V1_GetKeystoreStatusRequest) -> Bool {
    if lhs.walletAddress != rhs.walletAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetKeystoreStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetKeystoreStatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetKeystoreStatusResponse, rhs: Xmtp_KeystoreApi_V1_GetKeystoreStatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetKeystoreStatusResponse.KeystoreStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0KEYSTORE_STATUS_UNSPECIFIED\0\u{1}KEYSTORE_STATUS_UNINITIALIZED\0\u{1}KEYSTORE_STATUS_INITIALIZED\0")
}

extension Xmtp_KeystoreApi_V1_InitKeystoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitKeystoreRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}v1\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_MessageContents_PrivateKeyBundleV1?
        var hadOneofValue = false
        if let current = self.bundle {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.bundle = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.bundle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_InitKeystoreRequest, rhs: Xmtp_KeystoreApi_V1_InitKeystoreRequest) -> Bool {
    if lhs.bundle != rhs.bundle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_InitKeystoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitKeystoreResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_InitKeystoreResponse, rhs: Xmtp_KeystoreApi_V1_InitKeystoreResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SignDigestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignDigestRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}digest\0\u{3}identity_key\0\u{3}prekey_index\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.digest) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.signer != nil {try decoder.handleConflictingOneOf()}
          self.signer = .identityKey(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.signer != nil {try decoder.handleConflictingOneOf()}
          self.signer = .prekeyIndex(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.digest.isEmpty {
      try visitor.visitSingularBytesField(value: self.digest, fieldNumber: 1)
    }
    switch self.signer {
    case .identityKey?: try {
      guard case .identityKey(let v)? = self.signer else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .prekeyIndex?: try {
      guard case .prekeyIndex(let v)? = self.signer else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SignDigestRequest, rhs: Xmtp_KeystoreApi_V1_SignDigestRequest) -> Bool {
    if lhs.digest != rhs.digest {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetRefreshJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRefreshJobRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.jobType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.jobType != .unspecified {
      try visitor.visitSingularEnumField(value: self.jobType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetRefreshJobRequest, rhs: Xmtp_KeystoreApi_V1_GetRefreshJobRequest) -> Bool {
    if lhs.jobType != rhs.jobType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetRefreshJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRefreshJobResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}last_run_ns\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lastRunNs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastRunNs != 0 {
      try visitor.visitSingularInt64Field(value: self.lastRunNs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetRefreshJobResponse, rhs: Xmtp_KeystoreApi_V1_GetRefreshJobResponse) -> Bool {
    if lhs.lastRunNs != rhs.lastRunNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SetRefeshJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetRefeshJobRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_type\0\u{3}last_run_ns\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.jobType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastRunNs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.jobType != .unspecified {
      try visitor.visitSingularEnumField(value: self.jobType, fieldNumber: 1)
    }
    if self.lastRunNs != 0 {
      try visitor.visitSingularInt64Field(value: self.lastRunNs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SetRefeshJobRequest, rhs: Xmtp_KeystoreApi_V1_SetRefeshJobRequest) -> Bool {
    if lhs.jobType != rhs.jobType {return false}
    if lhs.lastRunNs != rhs.lastRunNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_SetRefreshJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetRefreshJobResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_SetRefreshJobResponse, rhs: Xmtp_KeystoreApi_V1_SetRefreshJobResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_TopicMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicMap"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}topics\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Xmtp_KeystoreApi_V1_TopicMap.TopicData>.self, value: &self.topics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Xmtp_KeystoreApi_V1_TopicMap.TopicData>.self, value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_TopicMap, rhs: Xmtp_KeystoreApi_V1_TopicMap) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_TopicMap.TopicData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_TopicMap.protoMessageName + ".TopicData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}created_ns\0\u{3}peer_address\0\u{1}invitation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.createdNs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._invitation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.createdNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdNs, fieldNumber: 1)
    }
    if !self.peerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.peerAddress, fieldNumber: 2)
    }
    try { if let v = self._invitation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_TopicMap.TopicData, rhs: Xmtp_KeystoreApi_V1_TopicMap.TopicData) -> Bool {
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs.peerAddress != rhs.peerAddress {return false}
    if lhs._invitation != rhs._invitation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetConversationHmacKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConversationHmacKeysRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}topics\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.topics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedStringField(value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysRequest, rhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysRequest) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConversationHmacKeysResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}hmac_keys\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeys>.self, value: &self.hmacKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hmacKeys.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeys>.self, value: self.hmacKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse, rhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse) -> Bool {
    if lhs.hmacKeys != rhs.hmacKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.protoMessageName + ".HmacKeyData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thirty_day_periods_since_epoch\0\u{3}hmac_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.thirtyDayPeriodsSinceEpoch) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hmacKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.thirtyDayPeriodsSinceEpoch != 0 {
      try visitor.visitSingularInt32Field(value: self.thirtyDayPeriodsSinceEpoch, fieldNumber: 1)
    }
    if !self.hmacKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hmacKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeyData, rhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeyData) -> Bool {
    if lhs.thirtyDayPeriodsSinceEpoch != rhs.thirtyDayPeriodsSinceEpoch {return false}
    if lhs.hmacKey != rhs.hmacKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.protoMessageName + ".HmacKeys"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeys, rhs: Xmtp_KeystoreApi_V1_GetConversationHmacKeysResponse.HmacKeys) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_KeystoreApi_V1_PrivatePreferencesActionMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivatePreferencesActionMap"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}actions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Xmtp_MessageContents_PrivatePreferencesAction>.self, value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Xmtp_MessageContents_PrivatePreferencesAction>.self, value: self.actions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_KeystoreApi_V1_PrivatePreferencesActionMap, rhs: Xmtp_KeystoreApi_V1_PrivatePreferencesActionMap) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
