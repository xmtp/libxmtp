CREATE TABLE __diesel_schema_migrations (
       version VARCHAR(50) PRIMARY KEY NOT NULL,
       run_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE openmls_key_value (
    version INT NOT NULL,
    key_bytes BLOB NOT NULL,
    value_bytes BLOB NOT NULL,
    PRIMARY KEY (version, key_bytes)
);
CREATE TABLE association_state (
    "inbox_id" TEXT NOT NULL,
    "sequence_id" BIGINT NOT NULL,
    "state" BLOB NOT NULL,
    PRIMARY KEY ("inbox_id", "sequence_id")
);
CREATE TABLE openmls_key_store(
    key_bytes BLOB PRIMARY KEY NOT NULL,
    value_bytes BLOB NOT NULL
);
CREATE TABLE IF NOT EXISTS "identity"(
    "inbox_id" text NOT NULL,
    "installation_keys" BLOB NOT NULL,
    "credential_bytes" BLOB NOT NULL,
    rowid integer PRIMARY KEY CHECK (rowid = 1) -- There can only be one identity
, next_key_package_rotation_ns BIGINT);
CREATE TABLE IF NOT EXISTS "groups"(
    -- Random ID generated by group creator
    "id" BLOB PRIMARY KEY NOT NULL,
    -- Based on the timestamp of the welcome message
    "created_at_ns" bigint NOT NULL,
    -- Enum of GROUP_MEMBERSHIP_STATE
    "membership_state" int NOT NULL,
    -- Last time the installations were checked for the purpose of seeing if any are missing
    "installations_last_checked" bigint NOT NULL,
    -- Values are 1 = Conversation, 2 = Sync
    "added_by_inbox_id" text NOT NULL
, sequence_id bigint, rotated_at_ns BIGINT NOT NULL DEFAULT 0, conversation_type INTEGER NOT NULL DEFAULT 1, dm_id TEXT, last_message_ns BIGINT, message_disappear_from_ns  BIGINT, message_disappear_in_ns BIGINT, paused_for_version TEXT DEFAULT NULL, maybe_forked BOOLEAN NOT NULL DEFAULT FALSE, fork_details TEXT NOT NULL DEFAULT '', originator_id bigint, should_publish_commit_log BOOLEAN NOT NULL DEFAULT FALSE, commit_log_public_key BLOB, is_commit_log_forked BOOLEAN, has_pending_leave_request BOOLEAN);
CREATE INDEX groups_created_at_idx ON GROUPS (created_at_ns);
CREATE INDEX groups_membership_state_created_at_idx ON GROUPS (membership_state, created_at_ns);
CREATE TABLE group_messages(
    -- Derived via generate_message_id() in SDK, which hashes several inputs
    "id" BLOB PRIMARY KEY NOT NULL,
    "group_id" BLOB NOT NULL,
    -- Message contents after decryption
    "decrypted_message_bytes" BLOB NOT NULL,
    -- Based on the timestamp of the message
    "sent_at_ns" bigint NOT NULL,
    -- Enum GROUP_MESSAGE_KIND
    "kind" int NOT NULL,
    -- Could remove this if we added a table mapping installation_ids to wallet addresses
    "sender_installation_id" BLOB NOT NULL,
    -- The inbox_id of the sender
    "sender_inbox_id" text NOT NULL,
    -- Values are: 1 = Published, 2 = Unpublished
    "delivery_status" int NOT NULL DEFAULT 1, content_type INTEGER NOT NULL DEFAULT 0, version_minor INTEGER NOT NULL DEFAULT 0, version_major INTEGER NOT NULL DEFAULT 0, authority_id TEXT NOT NULL DEFAULT '', reference_id BINARY, expire_at_ns BIGINT, sequence_id BIGINT NOT NULL DEFAULT sequence_id, originator_id BIGINT NOT NULL DEFAULT originator_id,
    FOREIGN KEY (group_id) REFERENCES "groups"(id)
);
CREATE INDEX group_messages_group_id_sort_idx ON group_messages(group_id, sent_at_ns);
CREATE TABLE group_intents(
    -- Serial ID auto-generated by the DB
    "id" integer PRIMARY KEY AUTOINCREMENT NOT NULL,
    -- Enum INTENT_KIND
    "kind" int NOT NULL,
    "group_id" BLOB NOT NULL,
    -- Some sort of serializable blob that can be used to re-try the message if the first attempt failed due to conflict
    "data" BLOB NOT NULL,
    -- INTENT_STATE,
    "state" int NOT NULL,
    -- The hash of the encrypted, concrete, form of the message if it was published.
    "payload_hash" BLOB UNIQUE,
    -- (Optional) data needed for the post-commit flow. For example, welcome messages
    "post_commit_data" BLOB,
    -- The number of publish attempts
    "publish_attempts" int NOT NULL DEFAULT 0, staged_commit BLOB, published_in_epoch BIGINT, should_push BOOLEAN NOT NULL DEFAULT TRUE, sequence_id BIGINT, originator_id BIGINT,
    FOREIGN KEY (group_id) REFERENCES "groups"(id)
);
CREATE TABLE sqlite_sequence(name,seq);
CREATE INDEX group_intents_group_id_state ON group_intents(group_id, state);
CREATE TABLE identity_updates(
    -- The inbox_id the update refers to
    "inbox_id" text NOT NULL,
    -- The sequence_id of the update
    "sequence_id" bigint NOT NULL,
    -- Based on the timestamp given by the server
    "server_timestamp_ns" bigint NOT NULL,
    -- Random ID generated by group creator
    "payload" BLOB NOT NULL, originator_id INTEGER NOT NULL DEFAULT 1,
    -- Compound primary key of the `inbox_id` and `sequence_id`
    PRIMARY KEY (inbox_id, sequence_id)
);
CREATE INDEX idx_identity_updates_inbox_id_sequence_id_asc ON identity_updates(inbox_id, sequence_id ASC);
CREATE TABLE IF NOT EXISTS "consent_records"(
    -- Enum of the CONSENT_TYPE (GROUP_ID, INBOX_ID, etc..)
    "entity_type" int NOT NULL,
    -- Enum of CONSENT_STATE (ALLOWED, DENIED, etc..)
    "state" int NOT NULL,
    -- The entity of what has consent (0x00 etc..)
    "entity" text NOT NULL, consented_at_ns BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (entity_type, entity)
);
CREATE TABLE key_package_history (
    "id" integer PRIMARY KEY AUTOINCREMENT NOT NULL,
    "key_package_hash_ref" BLOB UNIQUE NOT NULL,
    "created_at_ns" bigint NOT NULL
, delete_at_ns BIGINT, post_quantum_public_key BLOB);
CREATE INDEX idx_group_messages_reference_id ON group_messages(reference_id);
CREATE TABLE identity_cache (
    inbox_id TEXT NOT NULL,
    identity TEXT NOT NULL,
    identity_kind INT NOT NULL,
    PRIMARY KEY (identity, identity_kind)
);
CREATE TRIGGER msg_inserted AFTER INSERT ON group_messages FOR EACH ROW BEGIN
UPDATE groups
SET
    last_message_ns = NEW.sent_at_ns
WHERE
    id = NEW.group_id
    AND (
        last_message_ns IS NULL
        OR NEW.sent_at_ns > last_message_ns
    );

END;
CREATE TABLE user_preferences (
    id INTEGER PRIMARY KEY NOT NULL DEFAULT 0 CHECK (id = 0),
    hmac_key BLOB,
    hmac_key_cycled_at_ns BIGINT
);
CREATE TABLE processed_device_sync_messages (message_id BLOB PRIMARY KEY NOT NULL);
CREATE TABLE icebox (
    sequence_id BIGINT NOT NULL,
    originator_id BIGINT NOT NULL,
    depending_sequence_id BIGINT,
    depending_originator_id BIGINT,
    envelope_payload BLOB NOT NULL,
    PRIMARY KEY (sequence_id, originator_id),
    CHECK (
        (
            depending_sequence_id IS NULL
            AND depending_originator_id IS NULL
        )
        OR (
            depending_sequence_id IS NOT NULL
            AND depending_originator_id IS NOT NULL
        )
    )
);
CREATE INDEX idx_icebox_dependencies ON icebox (depending_sequence_id, depending_originator_id);
CREATE TABLE events (
    created_at_ns BIGINT NOT NULL,
    group_id BLOB,
    event TEXT NOT NULL,
    details BLOB
, level INTEGER NOT NULL DEFAULT 0, icon TEXT);
CREATE INDEX idx_event_name ON events (event);
CREATE TABLE local_commit_log (
    -- A locally assigned ID for the local log entry
    "rowid" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    "group_id" BLOB NOT NULL,
    -- The sequence ID of the commit being applied
    -- For welcomes, this is the sequence ID of the commit that spawned the welcome
    -- For group creation, this is 0
    "commit_sequence_id" BIGINT NOT NULL,
    -- The encryption state of the group before the commit was applied
    -- https://www.rfc-editor.org/rfc/rfc9420.html#section-8-13
    "last_epoch_authenticator" BLOB NOT NULL,
    -- Whether the commit was successfully applied or not
    -- 1 = Applied, all other values are failures matching the protobuf
    "commit_result" INT NOT NULL,
    -- The state after the commit was applied, or the existing state otherwise
    "applied_epoch_number" BIGINT NOT NULL,
    "applied_epoch_authenticator" BLOB NOT NULL,
    -- Items below this line are for debugging purposes
    "error_message" TEXT,
    "sender_inbox_id" TEXT,
    "sender_installation_id" BLOB,
    "commit_type" TEXT
);
CREATE TABLE remote_commit_log (
    -- The sequence ID of the log entry on the server
    "log_sequence_id" BIGINT NOT NULL,
    "group_id" BLOB NOT NULL,
    -- The sequence ID of the commit being referenced
    "commit_sequence_id" BIGINT NOT NULL,
    -- Whether the commit was successfully applied or not
    -- 1 = Applied, all other values are failures matching the protobuf
    "commit_result" INT NOT NULL,
    -- The state after the commit was applied, or the existing state otherwise
    "applied_epoch_number" BIGINT NOT NULL,
    "applied_epoch_authenticator" BLOB NOT NULL
);
CREATE TABLE refresh_state (
    entity_id BLOB NOT NULL,
    entity_kind INTEGER NOT NULL,
    sequence_id BIGINT NOT NULL CHECK (sequence_id >= 0) ,
    originator_id INTEGER NOT NULL CHECK (originator_id >= 0),
    PRIMARY KEY (entity_id, entity_kind, originator_id)
);
CREATE TABLE readd_status (
    "group_id" BLOB NOT NULL,
    "installation_id" BLOB NOT NULL,
    "requested_at_sequence_id" BIGINT,
    "responded_at_sequence_id" BIGINT,
    PRIMARY KEY ("group_id", "installation_id")
);
CREATE INDEX idx_groups_dm_coalesce_last_message ON groups(COALESCE(dm_id, id), last_message_ns DESC);
CREATE TABLE pending_remove(
group_id BLOB NOT NULL,
inbox_id text NOT NULL,
message_id BLOB NOT NULL,
PRIMARY KEY (inbox_id, group_id));
CREATE TABLE IF NOT EXISTS "tasks" (
  -- Serial ID auto-generated by the DB
  id integer primary key autoincrement not null,
  -- ID of the message that originated the task
  originating_message_sequence_id bigint not null check (originating_message_sequence_id >= 0),
  originating_message_originator_id integer not null check (originating_message_originator_id >= 0),
  -- Timestamp of the task's creation
  created_at_ns bigint not null,
  -- Timestamp of the task's expiration
  expires_at_ns bigint not null,
  -- Number of attempts to execute the task it should be set to 1 initially
  attempts integer not null,
  -- Maximum number of attempts to execute the task
  max_attempts integer not null,
  -- Timestamp of the last attempt to execute the task
  last_attempted_at_ns bigint not null,
  -- Scaling factor between attempts
  backoff_scaling_factor real not null,
  -- Maximum duration to wait between attempts
  max_backoff_duration_ns bigint not null,
  -- Initial duration to wait between attempts
  initial_backoff_duration_ns bigint not null,
  -- Timestamp of the next attempt to execute the task
  next_attempt_at_ns bigint not null,
  -- Hash of the data to execute the task, required for deduplication
  data_hash blob unique not null,
  -- Data to execute the task - a serialized xmtp.mls.database.Task protobuf message
  "data" blob not null
);
CREATE VIEW conversation_list AS
WITH ranked_messages AS (
    SELECT
        gm.group_id,
        gm.id AS message_id,
        gm.decrypted_message_bytes,
        gm.sent_at_ns,
        gm.kind AS message_kind,
        gm.sender_installation_id,
        gm.sender_inbox_id,
        gm.delivery_status,
        gm.content_type,
        gm.version_major,
        gm.version_minor,
        gm.authority_id,
        gm.sequence_id,
        gm.originator_id,
        ROW_NUMBER() OVER (PARTITION BY gm.group_id ORDER BY gm.sent_at_ns DESC) AS row_num
    FROM
        group_messages gm
    WHERE
        gm.kind = 1
        AND gm.content_type IN (0, 1, 4, 6, 7, 8, 9)
)
SELECT
    g.id AS id,
    g.created_at_ns,
    g.membership_state,
    g.installations_last_checked,
    g.added_by_inbox_id,
    g.sequence_id as welcome_sequence_id,
    g.dm_id,
    g.rotated_at_ns,
    g.conversation_type,
    g.is_commit_log_forked,
    rm.message_id,
    rm.decrypted_message_bytes,
    rm.sent_at_ns,
    rm.message_kind,
    rm.sender_installation_id,
    rm.sender_inbox_id,
    rm.delivery_status,
    rm.content_type,
    rm.version_major,
    rm.version_minor,
    rm.authority_id,
    rm.sequence_id,
    rm.originator_id
FROM
    groups g
    LEFT JOIN ranked_messages rm
    ON g.id = rm.group_id AND rm.row_num = 1
ORDER BY COALESCE(rm.sent_at_ns, g.created_at_ns) DESC
/* conversation_list(id,created_at_ns,membership_state,installations_last_checked,added_by_inbox_id,welcome_sequence_id,dm_id,rotated_at_ns,conversation_type,is_commit_log_forked,message_id,decrypted_message_bytes,sent_at_ns,message_kind,sender_installation_id,sender_inbox_id,delivery_status,content_type,version_major,version_minor,authority_id,sequence_id,originator_id) */;
