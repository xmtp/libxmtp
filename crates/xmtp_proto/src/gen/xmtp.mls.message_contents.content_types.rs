// This file is @generated by prost-build.
/// MultiRemoteAttachment message type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiRemoteAttachment {
    /// Array of attachment information
    #[prost(message, repeated, tag = "1")]
    pub attachments: ::prost::alloc::vec::Vec<RemoteAttachmentInfo>,
}
impl ::prost::Name for MultiRemoteAttachment {
    const NAME: &'static str = "MultiRemoteAttachment";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.MultiRemoteAttachment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.MultiRemoteAttachment".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoteAttachmentInfo {
    /// The SHA256 hash of the remote content
    #[prost(string, tag = "1")]
    pub content_digest: ::prost::alloc::string::String,
    /// A 32 byte array for decrypting the remote content payload
    #[prost(bytes = "vec", tag = "2")]
    pub secret: ::prost::alloc::vec::Vec<u8>,
    /// A byte array for the nonce used to encrypt the remote content payload
    #[prost(bytes = "vec", tag = "3")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// A byte array for the salt used to encrypt the remote content payload
    #[prost(bytes = "vec", tag = "4")]
    pub salt: ::prost::alloc::vec::Vec<u8>,
    /// The scheme of the URL. Must be "<https://">
    #[prost(string, tag = "5")]
    pub scheme: ::prost::alloc::string::String,
    /// The URL of the remote content
    #[prost(string, tag = "6")]
    pub url: ::prost::alloc::string::String,
    /// The size of the encrypted content in bytes (max size of 4GB)
    #[prost(uint32, optional, tag = "7")]
    pub content_length: ::core::option::Option<u32>,
    /// The filename of the remote content
    #[prost(string, optional, tag = "8")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for RemoteAttachmentInfo {
    const NAME: &'static str = "RemoteAttachmentInfo";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.RemoteAttachmentInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.RemoteAttachmentInfo".into()
    }
}
/// WalletSendCalls represents parameters for sending wallet calls
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WalletSendCalls {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// hex chain id, e.g., "0x1"
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    /// hex address of the sender, e.g., "0xabc..."
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub calls: ::prost::alloc::vec::Vec<Call>,
    /// wallet capabilities to request or configure
    #[prost(map = "string, string", tag = "5")]
    pub capabilities: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for WalletSendCalls {
    const NAME: &'static str = "WalletSendCalls";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.WalletSendCalls".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.WalletSendCalls".into()
    }
}
/// Call represents an individual transaction call
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Call {
    /// destination address
    #[prost(string, tag = "1")]
    pub to: ::prost::alloc::string::String,
    /// call data payload
    #[prost(string, tag = "2")]
    pub data: ::prost::alloc::string::String,
    /// hex value to send
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
    /// hex gas limit
    #[prost(string, tag = "4")]
    pub gas: ::prost::alloc::string::String,
    /// metadata for the call
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for Call {
    const NAME: &'static str = "Call";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.Call".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.Call".into()
    }
}
/// LeaveRequest message type
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaveRequest {
    /// A serialized AuthenticatedNote containing the sender's signed, member-only verifiable statement
    #[prost(bytes = "vec", optional, tag = "1")]
    pub authenticated_note: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for LeaveRequest {
    const NAME: &'static str = "LeaveRequest";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.LeaveRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.LeaveRequest".into()
    }
}
/// DeleteMessage message type
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteMessage {
    /// ID of the message to delete
    #[prost(string, tag = "1")]
    pub message_id: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteMessage {
    const NAME: &'static str = "DeleteMessage";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.DeleteMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.DeleteMessage".into()
    }
}
/// EditMessage message type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditMessage {
    /// ID of the message to edit
    #[prost(string, tag = "1")]
    pub message_id: ::prost::alloc::string::String,
    /// The new content for the message
    #[prost(message, optional, tag = "2")]
    pub edited_content: ::core::option::Option<super::EncodedContent>,
}
impl ::prost::Name for EditMessage {
    const NAME: &'static str = "EditMessage";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.EditMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.EditMessage".into()
    }
}
/// Reaction message type
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReactionV2 {
    /// The message ID being reacted to
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
    /// The inbox ID of the user who sent the message being reacted to
    /// Optional for group messages
    #[prost(string, tag = "2")]
    pub reference_inbox_id: ::prost::alloc::string::String,
    /// The action of the reaction (added or removed)
    #[prost(enumeration = "ReactionAction", tag = "3")]
    pub action: i32,
    /// The content of the reaction
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    /// The schema of the reaction content
    #[prost(enumeration = "ReactionSchema", tag = "5")]
    pub schema: i32,
}
impl ::prost::Name for ReactionV2 {
    const NAME: &'static str = "ReactionV2";
    const PACKAGE: &'static str = "xmtp.mls.message_contents.content_types";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.content_types.ReactionV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.content_types.ReactionV2".into()
    }
}
/// Action enum to represent reaction states
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReactionAction {
    Unspecified = 0,
    Added = 1,
    Removed = 2,
}
impl ReactionAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REACTION_ACTION_UNSPECIFIED",
            Self::Added => "REACTION_ACTION_ADDED",
            Self::Removed => "REACTION_ACTION_REMOVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REACTION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "REACTION_ACTION_ADDED" => Some(Self::Added),
            "REACTION_ACTION_REMOVED" => Some(Self::Removed),
            _ => None,
        }
    }
}
/// Schema enum to represent reaction content types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReactionSchema {
    Unspecified = 0,
    Unicode = 1,
    Shortcode = 2,
    Custom = 3,
}
impl ReactionSchema {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REACTION_SCHEMA_UNSPECIFIED",
            Self::Unicode => "REACTION_SCHEMA_UNICODE",
            Self::Shortcode => "REACTION_SCHEMA_SHORTCODE",
            Self::Custom => "REACTION_SCHEMA_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REACTION_SCHEMA_UNSPECIFIED" => Some(Self::Unspecified),
            "REACTION_SCHEMA_UNICODE" => Some(Self::Unicode),
            "REACTION_SCHEMA_SHORTCODE" => Some(Self::Shortcode),
            "REACTION_SCHEMA_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
