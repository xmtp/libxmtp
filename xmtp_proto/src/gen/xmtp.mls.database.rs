// This file is @generated by prost-build.
/// The data required to publish a message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SendMessageData {
    #[prost(oneof = "send_message_data::Version", tags = "1")]
    pub version: ::core::option::Option<send_message_data::Version>,
}
/// Nested message and enum types in `SendMessageData`.
pub mod send_message_data {
    /// V1 of SendMessagePublishData
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V1 {
        #[prost(bytes = "vec", tag = "1")]
        pub payload_bytes: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.SendMessageData.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.SendMessageData.V1".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
impl ::prost::Name for SendMessageData {
    const NAME: &'static str = "SendMessageData";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.SendMessageData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.SendMessageData".into()
    }
}
/// Wrapper around a list af repeated EVM Account Addresses
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountAddresses {
    #[prost(string, repeated, tag = "1")]
    pub account_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for AccountAddresses {
    const NAME: &'static str = "AccountAddresses";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.AccountAddresses".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.AccountAddresses".into()
    }
}
/// Wrapper around a list of repeated Installation IDs
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstallationIds {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub installation_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for InstallationIds {
    const NAME: &'static str = "InstallationIds";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.InstallationIds".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.InstallationIds".into()
    }
}
/// One of an EVM account address or Installation ID
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AddressesOrInstallationIds {
    #[prost(
        oneof = "addresses_or_installation_ids::AddressesOrInstallationIds",
        tags = "1, 2"
    )]
    pub addresses_or_installation_ids: ::core::option::Option<
        addresses_or_installation_ids::AddressesOrInstallationIds,
    >,
}
/// Nested message and enum types in `AddressesOrInstallationIds`.
pub mod addresses_or_installation_ids {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum AddressesOrInstallationIds {
        #[prost(message, tag = "1")]
        AccountAddresses(super::AccountAddresses),
        #[prost(message, tag = "2")]
        InstallationIds(super::InstallationIds),
    }
}
impl ::prost::Name for AddressesOrInstallationIds {
    const NAME: &'static str = "AddressesOrInstallationIds";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.AddressesOrInstallationIds".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.AddressesOrInstallationIds".into()
    }
}
/// The data required to add members to a group
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AddMembersData {
    #[prost(oneof = "add_members_data::Version", tags = "1")]
    pub version: ::core::option::Option<add_members_data::Version>,
}
/// Nested message and enum types in `AddMembersData`.
pub mod add_members_data {
    /// V1 of AddMembersPublishData
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V1 {
        #[prost(message, optional, tag = "1")]
        pub addresses_or_installation_ids: ::core::option::Option<
            super::AddressesOrInstallationIds,
        >,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.AddMembersData.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.AddMembersData.V1".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
impl ::prost::Name for AddMembersData {
    const NAME: &'static str = "AddMembersData";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.AddMembersData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.AddMembersData".into()
    }
}
/// The data required to remove members from a group
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveMembersData {
    #[prost(oneof = "remove_members_data::Version", tags = "1")]
    pub version: ::core::option::Option<remove_members_data::Version>,
}
/// Nested message and enum types in `RemoveMembersData`.
pub mod remove_members_data {
    /// V1 of RemoveMembersPublishData
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V1 {
        #[prost(message, optional, tag = "1")]
        pub addresses_or_installation_ids: ::core::option::Option<
            super::AddressesOrInstallationIds,
        >,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.RemoveMembersData.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.RemoveMembersData.V1".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
impl ::prost::Name for RemoveMembersData {
    const NAME: &'static str = "RemoveMembersData";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.RemoveMembersData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.RemoveMembersData".into()
    }
}
/// The data required to make a commit that updates group membership
/// Handles both Add and Remove actions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGroupMembershipData {
    #[prost(oneof = "update_group_membership_data::Version", tags = "1")]
    pub version: ::core::option::Option<update_group_membership_data::Version>,
}
/// Nested message and enum types in `UpdateGroupMembershipData`.
pub mod update_group_membership_data {
    /// V1 of UpdateGroupMembershipPublishData
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct V1 {
        /// Contains delta of membership updates that need to be applied
        #[prost(map = "string, uint64", tag = "1")]
        pub membership_updates: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            u64,
        >,
        /// Contains the list of members that will be removed
        #[prost(string, repeated, tag = "2")]
        pub removed_members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// List of installations that failed to be added due to errors encountered during the evaluation process.
        #[prost(bytes = "vec", repeated, tag = "3")]
        pub failed_installations: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.UpdateGroupMembershipData.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.UpdateGroupMembershipData.V1".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
impl ::prost::Name for UpdateGroupMembershipData {
    const NAME: &'static str = "UpdateGroupMembershipData";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.UpdateGroupMembershipData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.UpdateGroupMembershipData".into()
    }
}
/// The data required to update group metadata
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateMetadataData {
    #[prost(oneof = "update_metadata_data::Version", tags = "1")]
    pub version: ::core::option::Option<update_metadata_data::Version>,
}
/// Nested message and enum types in `UpdateMetadataData`.
pub mod update_metadata_data {
    /// V1 of UpdateMetadataPublishData
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V1 {
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub field_value: ::prost::alloc::string::String,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.UpdateMetadataData.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.UpdateMetadataData.V1".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
impl ::prost::Name for UpdateMetadataData {
    const NAME: &'static str = "UpdateMetadataData";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.UpdateMetadataData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.UpdateMetadataData".into()
    }
}
/// The data required to update group admin/super admin lists
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateAdminListsData {
    #[prost(oneof = "update_admin_lists_data::Version", tags = "1")]
    pub version: ::core::option::Option<update_admin_lists_data::Version>,
}
/// Nested message and enum types in `UpdateAdminListsData`.
pub mod update_admin_lists_data {
    /// V1 of UpdateAdminListsPublishData
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V1 {
        #[prost(enumeration = "super::AdminListUpdateType", tag = "1")]
        pub admin_list_update_type: i32,
        #[prost(string, tag = "2")]
        pub inbox_id: ::prost::alloc::string::String,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.UpdateAdminListsData.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.UpdateAdminListsData.V1".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
impl ::prost::Name for UpdateAdminListsData {
    const NAME: &'static str = "UpdateAdminListsData";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.UpdateAdminListsData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.UpdateAdminListsData".into()
    }
}
/// The data required to update permissions
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdatePermissionData {
    #[prost(oneof = "update_permission_data::Version", tags = "1")]
    pub version: ::core::option::Option<update_permission_data::Version>,
}
/// Nested message and enum types in `UpdatePermissionData`.
pub mod update_permission_data {
    /// V1 of UpdatePermissionData
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V1 {
        #[prost(enumeration = "super::PermissionUpdateType", tag = "1")]
        pub permission_update_type: i32,
        #[prost(enumeration = "super::PermissionPolicyOption", tag = "2")]
        pub permission_policy_option: i32,
        /// Metadata permissions update specify which field permission they are updating
        #[prost(string, optional, tag = "3")]
        pub metadata_field_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.UpdatePermissionData.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.UpdatePermissionData.V1".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(V1),
    }
}
impl ::prost::Name for UpdatePermissionData {
    const NAME: &'static str = "UpdatePermissionData";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.UpdatePermissionData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.UpdatePermissionData".into()
    }
}
/// Generic data-type for all post-commit actions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostCommitAction {
    #[prost(oneof = "post_commit_action::Kind", tags = "1")]
    pub kind: ::core::option::Option<post_commit_action::Kind>,
}
/// Nested message and enum types in `PostCommitAction`.
pub mod post_commit_action {
    /// An installation
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Installation {
        #[prost(bytes = "vec", tag = "1")]
        pub installation_key: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "2")]
        pub hpke_public_key: ::prost::alloc::vec::Vec<u8>,
        #[prost(
            enumeration = "super::super::message_contents::WelcomeWrapperAlgorithm",
            tag = "3"
        )]
        pub welcome_wrapper_algorithm: i32,
    }
    impl ::prost::Name for Installation {
        const NAME: &'static str = "Installation";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.PostCommitAction.Installation".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.PostCommitAction.Installation".into()
        }
    }
    /// SendWelcome message
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendWelcomes {
        #[prost(message, repeated, tag = "1")]
        pub installations: ::prost::alloc::vec::Vec<Installation>,
        #[prost(bytes = "vec", tag = "2")]
        pub welcome_message: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for SendWelcomes {
        const NAME: &'static str = "SendWelcomes";
        const PACKAGE: &'static str = "xmtp.mls.database";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.database.PostCommitAction.SendWelcomes".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.database.PostCommitAction.SendWelcomes".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        SendWelcomes(SendWelcomes),
    }
}
impl ::prost::Name for PostCommitAction {
    const NAME: &'static str = "PostCommitAction";
    const PACKAGE: &'static str = "xmtp.mls.database";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.database.PostCommitAction".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.database.PostCommitAction".into()
    }
}
/// Type of update to admin lists
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdminListUpdateType {
    Unspecified = 0,
    AddAdmin = 1,
    RemoveAdmin = 2,
    AddSuperAdmin = 3,
    RemoveSuperAdmin = 4,
}
impl AdminListUpdateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED",
            Self::AddAdmin => "ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN",
            Self::RemoveAdmin => "ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN",
            Self::AddSuperAdmin => "ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN",
            Self::RemoveSuperAdmin => "ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN" => Some(Self::AddAdmin),
            "ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN" => Some(Self::RemoveAdmin),
            "ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN" => Some(Self::AddSuperAdmin),
            "ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN" => Some(Self::RemoveSuperAdmin),
            _ => None,
        }
    }
}
/// Type of Permission to Update
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PermissionUpdateType {
    Unspecified = 0,
    AddMember = 1,
    RemoveMember = 2,
    AddAdmin = 3,
    RemoveAdmin = 4,
    UpdateMetadata = 5,
}
impl PermissionUpdateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PERMISSION_UPDATE_TYPE_UNSPECIFIED",
            Self::AddMember => "PERMISSION_UPDATE_TYPE_ADD_MEMBER",
            Self::RemoveMember => "PERMISSION_UPDATE_TYPE_REMOVE_MEMBER",
            Self::AddAdmin => "PERMISSION_UPDATE_TYPE_ADD_ADMIN",
            Self::RemoveAdmin => "PERMISSION_UPDATE_TYPE_REMOVE_ADMIN",
            Self::UpdateMetadata => "PERMISSION_UPDATE_TYPE_UPDATE_METADATA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERMISSION_UPDATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PERMISSION_UPDATE_TYPE_ADD_MEMBER" => Some(Self::AddMember),
            "PERMISSION_UPDATE_TYPE_REMOVE_MEMBER" => Some(Self::RemoveMember),
            "PERMISSION_UPDATE_TYPE_ADD_ADMIN" => Some(Self::AddAdmin),
            "PERMISSION_UPDATE_TYPE_REMOVE_ADMIN" => Some(Self::RemoveAdmin),
            "PERMISSION_UPDATE_TYPE_UPDATE_METADATA" => Some(Self::UpdateMetadata),
            _ => None,
        }
    }
}
/// Permission Policy
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PermissionPolicyOption {
    Unspecified = 0,
    Allow = 1,
    Deny = 2,
    AdminOnly = 3,
    SuperAdminOnly = 4,
}
impl PermissionPolicyOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PERMISSION_POLICY_OPTION_UNSPECIFIED",
            Self::Allow => "PERMISSION_POLICY_OPTION_ALLOW",
            Self::Deny => "PERMISSION_POLICY_OPTION_DENY",
            Self::AdminOnly => "PERMISSION_POLICY_OPTION_ADMIN_ONLY",
            Self::SuperAdminOnly => "PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERMISSION_POLICY_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
            "PERMISSION_POLICY_OPTION_ALLOW" => Some(Self::Allow),
            "PERMISSION_POLICY_OPTION_DENY" => Some(Self::Deny),
            "PERMISSION_POLICY_OPTION_ADMIN_ONLY" => Some(Self::AdminOnly),
            "PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY" => Some(Self::SuperAdminOnly),
            _ => None,
        }
    }
}
