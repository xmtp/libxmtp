// This file is @generated by prost-build.
/// Wrapper class for errors from the Keystore API
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeystoreError {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(enumeration = "ErrorCode", tag = "2")]
    pub code: i32,
}
impl ::prost::Name for KeystoreError {
    const NAME: &'static str = "KeystoreError";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.KeystoreError".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.KeystoreError".into()
    }
}
/// Decrypt a batch of messages using X3DH key agreement
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptV1Request {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<decrypt_v1_request::Request>,
}
/// Nested message and enum types in `DecryptV1Request`.
pub mod decrypt_v1_request {
    /// A single decryption request
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        #[prost(message, optional, tag = "1")]
        pub payload: ::core::option::Option<
            super::super::super::message_contents::Ciphertext,
        >,
        #[prost(message, optional, tag = "2")]
        pub peer_keys: ::core::option::Option<
            super::super::super::message_contents::PublicKeyBundle,
        >,
        #[prost(bytes = "vec", tag = "3")]
        pub header_bytes: ::prost::alloc::vec::Vec<u8>,
        #[prost(bool, tag = "4")]
        pub is_sender: bool,
    }
    impl ::prost::Name for Request {
        const NAME: &'static str = "Request";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.DecryptV1Request.Request".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.DecryptV1Request.Request".into()
        }
    }
}
impl ::prost::Name for DecryptV1Request {
    const NAME: &'static str = "DecryptV1Request";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.DecryptV1Request".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.DecryptV1Request".into()
    }
}
/// Response type for both V1 and V2 decryption requests
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<decrypt_response::Response>,
}
/// Nested message and enum types in `DecryptResponse`.
pub mod decrypt_response {
    /// A single decryption response
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Response {
        #[prost(oneof = "response::Response", tags = "1, 2")]
        pub response: ::core::option::Option<response::Response>,
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        /// Wrapper object for success response
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Success {
            #[prost(bytes = "vec", tag = "1")]
            pub decrypted: ::prost::alloc::vec::Vec<u8>,
        }
        impl ::prost::Name for Success {
            const NAME: &'static str = "Success";
            const PACKAGE: &'static str = "xmtp.keystore_api.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "xmtp.keystore_api.v1.DecryptResponse.Response.Success".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "/xmtp.keystore_api.v1.DecryptResponse.Response.Success".into()
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Result(Success),
            #[prost(message, tag = "2")]
            Error(super::super::KeystoreError),
        }
    }
    impl ::prost::Name for Response {
        const NAME: &'static str = "Response";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.DecryptResponse.Response".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.DecryptResponse.Response".into()
        }
    }
}
impl ::prost::Name for DecryptResponse {
    const NAME: &'static str = "DecryptResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.DecryptResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.DecryptResponse".into()
    }
}
/// Decrypt a batch of messages using the appropriate topic keys
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptV2Request {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<decrypt_v2_request::Request>,
}
/// Nested message and enum types in `DecryptV2Request`.
pub mod decrypt_v2_request {
    /// A single decryption request
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        #[prost(message, optional, tag = "1")]
        pub payload: ::core::option::Option<
            super::super::super::message_contents::Ciphertext,
        >,
        #[prost(bytes = "vec", tag = "2")]
        pub header_bytes: ::prost::alloc::vec::Vec<u8>,
        #[prost(string, tag = "3")]
        pub content_topic: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Request {
        const NAME: &'static str = "Request";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.DecryptV2Request.Request".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.DecryptV2Request.Request".into()
        }
    }
}
impl ::prost::Name for DecryptV2Request {
    const NAME: &'static str = "DecryptV2Request";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.DecryptV2Request".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.DecryptV2Request".into()
    }
}
/// Encrypt a batch of messages using X3DH key agreement
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptV1Request {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<encrypt_v1_request::Request>,
}
/// Nested message and enum types in `EncryptV1Request`.
pub mod encrypt_v1_request {
    /// A single encryption request
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        #[prost(message, optional, tag = "1")]
        pub recipient: ::core::option::Option<
            super::super::super::message_contents::PublicKeyBundle,
        >,
        #[prost(bytes = "vec", tag = "2")]
        pub payload: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "3")]
        pub header_bytes: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Request {
        const NAME: &'static str = "Request";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.EncryptV1Request.Request".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.EncryptV1Request.Request".into()
        }
    }
}
impl ::prost::Name for EncryptV1Request {
    const NAME: &'static str = "EncryptV1Request";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.EncryptV1Request".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.EncryptV1Request".into()
    }
}
/// Response type for both V1 and V2 encryption requests
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<encrypt_response::Response>,
}
/// Nested message and enum types in `EncryptResponse`.
pub mod encrypt_response {
    /// A single encryption response
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Response {
        #[prost(oneof = "response::Response", tags = "1, 2")]
        pub response: ::core::option::Option<response::Response>,
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        /// Wrapper object for success response
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Success {
            #[prost(message, optional, tag = "1")]
            pub encrypted: ::core::option::Option<
                super::super::super::super::message_contents::Ciphertext,
            >,
            #[prost(bytes = "vec", tag = "2")]
            pub sender_hmac: ::prost::alloc::vec::Vec<u8>,
        }
        impl ::prost::Name for Success {
            const NAME: &'static str = "Success";
            const PACKAGE: &'static str = "xmtp.keystore_api.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "xmtp.keystore_api.v1.EncryptResponse.Response.Success".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "/xmtp.keystore_api.v1.EncryptResponse.Response.Success".into()
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Result(Success),
            #[prost(message, tag = "2")]
            Error(super::super::KeystoreError),
        }
    }
    impl ::prost::Name for Response {
        const NAME: &'static str = "Response";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.EncryptResponse.Response".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.EncryptResponse.Response".into()
        }
    }
}
impl ::prost::Name for EncryptResponse {
    const NAME: &'static str = "EncryptResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.EncryptResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.EncryptResponse".into()
    }
}
/// Encrypt a batch of messages using the appropriate topic keys
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptV2Request {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<encrypt_v2_request::Request>,
}
/// Nested message and enum types in `EncryptV2Request`.
pub mod encrypt_v2_request {
    /// A single encryption request
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        #[prost(bytes = "vec", tag = "1")]
        pub payload: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "2")]
        pub header_bytes: ::prost::alloc::vec::Vec<u8>,
        #[prost(string, tag = "3")]
        pub content_topic: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Request {
        const NAME: &'static str = "Request";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.EncryptV2Request.Request".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.EncryptV2Request.Request".into()
        }
    }
}
impl ::prost::Name for EncryptV2Request {
    const NAME: &'static str = "EncryptV2Request";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.EncryptV2Request".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.EncryptV2Request".into()
    }
}
/// Encrypt a message for yourself
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelfEncryptRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<self_encrypt_request::Request>,
}
/// Nested message and enum types in `SelfEncryptRequest`.
pub mod self_encrypt_request {
    /// Request type
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        #[prost(bytes = "vec", tag = "1")]
        pub payload: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Request {
        const NAME: &'static str = "Request";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.SelfEncryptRequest.Request".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.SelfEncryptRequest.Request".into()
        }
    }
}
impl ::prost::Name for SelfEncryptRequest {
    const NAME: &'static str = "SelfEncryptRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SelfEncryptRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SelfEncryptRequest".into()
    }
}
/// Response type for SelfEncryptRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelfEncryptResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<self_encrypt_response::Response>,
}
/// Nested message and enum types in `SelfEncryptResponse`.
pub mod self_encrypt_response {
    /// Response type
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Response {
        #[prost(oneof = "response::Response", tags = "1, 2")]
        pub response: ::core::option::Option<response::Response>,
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        /// Success response
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Success {
            #[prost(bytes = "vec", tag = "1")]
            pub encrypted: ::prost::alloc::vec::Vec<u8>,
        }
        impl ::prost::Name for Success {
            const NAME: &'static str = "Success";
            const PACKAGE: &'static str = "xmtp.keystore_api.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "/xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success".into()
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Result(Success),
            #[prost(message, tag = "2")]
            Error(super::super::KeystoreError),
        }
    }
    impl ::prost::Name for Response {
        const NAME: &'static str = "Response";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.SelfEncryptResponse.Response".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.SelfEncryptResponse.Response".into()
        }
    }
}
impl ::prost::Name for SelfEncryptResponse {
    const NAME: &'static str = "SelfEncryptResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SelfEncryptResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SelfEncryptResponse".into()
    }
}
/// SelfDecryptRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelfDecryptRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<self_decrypt_request::Request>,
}
/// Nested message and enum types in `SelfDecryptRequest`.
pub mod self_decrypt_request {
    /// Request type
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        #[prost(bytes = "vec", tag = "1")]
        pub payload: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Request {
        const NAME: &'static str = "Request";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.SelfDecryptRequest.Request".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.SelfDecryptRequest.Request".into()
        }
    }
}
impl ::prost::Name for SelfDecryptRequest {
    const NAME: &'static str = "SelfDecryptRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SelfDecryptRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SelfDecryptRequest".into()
    }
}
/// Get the private preferences topic identifier
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPrivatePreferencesTopicIdentifierResponse {
    #[prost(string, tag = "1")]
    pub identifier: ::prost::alloc::string::String,
}
impl ::prost::Name for GetPrivatePreferencesTopicIdentifierResponse {
    const NAME: &'static str = "GetPrivatePreferencesTopicIdentifierResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetPrivatePreferencesTopicIdentifierResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetPrivatePreferencesTopicIdentifierResponse".into()
    }
}
/// Request to create an invite payload, and store the topic keys in the Keystore
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInviteRequest {
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<
        super::super::message_contents::invitation_v1::Context,
    >,
    #[prost(message, optional, tag = "2")]
    pub recipient: ::core::option::Option<
        super::super::message_contents::SignedPublicKeyBundle,
    >,
    #[prost(uint64, tag = "3")]
    pub created_ns: u64,
    #[prost(message, optional, tag = "4")]
    pub consent_proof: ::core::option::Option<
        super::super::message_contents::ConsentProofPayload,
    >,
}
impl ::prost::Name for CreateInviteRequest {
    const NAME: &'static str = "CreateInviteRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.CreateInviteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.CreateInviteRequest".into()
    }
}
/// Response to a CreateInviteRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInviteResponse {
    #[prost(message, optional, tag = "1")]
    pub conversation: ::core::option::Option<
        super::super::message_contents::ConversationReference,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for CreateInviteResponse {
    const NAME: &'static str = "CreateInviteResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.CreateInviteResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.CreateInviteResponse".into()
    }
}
/// Request to save a batch of invite messages to the Keystore
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveInvitesRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<save_invites_request::Request>,
}
/// Nested message and enum types in `SaveInvitesRequest`.
pub mod save_invites_request {
    /// Mirrors xmtp.envelope schema
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub content_topic: ::prost::alloc::string::String,
        #[prost(uint64, tag = "2")]
        pub timestamp_ns: u64,
        #[prost(bytes = "vec", tag = "3")]
        pub payload: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Request {
        const NAME: &'static str = "Request";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.SaveInvitesRequest.Request".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.SaveInvitesRequest.Request".into()
        }
    }
}
impl ::prost::Name for SaveInvitesRequest {
    const NAME: &'static str = "SaveInvitesRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SaveInvitesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SaveInvitesRequest".into()
    }
}
/// Response to a SaveInvitesRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveInvitesResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<save_invites_response::Response>,
}
/// Nested message and enum types in `SaveInvitesResponse`.
pub mod save_invites_response {
    /// A single response
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(oneof = "response::Response", tags = "1, 2")]
        pub response: ::core::option::Option<response::Response>,
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        /// Wrapper object for success response
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Success {
            #[prost(message, optional, tag = "1")]
            pub conversation: ::core::option::Option<
                super::super::super::super::message_contents::ConversationReference,
            >,
        }
        impl ::prost::Name for Success {
            const NAME: &'static str = "Success";
            const PACKAGE: &'static str = "xmtp.keystore_api.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "/xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success".into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Result(Success),
            #[prost(message, tag = "2")]
            Error(super::super::KeystoreError),
        }
    }
    impl ::prost::Name for Response {
        const NAME: &'static str = "Response";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.SaveInvitesResponse.Response".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.SaveInvitesResponse.Response".into()
        }
    }
}
impl ::prost::Name for SaveInvitesResponse {
    const NAME: &'static str = "SaveInvitesResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SaveInvitesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SaveInvitesResponse".into()
    }
}
/// CreateAuthTokenRequest is used to create an auth token for the XMTP API
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateAuthTokenRequest {
    #[prost(uint64, optional, tag = "1")]
    pub timestamp_ns: ::core::option::Option<u64>,
}
impl ::prost::Name for CreateAuthTokenRequest {
    const NAME: &'static str = "CreateAuthTokenRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.CreateAuthTokenRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.CreateAuthTokenRequest".into()
    }
}
/// SaveV1ConversationsRequest is used to save a batch of conversations to the
/// built in persistence
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveV1ConversationsRequest {
    #[prost(message, repeated, tag = "1")]
    pub conversations: ::prost::alloc::vec::Vec<
        super::super::message_contents::ConversationReference,
    >,
}
impl ::prost::Name for SaveV1ConversationsRequest {
    const NAME: &'static str = "SaveV1ConversationsRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SaveV1ConversationsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SaveV1ConversationsRequest".into()
    }
}
/// Placeholder response type for SaveV1Conversations
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SaveV1ConversationsResponse {}
impl ::prost::Name for SaveV1ConversationsResponse {
    const NAME: &'static str = "SaveV1ConversationsResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SaveV1ConversationsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SaveV1ConversationsResponse".into()
    }
}
/// Response for GetV2Conversations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub conversations: ::prost::alloc::vec::Vec<
        super::super::message_contents::ConversationReference,
    >,
}
impl ::prost::Name for GetConversationsResponse {
    const NAME: &'static str = "GetConversationsResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetConversationsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetConversationsResponse".into()
    }
}
/// Used to check if the Keystore implementation has been setup for the given
/// wallet address Only used for MM Snap Keystore currently
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetKeystoreStatusRequest {
    #[prost(string, tag = "1")]
    pub wallet_address: ::prost::alloc::string::String,
}
impl ::prost::Name for GetKeystoreStatusRequest {
    const NAME: &'static str = "GetKeystoreStatusRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetKeystoreStatusRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetKeystoreStatusRequest".into()
    }
}
/// Response to GetKeystoreStatusRequest
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetKeystoreStatusResponse {
    #[prost(enumeration = "get_keystore_status_response::KeystoreStatus", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `GetKeystoreStatusResponse`.
pub mod get_keystore_status_response {
    /// Status of the Keystore for the specified wallet address
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeystoreStatus {
        Unspecified = 0,
        Uninitialized = 1,
        Initialized = 2,
    }
    impl KeystoreStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KEYSTORE_STATUS_UNSPECIFIED",
                Self::Uninitialized => "KEYSTORE_STATUS_UNINITIALIZED",
                Self::Initialized => "KEYSTORE_STATUS_INITIALIZED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KEYSTORE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "KEYSTORE_STATUS_UNINITIALIZED" => Some(Self::Uninitialized),
                "KEYSTORE_STATUS_INITIALIZED" => Some(Self::Initialized),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for GetKeystoreStatusResponse {
    const NAME: &'static str = "GetKeystoreStatusResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetKeystoreStatusResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetKeystoreStatusResponse".into()
    }
}
/// Used to initialize the Keystore with a private key bundle retrieved from the
/// client
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitKeystoreRequest {
    #[prost(oneof = "init_keystore_request::Bundle", tags = "1")]
    pub bundle: ::core::option::Option<init_keystore_request::Bundle>,
}
/// Nested message and enum types in `InitKeystoreRequest`.
pub mod init_keystore_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Bundle {
        #[prost(message, tag = "1")]
        V1(super::super::super::message_contents::PrivateKeyBundleV1),
    }
}
impl ::prost::Name for InitKeystoreRequest {
    const NAME: &'static str = "InitKeystoreRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.InitKeystoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.InitKeystoreRequest".into()
    }
}
/// Response to the request to initialize the Keystore
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InitKeystoreResponse {
    #[prost(message, optional, tag = "1")]
    pub error: ::core::option::Option<KeystoreError>,
}
impl ::prost::Name for InitKeystoreResponse {
    const NAME: &'static str = "InitKeystoreResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.InitKeystoreResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.InitKeystoreResponse".into()
    }
}
/// SignDigestRequest is used to sign a digest with either the identity key
/// or a prekey
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignDigestRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub digest: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "sign_digest_request::Signer", tags = "2, 3")]
    pub signer: ::core::option::Option<sign_digest_request::Signer>,
}
/// Nested message and enum types in `SignDigestRequest`.
pub mod sign_digest_request {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Signer {
        #[prost(bool, tag = "2")]
        IdentityKey(bool),
        #[prost(uint32, tag = "3")]
        PrekeyIndex(u32),
    }
}
impl ::prost::Name for SignDigestRequest {
    const NAME: &'static str = "SignDigestRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SignDigestRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SignDigestRequest".into()
    }
}
/// GetRefreshJobRequest is used to get the last run time of a refresh job
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRefreshJobRequest {
    #[prost(enumeration = "JobType", tag = "1")]
    pub job_type: i32,
}
impl ::prost::Name for GetRefreshJobRequest {
    const NAME: &'static str = "GetRefreshJobRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetRefreshJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetRefreshJobRequest".into()
    }
}
/// GetRefreshJobResponse is used to return the last run time of a refresh job
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRefreshJobResponse {
    #[prost(int64, tag = "1")]
    pub last_run_ns: i64,
}
impl ::prost::Name for GetRefreshJobResponse {
    const NAME: &'static str = "GetRefreshJobResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetRefreshJobResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetRefreshJobResponse".into()
    }
}
/// SetRefreshJobRequest is used to set the last run time of a refresh job
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetRefeshJobRequest {
    #[prost(enumeration = "JobType", tag = "1")]
    pub job_type: i32,
    #[prost(int64, tag = "2")]
    pub last_run_ns: i64,
}
impl ::prost::Name for SetRefeshJobRequest {
    const NAME: &'static str = "SetRefeshJobRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SetRefeshJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SetRefeshJobRequest".into()
    }
}
/// SetRefreshJobResponse is an empty response type
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetRefreshJobResponse {}
impl ::prost::Name for SetRefreshJobResponse {
    const NAME: &'static str = "SetRefreshJobResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.SetRefreshJobResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.SetRefreshJobResponse".into()
    }
}
/// A mapping of topics to their decrypted invitations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicMap {
    #[prost(map = "string, message", tag = "1")]
    pub topics: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        topic_map::TopicData,
    >,
}
/// Nested message and enum types in `TopicMap`.
pub mod topic_map {
    /// TopicData wraps the invitation and the timestamp it was created
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TopicData {
        #[prost(uint64, tag = "1")]
        pub created_ns: u64,
        #[prost(string, tag = "2")]
        pub peer_address: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub invitation: ::core::option::Option<
            super::super::super::message_contents::InvitationV1,
        >,
    }
    impl ::prost::Name for TopicData {
        const NAME: &'static str = "TopicData";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.TopicMap.TopicData".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.TopicMap.TopicData".into()
        }
    }
}
impl ::prost::Name for TopicMap {
    const NAME: &'static str = "TopicMap";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.TopicMap".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.TopicMap".into()
    }
}
/// Used to get a mapping of conversation topics to their HMAC keys
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConversationHmacKeysRequest {
    #[prost(string, repeated, tag = "1")]
    pub topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for GetConversationHmacKeysRequest {
    const NAME: &'static str = "GetConversationHmacKeysRequest";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetConversationHmacKeysRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetConversationHmacKeysRequest".into()
    }
}
/// A mapping of topics to their HMAC keys
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationHmacKeysResponse {
    #[prost(map = "string, message", tag = "1")]
    pub hmac_keys: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        get_conversation_hmac_keys_response::HmacKeys,
    >,
}
/// Nested message and enum types in `GetConversationHmacKeysResponse`.
pub mod get_conversation_hmac_keys_response {
    /// HmacKeyData wraps the HMAC key and the number of 30 day periods since epoch
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct HmacKeyData {
        #[prost(int32, tag = "1")]
        pub thirty_day_periods_since_epoch: i32,
        #[prost(bytes = "vec", tag = "2")]
        pub hmac_key: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for HmacKeyData {
        const NAME: &'static str = "HmacKeyData";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData".into()
        }
    }
    /// HmacKeys represents multiple HmacKeyData objects
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HmacKeys {
        #[prost(message, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<HmacKeyData>,
    }
    impl ::prost::Name for HmacKeys {
        const NAME: &'static str = "HmacKeys";
        const PACKAGE: &'static str = "xmtp.keystore_api.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys".into()
        }
    }
}
impl ::prost::Name for GetConversationHmacKeysResponse {
    const NAME: &'static str = "GetConversationHmacKeysResponse";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.GetConversationHmacKeysResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.GetConversationHmacKeysResponse".into()
    }
}
/// A mapping of message hashes to their private preferences action
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePreferencesActionMap {
    #[prost(map = "string, message", tag = "1")]
    pub actions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::message_contents::PrivatePreferencesAction,
    >,
}
impl ::prost::Name for PrivatePreferencesActionMap {
    const NAME: &'static str = "PrivatePreferencesActionMap";
    const PACKAGE: &'static str = "xmtp.keystore_api.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.keystore_api.v1.PrivatePreferencesActionMap".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.keystore_api.v1.PrivatePreferencesActionMap".into()
    }
}
/// Application-specific error codes for the Keystore API.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    Unspecified = 0,
    InvalidInput = 1,
    NoMatchingPrekey = 2,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ERROR_CODE_UNSPECIFIED",
            Self::InvalidInput => "ERROR_CODE_INVALID_INPUT",
            Self::NoMatchingPrekey => "ERROR_CODE_NO_MATCHING_PREKEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_CODE_INVALID_INPUT" => Some(Self::InvalidInput),
            "ERROR_CODE_NO_MATCHING_PREKEY" => Some(Self::NoMatchingPrekey),
            _ => None,
        }
    }
}
/// JobType is used to specify the type of job the caller would like info on
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobType {
    Unspecified = 0,
    RefreshV1 = 1,
    RefreshV2 = 2,
    RefreshPppp = 3,
}
impl JobType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "JOB_TYPE_UNSPECIFIED",
            Self::RefreshV1 => "JOB_TYPE_REFRESH_V1",
            Self::RefreshV2 => "JOB_TYPE_REFRESH_V2",
            Self::RefreshPppp => "JOB_TYPE_REFRESH_PPPP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOB_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "JOB_TYPE_REFRESH_V1" => Some(Self::RefreshV1),
            "JOB_TYPE_REFRESH_V2" => Some(Self::RefreshV2),
            "JOB_TYPE_REFRESH_PPPP" => Some(Self::RefreshPppp),
            _ => None,
        }
    }
}
