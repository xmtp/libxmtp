// This file is @generated by prost-build.
/// Signature represents a generalized public key signature,
/// defined as a union to support cryptographic algorithm agility.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signature {
    #[prost(oneof = "signature::Union", tags = "1, 2")]
    pub union: ::core::option::Option<signature::Union>,
}
/// Nested message and enum types in `Signature`.
pub mod signature {
    /// ECDSA signature bytes and the recovery bit
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EcdsaCompact {
        /// compact representation \[ R || S \], 64 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
        /// recovery bit
        #[prost(uint32, tag = "2")]
        pub recovery: u32,
    }
    /// ECDSA signature bytes and the recovery bit
    /// produced by xmtp-js::PublicKey.signWithWallet function, i.e.
    /// EIP-191 signature of a "Create Identity" message with the key embedded.
    /// Used to sign identity keys.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WalletEcdsaCompact {
        /// compact representation \[ R || S \], 64 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
        /// recovery bit
        #[prost(uint32, tag = "2")]
        pub recovery: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "1")]
        EcdsaCompact(EcdsaCompact),
        #[prost(message, tag = "2")]
        WalletEcdsaCompact(WalletEcdsaCompact),
    }
}
/// UnsignedPublicKey represents a generalized public key,
/// defined as a union to support cryptographic algorithm agility.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsignedPublicKey {
    #[prost(uint64, tag = "1")]
    pub created_ns: u64,
    #[prost(oneof = "unsigned_public_key::Union", tags = "3")]
    pub union: ::core::option::Option<unsigned_public_key::Union>,
}
/// Nested message and enum types in `UnsignedPublicKey`.
pub mod unsigned_public_key {
    /// EC: SECP256k1
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Secp256k1Uncompressed {
        /// uncompressed point with prefix (0x04) \[ P || X || Y \], 65 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "3")]
        Secp256k1Uncompressed(Secp256k1Uncompressed),
    }
}
/// SignedPublicKey
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedPublicKey {
    /// embeds an UnsignedPublicKey
    #[prost(bytes = "vec", tag = "1")]
    pub key_bytes: ::prost::alloc::vec::Vec<u8>,
    /// signs key_bytes
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
}
/// PublicKeyBundle packages the cryptographic keys associated with a wallet.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedPublicKeyBundle {
    /// Identity key MUST be signed by the wallet.
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<SignedPublicKey>,
    /// Pre-key MUST be signed by the identity key.
    #[prost(message, optional, tag = "2")]
    pub pre_key: ::core::option::Option<SignedPublicKey>,
}
/// PublicKey represents a generalized public key,
/// defined as a union to support cryptographic algorithm agility.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKey {
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
    #[prost(oneof = "public_key::Union", tags = "3")]
    pub union: ::core::option::Option<public_key::Union>,
}
/// Nested message and enum types in `PublicKey`.
pub mod public_key {
    /// The key bytes
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Secp256k1Uncompressed {
        /// uncompressed point with prefix (0x04) \[ P || X || Y \], 65 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "3")]
        Secp256k1Uncompressed(Secp256k1Uncompressed),
    }
}
/// PublicKeyBundle packages the cryptographic keys associated with a wallet,
/// both senders and recipients are identified by their key bundles.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyBundle {
    /// Identity key MUST be signed by the wallet.
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<PublicKey>,
    /// Pre-key MUST be signed by the identity key.
    #[prost(message, optional, tag = "2")]
    pub pre_key: ::core::option::Option<PublicKey>,
}
/// Ciphertext represents encrypted payload.
/// It is definited as a union to support cryptographic algorithm agility.
/// The payload is accompanied by the cryptographic parameters
/// required by the chosen encryption scheme.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ciphertext {
    #[prost(oneof = "ciphertext::Union", tags = "1")]
    pub union: ::core::option::Option<ciphertext::Union>,
}
/// Nested message and enum types in `Ciphertext`.
pub mod ciphertext {
    /// Encryption: AES256-GCM
    /// Key derivation function: HKDF-SHA256
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Aes256gcmHkdfsha256 {
        /// 32 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub hkdf_salt: ::prost::alloc::vec::Vec<u8>,
        /// 12 bytes
        #[prost(bytes = "vec", tag = "2")]
        pub gcm_nonce: ::prost::alloc::vec::Vec<u8>,
        /// encrypted payload
        #[prost(bytes = "vec", tag = "3")]
        pub payload: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "1")]
        Aes256GcmHkdfSha256(Aes256gcmHkdfsha256),
    }
}
/// SignedEciesCiphertext represents an ECIES encrypted payload and a signature
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedEciesCiphertext {
    /// serialized Ecies message
    #[prost(bytes = "vec", tag = "1")]
    pub ecies_bytes: ::prost::alloc::vec::Vec<u8>,
    /// signature of sha256(ecies_bytes) signed with the IdentityKey
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
}
/// Nested message and enum types in `SignedEciesCiphertext`.
pub mod signed_ecies_ciphertext {
    /// Ecies is ciphertext encrypted using ECIES with a MAC
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ecies {
        /// 65 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub ephemeral_public_key: ::prost::alloc::vec::Vec<u8>,
        /// 16 bytes
        #[prost(bytes = "vec", tag = "2")]
        pub iv: ::prost::alloc::vec::Vec<u8>,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub mac: ::prost::alloc::vec::Vec<u8>,
        /// encrypted payload with block size of 16
        #[prost(bytes = "vec", tag = "4")]
        pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    }
}
/// Unsealed invitation V1
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvitationV1 {
    /// topic name chosen for this conversation.
    /// It MUST be randomly generated bytes (length >= 32),
    /// then base64 encoded without padding
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// A context object defining metadata
    #[prost(message, optional, tag = "2")]
    pub context: ::core::option::Option<invitation_v1::Context>,
    /// The user's consent proof
    #[prost(message, optional, tag = "4")]
    pub consent_proof: ::core::option::Option<ConsentProofPayload>,
    /// message encryption scheme and keys for this conversation.
    #[prost(oneof = "invitation_v1::Encryption", tags = "3")]
    pub encryption: ::core::option::Option<invitation_v1::Encryption>,
}
/// Nested message and enum types in `InvitationV1`.
pub mod invitation_v1 {
    /// Supported encryption schemes
    /// AES256-GCM-HKDF-SHA256
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Aes256gcmHkdfsha256 {
        /// randomly generated key material (32 bytes)
        #[prost(bytes = "vec", tag = "1")]
        pub key_material: ::prost::alloc::vec::Vec<u8>,
    }
    /// The context type
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Context {
        /// Expected to be a URI (ie xmtp.org/convo1)
        #[prost(string, tag = "1")]
        pub conversation_id: ::prost::alloc::string::String,
        /// Key value map of additional metadata that would be exposed to
        /// application developers and could be used for filtering
        #[prost(map = "string, string", tag = "2")]
        pub metadata: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    /// message encryption scheme and keys for this conversation.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Encryption {
        /// Specify the encryption method to process the key material properly.
        #[prost(message, tag = "3")]
        Aes256GcmHkdfSha256(Aes256gcmHkdfsha256),
    }
}
/// Sealed Invitation V1 Header
/// Header carries information that is unencrypted, thus readable by the network
/// it is however authenticated as associated data with the AEAD scheme used
/// to encrypt the invitation body, thus providing tamper evidence.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SealedInvitationHeaderV1 {
    #[prost(message, optional, tag = "1")]
    pub sender: ::core::option::Option<SignedPublicKeyBundle>,
    #[prost(message, optional, tag = "2")]
    pub recipient: ::core::option::Option<SignedPublicKeyBundle>,
    #[prost(uint64, tag = "3")]
    pub created_ns: u64,
}
/// Sealed Invitation V1
/// Invitation encrypted with key material derived from the sender's and
/// recipient's public key bundles using simplified X3DH where
/// the sender's ephemeral key is replaced with sender's pre-key.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SealedInvitationV1 {
    /// encoded SealedInvitationHeaderV1 used as associated data for Ciphertext
    #[prost(bytes = "vec", tag = "1")]
    pub header_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Ciphertext.payload MUST contain encrypted InvitationV1.
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
}
/// Versioned Sealed Invitation
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SealedInvitation {
    #[prost(oneof = "sealed_invitation::Version", tags = "1")]
    pub version: ::core::option::Option<sealed_invitation::Version>,
}
/// Nested message and enum types in `SealedInvitation`.
pub mod sealed_invitation {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::SealedInvitationV1),
    }
}
/// Payload for user's consent proof to be set in the invitation
/// Signifying the conversation should be preapproved for the user on receipt
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsentProofPayload {
    /// the user's signature in hex format
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
    /// approximate time when the user signed
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    /// version of the payload
    #[prost(enumeration = "ConsentProofPayloadVersion", tag = "3")]
    pub payload_version: i32,
}
/// Version of consent proof payload
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsentProofPayloadVersion {
    Unspecified = 0,
    ConsentProofPayloadVersion1 = 1,
}
impl ConsentProofPayloadVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED",
            Self::ConsentProofPayloadVersion1 => "CONSENT_PROOF_PAYLOAD_VERSION_1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "CONSENT_PROOF_PAYLOAD_VERSION_1" => Some(Self::ConsentProofPayloadVersion1),
            _ => None,
        }
    }
}
/// A light pointer for a conversation that contains no decryption keys
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationReference {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub peer_address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub created_ns: u64,
    #[prost(message, optional, tag = "4")]
    pub context: ::core::option::Option<invitation_v1::Context>,
    #[prost(message, optional, tag = "5")]
    pub consent_proof_payload: ::core::option::Option<ConsentProofPayload>,
}
/// PrivateKey generalized to support different key types
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedPrivateKey {
    /// time the key was created
    #[prost(uint64, tag = "1")]
    pub created_ns: u64,
    /// public key for this private key
    #[prost(message, optional, tag = "3")]
    pub public_key: ::core::option::Option<SignedPublicKey>,
    /// private key
    #[prost(oneof = "signed_private_key::Union", tags = "2")]
    pub union: ::core::option::Option<signed_private_key::Union>,
}
/// Nested message and enum types in `SignedPrivateKey`.
pub mod signed_private_key {
    /// EC: SECP256k1
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Secp256k1 {
        /// D big-endian, 32 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    /// private key
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "2")]
        Secp256k1(Secp256k1),
    }
}
/// PrivateKeyBundle wraps the identityKey and the preKeys,
/// enforces usage of signed keys.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyBundleV2 {
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<SignedPrivateKey>,
    /// all the known pre-keys, newer keys first,
    #[prost(message, repeated, tag = "2")]
    pub pre_keys: ::prost::alloc::vec::Vec<SignedPrivateKey>,
}
/// LEGACY: PrivateKey generalized to support different key types
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKey {
    /// time the key was created
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
    /// public key for this private key
    #[prost(message, optional, tag = "3")]
    pub public_key: ::core::option::Option<PublicKey>,
    /// private key
    #[prost(oneof = "private_key::Union", tags = "2")]
    pub union: ::core::option::Option<private_key::Union>,
}
/// Nested message and enum types in `PrivateKey`.
pub mod private_key {
    /// EC: SECP256k1
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Secp256k1 {
        /// D big-endian, 32 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    /// private key
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "2")]
        Secp256k1(Secp256k1),
    }
}
/// LEGACY: PrivateKeyBundleV1 wraps the identityKey and the preKeys
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyBundleV1 {
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<PrivateKey>,
    /// all the known pre-keys, newer keys first,
    #[prost(message, repeated, tag = "2")]
    pub pre_keys: ::prost::alloc::vec::Vec<PrivateKey>,
}
/// Versioned PrivateKeyBundle
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyBundle {
    #[prost(oneof = "private_key_bundle::Version", tags = "1, 2")]
    pub version: ::core::option::Option<private_key_bundle::Version>,
}
/// Nested message and enum types in `PrivateKeyBundle`.
pub mod private_key_bundle {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::PrivateKeyBundleV1),
        #[prost(message, tag = "2")]
        V2(super::PrivateKeyBundleV2),
    }
}
/// PrivateKeyBundle encrypted with key material generated by
/// signing a randomly generated "pre-key" with the user's wallet,
/// i.e. EIP-191 signature of a "storage signature" message with
/// the pre-key embedded in it.
/// (see xmtp-js::PrivateKeyBundle.toEncryptedBytes for details)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptedPrivateKeyBundleV1 {
    /// randomly generated pre-key
    ///
    /// 32 bytes
    #[prost(bytes = "vec", tag = "1")]
    pub wallet_pre_key: ::prost::alloc::vec::Vec<u8>,
    /// MUST contain encrypted PrivateKeyBundle
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
}
/// Versioned encrypted PrivateKeyBundle
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptedPrivateKeyBundle {
    #[prost(oneof = "encrypted_private_key_bundle::Version", tags = "1")]
    pub version: ::core::option::Option<encrypted_private_key_bundle::Version>,
}
/// Nested message and enum types in `EncryptedPrivateKeyBundle`.
pub mod encrypted_private_key_bundle {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::EncryptedPrivateKeyBundleV1),
    }
}
/// PrivatePreferencesAction is a message used to update the client's preference
/// store.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePreferencesAction {
    #[prost(
        oneof = "private_preferences_action::MessageType",
        tags = "1, 2, 3, 4, 5, 6"
    )]
    pub message_type: ::core::option::Option<private_preferences_action::MessageType>,
}
/// Nested message and enum types in `PrivatePreferencesAction`.
pub mod private_preferences_action {
    /// Allow 1:1 direct message (DM) access
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AllowAddress {
        /// Add the given wallet addresses to the allow list
        #[prost(string, repeated, tag = "1")]
        pub wallet_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Deny (block) 1:1 direct message (DM) access
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DenyAddress {
        /// Add the given wallet addresses to the deny list
        #[prost(string, repeated, tag = "1")]
        pub wallet_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Allow V3 1:1 direct message (DM) access
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AllowInboxId {
        /// Add the given inbox id to the allow list
        #[prost(string, repeated, tag = "1")]
        pub inbox_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Deny (block) V3 1:1 direct message (DM) access
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DenyInboxId {
        /// Add the given inbox id to the deny list
        #[prost(string, repeated, tag = "1")]
        pub inbox_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Allow Group access
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AllowGroup {
        /// Add the given group_ids to the allow list
        #[prost(string, repeated, tag = "1")]
        pub group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Deny (deny) Group access
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DenyGroup {
        /// Add the given group_ids to the deny list
        #[prost(string, repeated, tag = "1")]
        pub group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MessageType {
        #[prost(message, tag = "1")]
        AllowAddress(AllowAddress),
        #[prost(message, tag = "2")]
        DenyAddress(DenyAddress),
        #[prost(message, tag = "3")]
        AllowGroup(AllowGroup),
        #[prost(message, tag = "4")]
        DenyGroup(DenyGroup),
        #[prost(message, tag = "5")]
        AllowInboxId(AllowInboxId),
        #[prost(message, tag = "6")]
        DenyInboxId(DenyInboxId),
    }
}
/// The payload that goes over the wire
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePreferencesPayload {
    #[prost(oneof = "private_preferences_payload::Version", tags = "1")]
    pub version: ::core::option::Option<private_preferences_payload::Version>,
}
/// Nested message and enum types in `PrivatePreferencesPayload`.
pub mod private_preferences_payload {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::Ciphertext),
    }
}
/// Message header is encoded separately as the bytes are also used
/// as associated data for authenticated encryption
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageHeaderV1 {
    #[prost(message, optional, tag = "1")]
    pub sender: ::core::option::Option<PublicKeyBundle>,
    #[prost(message, optional, tag = "2")]
    pub recipient: ::core::option::Option<PublicKeyBundle>,
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
}
/// Message is the top level protocol element
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageV1 {
    /// encapsulates encoded MessageHeaderV1
    #[prost(bytes = "vec", tag = "1")]
    pub header_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Ciphertext.payload MUST contain encrypted EncodedContent
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
}
/// Message header carries information that is not encrypted, and is therefore
/// observable by the network. It is however authenticated as associated data
/// of the AEAD encryption used to protect the message,
/// thus providing tamper evidence.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageHeaderV2 {
    /// sender specified message creation time
    #[prost(uint64, tag = "1")]
    pub created_ns: u64,
    /// the topic the message belongs to
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
}
/// Message combines the encoded header with the encrypted payload.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageV2 {
    /// encapsulates encoded MessageHeaderV2
    #[prost(bytes = "vec", tag = "1")]
    pub header_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Ciphertext.payload MUST contain encrypted SignedContent
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
    /// HMAC of the message ciphertext, with the HMAC key derived from the topic
    /// key
    #[prost(bytes = "vec", optional, tag = "3")]
    pub sender_hmac: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Flag indicating whether the message should be pushed from a notification
    /// server
    #[prost(bool, optional, tag = "4")]
    pub should_push: ::core::option::Option<bool>,
}
/// Versioned Message
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(oneof = "message::Version", tags = "1, 2")]
    pub version: ::core::option::Option<message::Version>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::MessageV1),
        #[prost(message, tag = "2")]
        V2(super::MessageV2),
    }
}
/// DecodedMessage represents the decrypted message contents.
/// DecodedMessage instances are not stored on the network, but
/// may be serialized and stored by clients
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecodedMessage {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sender_address: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "4")]
    pub recipient_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub sent_ns: u64,
    #[prost(string, tag = "6")]
    pub content_topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub conversation: ::core::option::Option<ConversationReference>,
    /// encapsulates EncodedContent
    #[prost(bytes = "vec", tag = "8")]
    pub content_bytes: ::prost::alloc::vec::Vec<u8>,
}
