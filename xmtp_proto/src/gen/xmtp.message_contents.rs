// This file is @generated by prost-build.
/// Signature represents a generalized public key signature,
/// defined as a union to support cryptographic algorithm agility.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Signature {
    #[prost(oneof = "signature::Union", tags = "1, 2")]
    pub union: ::core::option::Option<signature::Union>,
}
/// Nested message and enum types in `Signature`.
pub mod signature {
    /// ECDSA signature bytes and the recovery bit
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EcdsaCompact {
        /// compact representation \[ R || S \], 64 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
        /// recovery bit
        #[prost(uint32, tag = "2")]
        pub recovery: u32,
    }
    impl ::prost::Name for EcdsaCompact {
        const NAME: &'static str = "ECDSACompact";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.Signature.ECDSACompact".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.Signature.ECDSACompact".into()
        }
    }
    /// ECDSA signature bytes and the recovery bit
    /// produced by xmtp-js::PublicKey.signWithWallet function, i.e.
    /// EIP-191 signature of a "Create Identity" message with the key embedded.
    /// Used to sign identity keys.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct WalletEcdsaCompact {
        /// compact representation \[ R || S \], 64 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
        /// recovery bit
        #[prost(uint32, tag = "2")]
        pub recovery: u32,
    }
    impl ::prost::Name for WalletEcdsaCompact {
        const NAME: &'static str = "WalletECDSACompact";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.Signature.WalletECDSACompact".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.Signature.WalletECDSACompact".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "1")]
        EcdsaCompact(EcdsaCompact),
        #[prost(message, tag = "2")]
        WalletEcdsaCompact(WalletEcdsaCompact),
    }
}
impl ::prost::Name for Signature {
    const NAME: &'static str = "Signature";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.Signature".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.Signature".into()
    }
}
/// UnsignedPublicKey represents a generalized public key,
/// defined as a union to support cryptographic algorithm agility.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnsignedPublicKey {
    #[prost(uint64, tag = "1")]
    pub created_ns: u64,
    #[prost(oneof = "unsigned_public_key::Union", tags = "3")]
    pub union: ::core::option::Option<unsigned_public_key::Union>,
}
/// Nested message and enum types in `UnsignedPublicKey`.
pub mod unsigned_public_key {
    /// EC: SECP256k1
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Secp256k1Uncompressed {
        /// uncompressed point with prefix (0x04) \[ P || X || Y \], 65 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Secp256k1Uncompressed {
        const NAME: &'static str = "Secp256k1Uncompressed";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "3")]
        Secp256k1Uncompressed(Secp256k1Uncompressed),
    }
}
impl ::prost::Name for UnsignedPublicKey {
    const NAME: &'static str = "UnsignedPublicKey";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.UnsignedPublicKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.UnsignedPublicKey".into()
    }
}
/// SignedPublicKey
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedPublicKey {
    /// embeds an UnsignedPublicKey
    #[prost(bytes = "vec", tag = "1")]
    pub key_bytes: ::prost::alloc::vec::Vec<u8>,
    /// signs key_bytes
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
}
impl ::prost::Name for SignedPublicKey {
    const NAME: &'static str = "SignedPublicKey";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SignedPublicKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SignedPublicKey".into()
    }
}
/// PublicKeyBundle packages the cryptographic keys associated with a wallet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedPublicKeyBundle {
    /// Identity key MUST be signed by the wallet.
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<SignedPublicKey>,
    /// Pre-key MUST be signed by the identity key.
    #[prost(message, optional, tag = "2")]
    pub pre_key: ::core::option::Option<SignedPublicKey>,
}
impl ::prost::Name for SignedPublicKeyBundle {
    const NAME: &'static str = "SignedPublicKeyBundle";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SignedPublicKeyBundle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SignedPublicKeyBundle".into()
    }
}
/// PublicKey represents a generalized public key,
/// defined as a union to support cryptographic algorithm agility.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PublicKey {
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
    #[prost(oneof = "public_key::Union", tags = "3")]
    pub union: ::core::option::Option<public_key::Union>,
}
/// Nested message and enum types in `PublicKey`.
pub mod public_key {
    /// The key bytes
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Secp256k1Uncompressed {
        /// uncompressed point with prefix (0x04) \[ P || X || Y \], 65 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Secp256k1Uncompressed {
        const NAME: &'static str = "Secp256k1Uncompressed";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PublicKey.Secp256k1Uncompressed".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PublicKey.Secp256k1Uncompressed".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "3")]
        Secp256k1Uncompressed(Secp256k1Uncompressed),
    }
}
impl ::prost::Name for PublicKey {
    const NAME: &'static str = "PublicKey";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PublicKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PublicKey".into()
    }
}
/// PublicKeyBundle packages the cryptographic keys associated with a wallet,
/// both senders and recipients are identified by their key bundles.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PublicKeyBundle {
    /// Identity key MUST be signed by the wallet.
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<PublicKey>,
    /// Pre-key MUST be signed by the identity key.
    #[prost(message, optional, tag = "2")]
    pub pre_key: ::core::option::Option<PublicKey>,
}
impl ::prost::Name for PublicKeyBundle {
    const NAME: &'static str = "PublicKeyBundle";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PublicKeyBundle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PublicKeyBundle".into()
    }
}
/// Ciphertext represents encrypted payload.
/// It is definited as a union to support cryptographic algorithm agility.
/// The payload is accompanied by the cryptographic parameters
/// required by the chosen encryption scheme.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ciphertext {
    #[prost(oneof = "ciphertext::Union", tags = "1")]
    pub union: ::core::option::Option<ciphertext::Union>,
}
/// Nested message and enum types in `Ciphertext`.
pub mod ciphertext {
    /// Encryption: AES256-GCM
    /// Key derivation function: HKDF-SHA256
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Aes256gcmHkdfsha256 {
        /// 32 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub hkdf_salt: ::prost::alloc::vec::Vec<u8>,
        /// 12 bytes
        #[prost(bytes = "vec", tag = "2")]
        pub gcm_nonce: ::prost::alloc::vec::Vec<u8>,
        /// encrypted payload
        #[prost(bytes = "vec", tag = "3")]
        pub payload: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Aes256gcmHkdfsha256 {
        const NAME: &'static str = "Aes256gcmHkdfsha256";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.Ciphertext.Aes256gcmHkdfsha256".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.Ciphertext.Aes256gcmHkdfsha256".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "1")]
        Aes256GcmHkdfSha256(Aes256gcmHkdfsha256),
    }
}
impl ::prost::Name for Ciphertext {
    const NAME: &'static str = "Ciphertext";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.Ciphertext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.Ciphertext".into()
    }
}
/// SignedEciesCiphertext represents an ECIES encrypted payload and a signature
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedEciesCiphertext {
    /// serialized Ecies message
    #[prost(bytes = "vec", tag = "1")]
    pub ecies_bytes: ::prost::alloc::vec::Vec<u8>,
    /// signature of sha256(ecies_bytes) signed with the IdentityKey
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
}
/// Nested message and enum types in `SignedEciesCiphertext`.
pub mod signed_ecies_ciphertext {
    /// Ecies is ciphertext encrypted using ECIES with a MAC
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ecies {
        /// 65 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub ephemeral_public_key: ::prost::alloc::vec::Vec<u8>,
        /// 16 bytes
        #[prost(bytes = "vec", tag = "2")]
        pub iv: ::prost::alloc::vec::Vec<u8>,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub mac: ::prost::alloc::vec::Vec<u8>,
        /// encrypted payload with block size of 16
        #[prost(bytes = "vec", tag = "4")]
        pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Ecies {
        const NAME: &'static str = "Ecies";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.SignedEciesCiphertext.Ecies".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.SignedEciesCiphertext.Ecies".into()
        }
    }
}
impl ::prost::Name for SignedEciesCiphertext {
    const NAME: &'static str = "SignedEciesCiphertext";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SignedEciesCiphertext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SignedEciesCiphertext".into()
    }
}
/// PrivateKey generalized to support different key types
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedPrivateKey {
    /// time the key was created
    #[prost(uint64, tag = "1")]
    pub created_ns: u64,
    /// public key for this private key
    #[prost(message, optional, tag = "3")]
    pub public_key: ::core::option::Option<SignedPublicKey>,
    /// private key
    #[prost(oneof = "signed_private_key::Union", tags = "2")]
    pub union: ::core::option::Option<signed_private_key::Union>,
}
/// Nested message and enum types in `SignedPrivateKey`.
pub mod signed_private_key {
    /// EC: SECP256k1
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Secp256k1 {
        /// D big-endian, 32 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Secp256k1 {
        const NAME: &'static str = "Secp256k1";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.SignedPrivateKey.Secp256k1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.SignedPrivateKey.Secp256k1".into()
        }
    }
    /// private key
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "2")]
        Secp256k1(Secp256k1),
    }
}
impl ::prost::Name for SignedPrivateKey {
    const NAME: &'static str = "SignedPrivateKey";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SignedPrivateKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SignedPrivateKey".into()
    }
}
/// PrivateKeyBundle wraps the identityKey and the preKeys,
/// enforces usage of signed keys.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyBundleV2 {
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<SignedPrivateKey>,
    /// all the known pre-keys, newer keys first,
    #[prost(message, repeated, tag = "2")]
    pub pre_keys: ::prost::alloc::vec::Vec<SignedPrivateKey>,
}
impl ::prost::Name for PrivateKeyBundleV2 {
    const NAME: &'static str = "PrivateKeyBundleV2";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PrivateKeyBundleV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PrivateKeyBundleV2".into()
    }
}
/// LEGACY: PrivateKey generalized to support different key types
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrivateKey {
    /// time the key was created
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
    /// public key for this private key
    #[prost(message, optional, tag = "3")]
    pub public_key: ::core::option::Option<PublicKey>,
    /// private key
    #[prost(oneof = "private_key::Union", tags = "2")]
    pub union: ::core::option::Option<private_key::Union>,
}
/// Nested message and enum types in `PrivateKey`.
pub mod private_key {
    /// EC: SECP256k1
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Secp256k1 {
        /// D big-endian, 32 bytes
        #[prost(bytes = "vec", tag = "1")]
        pub bytes: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Secp256k1 {
        const NAME: &'static str = "Secp256k1";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PrivateKey.Secp256k1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PrivateKey.Secp256k1".into()
        }
    }
    /// private key
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Union {
        #[prost(message, tag = "2")]
        Secp256k1(Secp256k1),
    }
}
impl ::prost::Name for PrivateKey {
    const NAME: &'static str = "PrivateKey";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PrivateKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PrivateKey".into()
    }
}
/// LEGACY: PrivateKeyBundleV1 wraps the identityKey and the preKeys
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyBundleV1 {
    #[prost(message, optional, tag = "1")]
    pub identity_key: ::core::option::Option<PrivateKey>,
    /// all the known pre-keys, newer keys first,
    #[prost(message, repeated, tag = "2")]
    pub pre_keys: ::prost::alloc::vec::Vec<PrivateKey>,
}
impl ::prost::Name for PrivateKeyBundleV1 {
    const NAME: &'static str = "PrivateKeyBundleV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PrivateKeyBundleV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PrivateKeyBundleV1".into()
    }
}
/// Versioned PrivateKeyBundle
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyBundle {
    #[prost(oneof = "private_key_bundle::Version", tags = "1, 2")]
    pub version: ::core::option::Option<private_key_bundle::Version>,
}
/// Nested message and enum types in `PrivateKeyBundle`.
pub mod private_key_bundle {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::PrivateKeyBundleV1),
        #[prost(message, tag = "2")]
        V2(super::PrivateKeyBundleV2),
    }
}
impl ::prost::Name for PrivateKeyBundle {
    const NAME: &'static str = "PrivateKeyBundle";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PrivateKeyBundle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PrivateKeyBundle".into()
    }
}
/// PrivateKeyBundle encrypted with key material generated by
/// signing a randomly generated "pre-key" with the user's wallet,
/// i.e. EIP-191 signature of a "storage signature" message with
/// the pre-key embedded in it.
/// (see xmtp-js::PrivateKeyBundle.toEncryptedBytes for details)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptedPrivateKeyBundleV1 {
    /// randomly generated pre-key
    ///
    /// 32 bytes
    #[prost(bytes = "vec", tag = "1")]
    pub wallet_pre_key: ::prost::alloc::vec::Vec<u8>,
    /// MUST contain encrypted PrivateKeyBundle
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
}
impl ::prost::Name for EncryptedPrivateKeyBundleV1 {
    const NAME: &'static str = "EncryptedPrivateKeyBundleV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.EncryptedPrivateKeyBundleV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.EncryptedPrivateKeyBundleV1".into()
    }
}
/// Versioned encrypted PrivateKeyBundle
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptedPrivateKeyBundle {
    #[prost(oneof = "encrypted_private_key_bundle::Version", tags = "1")]
    pub version: ::core::option::Option<encrypted_private_key_bundle::Version>,
}
/// Nested message and enum types in `EncryptedPrivateKeyBundle`.
pub mod encrypted_private_key_bundle {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::EncryptedPrivateKeyBundleV1),
    }
}
impl ::prost::Name for EncryptedPrivateKeyBundle {
    const NAME: &'static str = "EncryptedPrivateKeyBundle";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.EncryptedPrivateKeyBundle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.EncryptedPrivateKeyBundle".into()
    }
}
/// PrivatePreferencesAction is a message used to update the client's preference
/// store.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrivatePreferencesAction {
    #[prost(
        oneof = "private_preferences_action::MessageType",
        tags = "1, 2, 3, 4, 5, 6"
    )]
    pub message_type: ::core::option::Option<private_preferences_action::MessageType>,
}
/// Nested message and enum types in `PrivatePreferencesAction`.
pub mod private_preferences_action {
    /// Allow 1:1 direct message (DM) access
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AllowAddress {
        /// Add the given wallet addresses to the allow list
        #[prost(string, repeated, tag = "1")]
        pub wallet_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for AllowAddress {
        const NAME: &'static str = "AllowAddress";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PrivatePreferencesAction.AllowAddress".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PrivatePreferencesAction.AllowAddress".into()
        }
    }
    /// Deny (block) 1:1 direct message (DM) access
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DenyAddress {
        /// Add the given wallet addresses to the deny list
        #[prost(string, repeated, tag = "1")]
        pub wallet_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for DenyAddress {
        const NAME: &'static str = "DenyAddress";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PrivatePreferencesAction.DenyAddress".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PrivatePreferencesAction.DenyAddress".into()
        }
    }
    /// Allow V3 1:1 direct message (DM) access
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AllowInboxId {
        /// Add the given inbox id to the allow list
        #[prost(string, repeated, tag = "1")]
        pub inbox_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for AllowInboxId {
        const NAME: &'static str = "AllowInboxId";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PrivatePreferencesAction.AllowInboxId".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PrivatePreferencesAction.AllowInboxId".into()
        }
    }
    /// Deny (block) V3 1:1 direct message (DM) access
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DenyInboxId {
        /// Add the given inbox id to the deny list
        #[prost(string, repeated, tag = "1")]
        pub inbox_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for DenyInboxId {
        const NAME: &'static str = "DenyInboxId";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PrivatePreferencesAction.DenyInboxId".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PrivatePreferencesAction.DenyInboxId".into()
        }
    }
    /// Allow Group access
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AllowGroup {
        /// Add the given group_ids to the allow list
        #[prost(string, repeated, tag = "1")]
        pub group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for AllowGroup {
        const NAME: &'static str = "AllowGroup";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PrivatePreferencesAction.AllowGroup".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PrivatePreferencesAction.AllowGroup".into()
        }
    }
    /// Deny (deny) Group access
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DenyGroup {
        /// Add the given group_ids to the deny list
        #[prost(string, repeated, tag = "1")]
        pub group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for DenyGroup {
        const NAME: &'static str = "DenyGroup";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.PrivatePreferencesAction.DenyGroup".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.PrivatePreferencesAction.DenyGroup".into()
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum MessageType {
        #[prost(message, tag = "1")]
        AllowAddress(AllowAddress),
        #[prost(message, tag = "2")]
        DenyAddress(DenyAddress),
        #[prost(message, tag = "3")]
        AllowGroup(AllowGroup),
        #[prost(message, tag = "4")]
        DenyGroup(DenyGroup),
        #[prost(message, tag = "5")]
        AllowInboxId(AllowInboxId),
        #[prost(message, tag = "6")]
        DenyInboxId(DenyInboxId),
    }
}
impl ::prost::Name for PrivatePreferencesAction {
    const NAME: &'static str = "PrivatePreferencesAction";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PrivatePreferencesAction".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PrivatePreferencesAction".into()
    }
}
/// The payload that goes over the wire
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrivatePreferencesPayload {
    #[prost(oneof = "private_preferences_payload::Version", tags = "1")]
    pub version: ::core::option::Option<private_preferences_payload::Version>,
}
/// Nested message and enum types in `PrivatePreferencesPayload`.
pub mod private_preferences_payload {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::Ciphertext),
    }
}
impl ::prost::Name for PrivatePreferencesPayload {
    const NAME: &'static str = "PrivatePreferencesPayload";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.PrivatePreferencesPayload".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.PrivatePreferencesPayload".into()
    }
}
/// Unsealed invitation V1
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvitationV1 {
    /// topic name chosen for this conversation.
    /// It MUST be randomly generated bytes (length >= 32),
    /// then base64 encoded without padding
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// A context object defining metadata
    #[prost(message, optional, tag = "2")]
    pub context: ::core::option::Option<invitation_v1::Context>,
    /// The user's consent proof
    #[prost(message, optional, tag = "4")]
    pub consent_proof: ::core::option::Option<ConsentProofPayload>,
    /// message encryption scheme and keys for this conversation.
    #[prost(oneof = "invitation_v1::Encryption", tags = "3")]
    pub encryption: ::core::option::Option<invitation_v1::Encryption>,
}
/// Nested message and enum types in `InvitationV1`.
pub mod invitation_v1 {
    /// Supported encryption schemes
    /// AES256-GCM-HKDF-SHA256
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Aes256gcmHkdfsha256 {
        /// randomly generated key material (32 bytes)
        #[prost(bytes = "vec", tag = "1")]
        pub key_material: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for Aes256gcmHkdfsha256 {
        const NAME: &'static str = "Aes256gcmHkdfsha256";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.InvitationV1.Aes256gcmHkdfsha256".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.InvitationV1.Aes256gcmHkdfsha256".into()
        }
    }
    /// The context type
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Context {
        /// Expected to be a URI (ie xmtp.org/convo1)
        #[prost(string, tag = "1")]
        pub conversation_id: ::prost::alloc::string::String,
        /// Key value map of additional metadata that would be exposed to
        /// application developers and could be used for filtering
        #[prost(map = "string, string", tag = "2")]
        pub metadata: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    impl ::prost::Name for Context {
        const NAME: &'static str = "Context";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.InvitationV1.Context".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.InvitationV1.Context".into()
        }
    }
    /// message encryption scheme and keys for this conversation.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Encryption {
        /// Specify the encryption method to process the key material properly.
        #[prost(message, tag = "3")]
        Aes256GcmHkdfSha256(Aes256gcmHkdfsha256),
    }
}
impl ::prost::Name for InvitationV1 {
    const NAME: &'static str = "InvitationV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.InvitationV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.InvitationV1".into()
    }
}
/// Sealed Invitation V1 Header
/// Header carries information that is unencrypted, thus readable by the network
/// it is however authenticated as associated data with the AEAD scheme used
/// to encrypt the invitation body, thus providing tamper evidence.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SealedInvitationHeaderV1 {
    #[prost(message, optional, tag = "1")]
    pub sender: ::core::option::Option<SignedPublicKeyBundle>,
    #[prost(message, optional, tag = "2")]
    pub recipient: ::core::option::Option<SignedPublicKeyBundle>,
    #[prost(uint64, tag = "3")]
    pub created_ns: u64,
}
impl ::prost::Name for SealedInvitationHeaderV1 {
    const NAME: &'static str = "SealedInvitationHeaderV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SealedInvitationHeaderV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SealedInvitationHeaderV1".into()
    }
}
/// Sealed Invitation V1
/// Invitation encrypted with key material derived from the sender's and
/// recipient's public key bundles using simplified X3DH where
/// the sender's ephemeral key is replaced with sender's pre-key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SealedInvitationV1 {
    /// encoded SealedInvitationHeaderV1 used as associated data for Ciphertext
    #[prost(bytes = "vec", tag = "1")]
    pub header_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Ciphertext.payload MUST contain encrypted InvitationV1.
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
}
impl ::prost::Name for SealedInvitationV1 {
    const NAME: &'static str = "SealedInvitationV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SealedInvitationV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SealedInvitationV1".into()
    }
}
/// Versioned Sealed Invitation
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SealedInvitation {
    #[prost(oneof = "sealed_invitation::Version", tags = "1")]
    pub version: ::core::option::Option<sealed_invitation::Version>,
}
/// Nested message and enum types in `SealedInvitation`.
pub mod sealed_invitation {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::SealedInvitationV1),
    }
}
impl ::prost::Name for SealedInvitation {
    const NAME: &'static str = "SealedInvitation";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SealedInvitation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SealedInvitation".into()
    }
}
/// Payload for user's consent proof to be set in the invitation
/// Signifying the conversation should be preapproved for the user on receipt
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConsentProofPayload {
    /// the user's signature in hex format
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
    /// approximate time when the user signed
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    /// version of the payload
    #[prost(enumeration = "ConsentProofPayloadVersion", tag = "3")]
    pub payload_version: i32,
}
impl ::prost::Name for ConsentProofPayload {
    const NAME: &'static str = "ConsentProofPayload";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.ConsentProofPayload".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.ConsentProofPayload".into()
    }
}
/// Version of consent proof payload
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsentProofPayloadVersion {
    Unspecified = 0,
    ConsentProofPayloadVersion1 = 1,
}
impl ConsentProofPayloadVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED",
            Self::ConsentProofPayloadVersion1 => "CONSENT_PROOF_PAYLOAD_VERSION_1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "CONSENT_PROOF_PAYLOAD_VERSION_1" => Some(Self::ConsentProofPayloadVersion1),
            _ => None,
        }
    }
}
/// A light pointer for a conversation that contains no decryption keys
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationReference {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub peer_address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub created_ns: u64,
    #[prost(message, optional, tag = "4")]
    pub context: ::core::option::Option<invitation_v1::Context>,
    #[prost(message, optional, tag = "5")]
    pub consent_proof_payload: ::core::option::Option<ConsentProofPayload>,
}
impl ::prost::Name for ConversationReference {
    const NAME: &'static str = "ConversationReference";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.ConversationReference".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.ConversationReference".into()
    }
}
/// Message header is encoded separately as the bytes are also used
/// as associated data for authenticated encryption
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageHeaderV1 {
    #[prost(message, optional, tag = "1")]
    pub sender: ::core::option::Option<PublicKeyBundle>,
    #[prost(message, optional, tag = "2")]
    pub recipient: ::core::option::Option<PublicKeyBundle>,
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
}
impl ::prost::Name for MessageHeaderV1 {
    const NAME: &'static str = "MessageHeaderV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.MessageHeaderV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.MessageHeaderV1".into()
    }
}
/// Message is the top level protocol element
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageV1 {
    /// encapsulates encoded MessageHeaderV1
    #[prost(bytes = "vec", tag = "1")]
    pub header_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Ciphertext.payload MUST contain encrypted EncodedContent
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
}
impl ::prost::Name for MessageV1 {
    const NAME: &'static str = "MessageV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.MessageV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.MessageV1".into()
    }
}
/// Message header carries information that is not encrypted, and is therefore
/// observable by the network. It is however authenticated as associated data
/// of the AEAD encryption used to protect the message,
/// thus providing tamper evidence.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageHeaderV2 {
    /// sender specified message creation time
    #[prost(uint64, tag = "1")]
    pub created_ns: u64,
    /// the topic the message belongs to
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
}
impl ::prost::Name for MessageHeaderV2 {
    const NAME: &'static str = "MessageHeaderV2";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.MessageHeaderV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.MessageHeaderV2".into()
    }
}
/// Message combines the encoded header with the encrypted payload.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageV2 {
    /// encapsulates encoded MessageHeaderV2
    #[prost(bytes = "vec", tag = "1")]
    pub header_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Ciphertext.payload MUST contain encrypted SignedContent
    #[prost(message, optional, tag = "2")]
    pub ciphertext: ::core::option::Option<Ciphertext>,
    /// HMAC of the message ciphertext, with the HMAC key derived from the topic
    /// key
    #[prost(bytes = "vec", optional, tag = "3")]
    pub sender_hmac: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Flag indicating whether the message should be pushed from a notification
    /// server
    #[prost(bool, optional, tag = "4")]
    pub should_push: ::core::option::Option<bool>,
}
impl ::prost::Name for MessageV2 {
    const NAME: &'static str = "MessageV2";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.MessageV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.MessageV2".into()
    }
}
/// Versioned Message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Message {
    #[prost(oneof = "message::Version", tags = "1, 2")]
    pub version: ::core::option::Option<message::Version>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::MessageV1),
        #[prost(message, tag = "2")]
        V2(super::MessageV2),
    }
}
impl ::prost::Name for Message {
    const NAME: &'static str = "Message";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.Message".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.Message".into()
    }
}
/// DecodedMessage represents the decrypted message contents.
/// DecodedMessage instances are not stored on the network, but
/// may be serialized and stored by clients
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecodedMessage {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sender_address: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "4")]
    pub recipient_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub sent_ns: u64,
    #[prost(string, tag = "6")]
    pub content_topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub conversation: ::core::option::Option<ConversationReference>,
    /// encapsulates EncodedContent
    #[prost(bytes = "vec", tag = "8")]
    pub content_bytes: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for DecodedMessage {
    const NAME: &'static str = "DecodedMessage";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.DecodedMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.DecodedMessage".into()
    }
}
/// ContentTypeId is used to identify the type of content stored in a Message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContentTypeId {
    /// authority governing this content type
    #[prost(string, tag = "1")]
    pub authority_id: ::prost::alloc::string::String,
    /// type identifier
    #[prost(string, tag = "2")]
    pub type_id: ::prost::alloc::string::String,
    /// major version of the type
    #[prost(uint32, tag = "3")]
    pub version_major: u32,
    /// minor version of the type
    #[prost(uint32, tag = "4")]
    pub version_minor: u32,
}
impl ::prost::Name for ContentTypeId {
    const NAME: &'static str = "ContentTypeId";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.ContentTypeId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.ContentTypeId".into()
    }
}
/// EncodedContent bundles the content with metadata identifying its type
/// and parameters required for correct decoding and presentation of the content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncodedContent {
    /// content type identifier used to match the payload with
    /// the correct decoding machinery
    #[prost(message, optional, tag = "1")]
    pub r#type: ::core::option::Option<ContentTypeId>,
    /// optional encoding parameters required to correctly decode the content
    #[prost(map = "string, string", tag = "2")]
    pub parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// optional fallback description of the content that can be used in case
    /// the client cannot decode or render the content
    #[prost(string, optional, tag = "3")]
    pub fallback: ::core::option::Option<::prost::alloc::string::String>,
    /// optional compression; the value indicates algorithm used to
    /// compress the encoded content bytes
    #[prost(enumeration = "Compression", optional, tag = "5")]
    pub compression: ::core::option::Option<i32>,
    /// encoded content itself
    #[prost(bytes = "vec", tag = "4")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for EncodedContent {
    const NAME: &'static str = "EncodedContent";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.EncodedContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.EncodedContent".into()
    }
}
/// SignedContent attaches a signature to EncodedContent.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedContent {
    /// MUST contain EncodedContent
    #[prost(bytes = "vec", tag = "1")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub sender: ::core::option::Option<SignedPublicKeyBundle>,
    /// MUST be a signature of a concatenation of
    /// the message header bytes and the payload bytes,
    /// signed by the sender's pre-key.
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<Signature>,
}
impl ::prost::Name for SignedContent {
    const NAME: &'static str = "SignedContent";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SignedContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SignedContent".into()
    }
}
/// Recognized compression algorithms
/// protolint:disable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Compression {
    Deflate = 0,
    Gzip = 1,
}
impl Compression {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Deflate => "COMPRESSION_DEFLATE",
            Self::Gzip => "COMPRESSION_GZIP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESSION_DEFLATE" => Some(Self::Deflate),
            "COMPRESSION_GZIP" => Some(Self::Gzip),
            _ => None,
        }
    }
}
/// Composite is used to implement xmtp.org/composite content type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Composite {
    #[prost(message, repeated, tag = "1")]
    pub parts: ::prost::alloc::vec::Vec<composite::Part>,
}
/// Nested message and enum types in `Composite`.
pub mod composite {
    /// Part represents one section of a composite message
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Part {
        #[prost(oneof = "part::Element", tags = "1, 2")]
        pub element: ::core::option::Option<part::Element>,
    }
    /// Nested message and enum types in `Part`.
    pub mod part {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Element {
            #[prost(message, tag = "1")]
            Part(super::super::EncodedContent),
            #[prost(message, tag = "2")]
            Composite(super::super::Composite),
        }
    }
    impl ::prost::Name for Part {
        const NAME: &'static str = "Part";
        const PACKAGE: &'static str = "xmtp.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.message_contents.Composite.Part".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.message_contents.Composite.Part".into()
        }
    }
}
impl ::prost::Name for Composite {
    const NAME: &'static str = "Composite";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.Composite".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.Composite".into()
    }
}
/// EciesMessage is a wrapper for ECIES encrypted payloads
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EciesMessage {
    #[prost(oneof = "ecies_message::Version", tags = "1")]
    pub version: ::core::option::Option<ecies_message::Version>,
}
/// Nested message and enum types in `EciesMessage`.
pub mod ecies_message {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        /// Expected to be an ECIES encrypted SignedPayload
        #[prost(bytes, tag = "1")]
        V1(::prost::alloc::vec::Vec<u8>),
    }
}
impl ::prost::Name for EciesMessage {
    const NAME: &'static str = "EciesMessage";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.EciesMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.EciesMessage".into()
    }
}
/// The message that will be signed by the Client and returned inside the
/// `action_body` field of the FrameAction message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameActionBody {
    /// The URL of the frame that was clicked
    /// May be different from `post_url`
    #[prost(string, tag = "1")]
    pub frame_url: ::prost::alloc::string::String,
    /// The 1-indexed button that was clicked
    #[prost(int32, tag = "2")]
    pub button_index: i32,
    /// Timestamp of the click in milliseconds since the epoch
    #[deprecated]
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
    /// A unique identifier for the conversation, not tied to anything on the
    /// network. Will not match the topic or conversation_id
    #[prost(string, tag = "4")]
    pub opaque_conversation_identifier: ::prost::alloc::string::String,
    /// Unix timestamp
    #[prost(uint32, tag = "5")]
    pub unix_timestamp: u32,
    /// Input text from a text input field
    #[prost(string, tag = "6")]
    pub input_text: ::prost::alloc::string::String,
    /// A state serialized to a string (for example via JSON.stringify()). Maximum 4096 bytes.
    #[prost(string, tag = "7")]
    pub state: ::prost::alloc::string::String,
    /// A 0x wallet address
    #[prost(string, tag = "8")]
    pub address: ::prost::alloc::string::String,
    /// A hash from a transaction
    #[prost(string, tag = "9")]
    pub transaction_id: ::prost::alloc::string::String,
}
impl ::prost::Name for FrameActionBody {
    const NAME: &'static str = "FrameActionBody";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.FrameActionBody".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.FrameActionBody".into()
    }
}
/// The outer payload that will be sent as the `messageBytes` in the
/// `trusted_data` part of the Frames message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameAction {
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub signature: ::core::option::Option<Signature>,
    /// The SignedPublicKeyBundle of the signer, used to link the XMTP signature
    /// with a blockchain account through a chain of signatures.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub signed_public_key_bundle: ::core::option::Option<SignedPublicKeyBundle>,
    /// Serialized FrameActionBody message, so that the signature verification can
    /// happen on a byte-perfect representation of the message
    #[prost(bytes = "vec", tag = "3")]
    pub action_body: ::prost::alloc::vec::Vec<u8>,
    /// The installation signature
    #[prost(bytes = "vec", tag = "4")]
    pub installation_signature: ::prost::alloc::vec::Vec<u8>,
    /// The public installation id used to sign.
    #[prost(bytes = "vec", tag = "5")]
    pub installation_id: ::prost::alloc::vec::Vec<u8>,
    /// The inbox id of the installation used to sign.
    #[prost(string, tag = "6")]
    pub inbox_id: ::prost::alloc::string::String,
}
impl ::prost::Name for FrameAction {
    const NAME: &'static str = "FrameAction";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.FrameAction".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.FrameAction".into()
    }
}
/// SignedPayload is a wrapper for a signature and a payload
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedPayload {
    #[prost(bytes = "vec", tag = "1")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
}
impl ::prost::Name for SignedPayload {
    const NAME: &'static str = "SignedPayload";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.SignedPayload".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.SignedPayload".into()
    }
}
/// LEGACY: User key bundle V1 using PublicKeys.
/// The PublicKeys MUST be signed.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContactBundleV1 {
    #[prost(message, optional, tag = "1")]
    pub key_bundle: ::core::option::Option<PublicKeyBundle>,
}
impl ::prost::Name for ContactBundleV1 {
    const NAME: &'static str = "ContactBundleV1";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.ContactBundleV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.ContactBundleV1".into()
    }
}
/// User key bundle V2 using SignedPublicKeys.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContactBundleV2 {
    #[prost(message, optional, tag = "1")]
    pub key_bundle: ::core::option::Option<SignedPublicKeyBundle>,
}
impl ::prost::Name for ContactBundleV2 {
    const NAME: &'static str = "ContactBundleV2";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.ContactBundleV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.ContactBundleV2".into()
    }
}
/// Versioned ContactBundle
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContactBundle {
    #[prost(oneof = "contact_bundle::Version", tags = "1, 2")]
    pub version: ::core::option::Option<contact_bundle::Version>,
}
/// Nested message and enum types in `ContactBundle`.
pub mod contact_bundle {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::ContactBundleV1),
        #[prost(message, tag = "2")]
        V2(super::ContactBundleV2),
    }
}
impl ::prost::Name for ContactBundle {
    const NAME: &'static str = "ContactBundle";
    const PACKAGE: &'static str = "xmtp.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.message_contents.ContactBundle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.message_contents.ContactBundle".into()
    }
}
