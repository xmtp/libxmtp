// This file is @generated by prost-build.
/// All potential device sync group messages
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSyncContent {
    #[prost(oneof = "device_sync_content::Content", tags = "1, 2, 3, 4")]
    pub content: ::core::option::Option<device_sync_content::Content>,
}
/// Nested message and enum types in `DeviceSyncContent`.
pub mod device_sync_content {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "1")]
        Request(super::DeviceSyncRequest),
        #[prost(message, tag = "2")]
        Acknowledge(super::DeviceSyncAcknowledge),
        #[prost(message, tag = "3")]
        Reply(super::DeviceSyncReply),
        #[prost(message, tag = "4")]
        PreferenceUpdates(super::PreferenceUpdates),
    }
}
/// Acknowledges a request
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSyncAcknowledge {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Preference updates
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreferenceUpdates {
    #[prost(message, repeated, tag = "1")]
    pub updates: ::prost::alloc::vec::Vec<PreferenceUpdate>,
}
/// Preference update
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreferenceUpdate {
    #[prost(oneof = "preference_update::Update", tags = "1, 2")]
    pub update: ::core::option::Option<preference_update::Update>,
}
/// Nested message and enum types in `PreferenceUpdate`.
pub mod preference_update {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Update {
        #[prost(message, tag = "1")]
        Consent(super::super::consent_backup::ConsentSave),
        #[prost(message, tag = "2")]
        Hmac(super::HmacKeyUpdate),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V1UserPreferenceUpdate {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// Hmac key update
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HmacKeyUpdate {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub cycled_at_ns: i64,
}
/// Initiator or new installation id requesting a sync payload send a request
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSyncRequest {
    /// Unique identifier for each request
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub pin_code: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(enumeration = "super::BackupElementSelection", tag = "3")]
    pub kind: i32,
    #[prost(message, optional, tag = "4")]
    pub options: ::core::option::Option<super::BackupOptions>,
}
/// Pre-existing installation id capable of supplying a sync payload sends this reply
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSyncReply {
    /// Must match an existing request_id from a message history request
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// Where the messages can be retrieved from
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// Encryption key
    #[prost(message, optional, tag = "3")]
    pub encryption_key: ::core::option::Option<DeviceSyncKeyType>,
    /// ns unix timestamp of when the reply was sent
    #[deprecated]
    #[prost(uint64, tag = "4")]
    pub timestamp_ns: u64,
    /// request kind
    #[deprecated]
    #[prost(enumeration = "super::BackupElementSelection", tag = "5")]
    pub kind: i32,
    /// Metadata about the backup
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<super::BackupMetadataSave>,
}
/// Key used to encrypt the message-bundle
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSyncKeyType {
    #[prost(oneof = "device_sync_key_type::Key", tags = "1")]
    pub key: ::core::option::Option<device_sync_key_type::Key>,
}
/// Nested message and enum types in `DeviceSyncKeyType`.
pub mod device_sync_key_type {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Key {
        #[prost(bytes, tag = "1")]
        Aes256Gcm(::prost::alloc::vec::Vec<u8>),
    }
}
