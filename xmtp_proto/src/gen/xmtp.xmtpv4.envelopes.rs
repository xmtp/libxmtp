// This file is @generated by prost-build.
/// A report of the payers and nodes that sent messages in a given range of messages
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayerReport {
    /// The originator this report is referring to
    #[prost(uint32, tag = "1")]
    pub originator_node_id: u32,
    /// The sequence_id that the report starts at \[exclusive\]
    #[prost(uint64, tag = "2")]
    pub start_sequence_id: u64,
    /// The sequence_id that the report ends at \[inclusive\]
    #[prost(uint64, tag = "3")]
    pub end_sequence_id: u64,
    /// The end timestamp of the report
    #[prost(uint32, tag = "4")]
    pub end_minute_since_epoch: u32,
    /// The merkle root of the payer balance diff tree
    #[prost(bytes = "vec", tag = "5")]
    pub payers_merkle_root: ::prost::alloc::vec::Vec<u8>,
    /// The node IDs that are active in the network at the time of the report
    #[prost(uint32, repeated, tag = "6")]
    pub active_node_ids: ::prost::alloc::vec::Vec<u32>,
}
impl ::prost::Name for PayerReport {
    const NAME: &'static str = "PayerReport";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.PayerReport".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.PayerReport".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeSignature {
    #[prost(uint32, tag = "1")]
    pub node_id: u32,
    #[prost(message, optional, tag = "2")]
    pub signature:
        ::core::option::Option<super::super::identity::associations::RecoverableEcdsaSignature>,
}
impl ::prost::Name for NodeSignature {
    const NAME: &'static str = "NodeSignature";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.NodeSignature".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.NodeSignature".into()
    }
}
/// An attestation of a payer report
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayerReportAttestation {
    /// The ID of the report, determined by hashing the report contents
    #[prost(bytes = "vec", tag = "1")]
    pub report_id: ::prost::alloc::vec::Vec<u8>,
    /// The signature of the attester
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<NodeSignature>,
}
impl ::prost::Name for PayerReportAttestation {
    const NAME: &'static str = "PayerReportAttestation";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.PayerReportAttestation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.PayerReportAttestation".into()
    }
}
/// The last seen entry per originator. Originators that have not been seen are omitted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cursor {
    #[prost(map = "uint32, uint64", tag = "1")]
    pub node_id_to_sequence_id: ::std::collections::HashMap<u32, u64>,
}
impl ::prost::Name for Cursor {
    const NAME: &'static str = "Cursor";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.Cursor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.Cursor".into()
    }
}
/// Data visible to the server that has been authenticated by the client.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatedData {
    /// Do NOT reuse tag 1 — previously used by target_originator
    #[prost(bytes = "vec", tag = "2")]
    pub target_topic: ::prost::alloc::vec::Vec<u8>,
    /// Do NOT reuse tag 4 — previously used by is_commit
    #[prost(message, optional, tag = "3")]
    pub depends_on: ::core::option::Option<Cursor>,
}
impl ::prost::Name for AuthenticatedData {
    const NAME: &'static str = "AuthenticatedData";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.AuthenticatedData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.AuthenticatedData".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientEnvelope {
    #[prost(message, optional, tag = "1")]
    pub aad: ::core::option::Option<AuthenticatedData>,
    #[prost(oneof = "client_envelope::Payload", tags = "2, 3, 4, 5, 6, 7")]
    pub payload: ::core::option::Option<client_envelope::Payload>,
}
/// Nested message and enum types in `ClientEnvelope`.
pub mod client_envelope {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "2")]
        GroupMessage(super::super::super::mls::api::v1::GroupMessageInput),
        #[prost(message, tag = "3")]
        WelcomeMessage(super::super::super::mls::api::v1::WelcomeMessageInput),
        #[prost(message, tag = "4")]
        UploadKeyPackage(super::super::super::mls::api::v1::UploadKeyPackageRequest),
        #[prost(message, tag = "5")]
        IdentityUpdate(super::super::super::identity::associations::IdentityUpdate),
        #[prost(message, tag = "6")]
        PayerReport(super::PayerReport),
        #[prost(message, tag = "7")]
        PayerReportAttestation(super::PayerReportAttestation),
    }
}
impl ::prost::Name for ClientEnvelope {
    const NAME: &'static str = "ClientEnvelope";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.ClientEnvelope".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.ClientEnvelope".into()
    }
}
/// Wraps client envelope with payer signature
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayerEnvelope {
    /// Protobuf serialized
    #[prost(bytes = "vec", tag = "1")]
    pub unsigned_client_envelope: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub payer_signature:
        ::core::option::Option<super::super::identity::associations::RecoverableEcdsaSignature>,
    #[prost(uint32, tag = "3")]
    pub target_originator: u32,
    #[prost(uint32, tag = "4")]
    pub message_retention_days: u32,
}
impl ::prost::Name for PayerEnvelope {
    const NAME: &'static str = "PayerEnvelope";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.PayerEnvelope".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.PayerEnvelope".into()
    }
}
/// For blockchain envelopes, these fields are set by the smart contract
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnsignedOriginatorEnvelope {
    #[prost(uint32, tag = "1")]
    pub originator_node_id: u32,
    #[prost(uint64, tag = "2")]
    pub originator_sequence_id: u64,
    #[prost(int64, tag = "3")]
    pub originator_ns: i64,
    #[prost(bytes = "vec", tag = "4")]
    pub payer_envelope_bytes: ::prost::alloc::vec::Vec<u8>,
    /// The base fee for the message in picodollars
    #[prost(uint64, tag = "5")]
    pub base_fee_picodollars: u64,
    /// The congestion fee for the message in picodollars
    #[prost(uint64, tag = "6")]
    pub congestion_fee_picodollars: u64,
    #[prost(uint64, tag = "7")]
    pub expiry_unixtime: u64,
}
impl ::prost::Name for UnsignedOriginatorEnvelope {
    const NAME: &'static str = "UnsignedOriginatorEnvelope";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.UnsignedOriginatorEnvelope".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.UnsignedOriginatorEnvelope".into()
    }
}
/// An alternative to a signature for blockchain payloads
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockchainProof {
    #[prost(bytes = "vec", tag = "1")]
    pub transaction_hash: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for BlockchainProof {
    const NAME: &'static str = "BlockchainProof";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.BlockchainProof".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.BlockchainProof".into()
    }
}
/// Signed originator envelope
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OriginatorEnvelope {
    /// Protobuf serialized
    #[prost(bytes = "vec", tag = "1")]
    pub unsigned_originator_envelope: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "originator_envelope::Proof", tags = "2, 3")]
    pub proof: ::core::option::Option<originator_envelope::Proof>,
}
/// Nested message and enum types in `OriginatorEnvelope`.
pub mod originator_envelope {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Proof {
        #[prost(message, tag = "2")]
        OriginatorSignature(super::super::super::identity::associations::RecoverableEcdsaSignature),
        #[prost(message, tag = "3")]
        BlockchainProof(super::BlockchainProof),
    }
}
impl ::prost::Name for OriginatorEnvelope {
    const NAME: &'static str = "OriginatorEnvelope";
    const PACKAGE: &'static str = "xmtp.xmtpv4.envelopes";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.xmtpv4.envelopes.OriginatorEnvelope".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.xmtpv4.envelopes.OriginatorEnvelope".into()
    }
}
