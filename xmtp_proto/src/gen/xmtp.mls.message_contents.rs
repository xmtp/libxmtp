// This file is @generated by prost-build.
/// PlaintextCommitLogEntry indicates whether a commit was successful or not,
/// when applied on top of the indicated `last_epoch_authenticator`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaintextCommitLogEntry {
    /// The group_id of the group that the commit belongs to.
    #[prost(bytes = "vec", tag = "1")]
    pub group_id: ::prost::alloc::vec::Vec<u8>,
    /// The sequence ID of the commit payload being validated.
    #[prost(uint64, tag = "2")]
    pub commit_sequence_id: u64,
    /// The encryption state before the commit was applied.
    #[prost(bytes = "vec", tag = "3")]
    pub last_epoch_authenticator: ::prost::alloc::vec::Vec<u8>,
    /// Indicates whether the commit was successful, or why it failed.
    #[prost(enumeration = "CommitResult", tag = "4")]
    pub commit_result: i32,
    /// The epoch number after the commit was applied, if successful.
    #[prost(uint64, tag = "5")]
    pub applied_epoch_number: u64,
    /// The encryption state after the commit was applied, if successful.
    #[prost(bytes = "vec", tag = "6")]
    pub applied_epoch_authenticator: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for PlaintextCommitLogEntry {
    const NAME: &'static str = "PlaintextCommitLogEntry";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.PlaintextCommitLogEntry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.PlaintextCommitLogEntry".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommitLogEntry {
    #[prost(uint64, tag = "1")]
    pub sequence_id: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub serialized_commit_log_entry: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<
        super::super::identity::associations::RecoverableEd25519Signature,
    >,
}
impl ::prost::Name for CommitLogEntry {
    const NAME: &'static str = "CommitLogEntry";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.CommitLogEntry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.CommitLogEntry".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommitResult {
    Unspecified = 0,
    Applied = 1,
    WrongEpoch = 2,
    Undecryptable = 3,
    Invalid = 4,
}
impl CommitResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMMIT_RESULT_UNSPECIFIED",
            Self::Applied => "COMMIT_RESULT_APPLIED",
            Self::WrongEpoch => "COMMIT_RESULT_WRONG_EPOCH",
            Self::Undecryptable => "COMMIT_RESULT_UNDECRYPTABLE",
            Self::Invalid => "COMMIT_RESULT_INVALID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMIT_RESULT_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMIT_RESULT_APPLIED" => Some(Self::Applied),
            "COMMIT_RESULT_WRONG_EPOCH" => Some(Self::WrongEpoch),
            "COMMIT_RESULT_UNDECRYPTABLE" => Some(Self::Undecryptable),
            "COMMIT_RESULT_INVALID" => Some(Self::Invalid),
            _ => None,
        }
    }
}
/// The KeyPackageExtension that stores the PubKey and the WelcomeWrapperEncryption
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WelcomeWrapperEncryption {
    #[prost(bytes = "vec", tag = "1")]
    pub pub_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "WelcomeWrapperAlgorithm", tag = "2")]
    pub algorithm: i32,
}
impl ::prost::Name for WelcomeWrapperEncryption {
    const NAME: &'static str = "WelcomeWrapperEncryption";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.WelcomeWrapperEncryption".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.WelcomeWrapperEncryption".into()
    }
}
/// Describes the algorithm used to encrypt the Welcome Wrapper
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WelcomeWrapperAlgorithm {
    Unspecified = 0,
    Curve25519 = 1,
    XwingMlkem768Draft6 = 2,
}
impl WelcomeWrapperAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WELCOME_WRAPPER_ALGORITHM_UNSPECIFIED",
            Self::Curve25519 => "WELCOME_WRAPPER_ALGORITHM_CURVE25519",
            Self::XwingMlkem768Draft6 => {
                "WELCOME_WRAPPER_ALGORITHM_XWING_MLKEM_768_DRAFT_6"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WELCOME_WRAPPER_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "WELCOME_WRAPPER_ALGORITHM_CURVE25519" => Some(Self::Curve25519),
            "WELCOME_WRAPPER_ALGORITHM_XWING_MLKEM_768_DRAFT_6" => {
                Some(Self::XwingMlkem768Draft6)
            }
            _ => None,
        }
    }
}
/// A request sent by an installation to recover from a fork. Other members
/// may remove and readd that installation from the group.
/// XIP: <https://community.xmtp.org/t/xip-68-draft-automated-fork-recovery/951>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReaddRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub group_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub commit_log_epoch: u64,
}
impl ::prost::Name for ReaddRequest {
    const NAME: &'static str = "ReaddRequest";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.ReaddRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.ReaddRequest".into()
    }
}
/// ContentTypeId is used to identify the type of content stored in a Message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContentTypeId {
    /// authority governing this content type
    #[prost(string, tag = "1")]
    pub authority_id: ::prost::alloc::string::String,
    /// type identifier
    #[prost(string, tag = "2")]
    pub type_id: ::prost::alloc::string::String,
    /// major version of the type
    #[prost(uint32, tag = "3")]
    pub version_major: u32,
    /// minor version of the type
    #[prost(uint32, tag = "4")]
    pub version_minor: u32,
}
impl ::prost::Name for ContentTypeId {
    const NAME: &'static str = "ContentTypeId";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.ContentTypeId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.ContentTypeId".into()
    }
}
/// EncodedContent bundles the content with metadata identifying its type
/// and parameters required for correct decoding and presentation of the content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncodedContent {
    /// content type identifier used to match the payload with
    /// the correct decoding machinery
    #[prost(message, optional, tag = "1")]
    pub r#type: ::core::option::Option<ContentTypeId>,
    /// optional encoding parameters required to correctly decode the content
    #[prost(map = "string, string", tag = "2")]
    pub parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// optional fallback description of the content that can be used in case
    /// the client cannot decode or render the content
    #[prost(string, optional, tag = "3")]
    pub fallback: ::core::option::Option<::prost::alloc::string::String>,
    /// optional compression; the value indicates algorithm used to
    /// compress the encoded content bytes
    #[prost(enumeration = "Compression", optional, tag = "5")]
    pub compression: ::core::option::Option<i32>,
    /// encoded content itself
    #[prost(bytes = "vec", tag = "4")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for EncodedContent {
    const NAME: &'static str = "EncodedContent";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.EncodedContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.EncodedContent".into()
    }
}
/// A PlaintextEnvelope is the outermost payload that gets encrypted by MLS
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaintextEnvelope {
    /// Selector which declares which version of the EncodedContent this
    /// PlaintextEnvelope is
    #[prost(oneof = "plaintext_envelope::Content", tags = "1, 2")]
    pub content: ::core::option::Option<plaintext_envelope::Content>,
}
/// Nested message and enum types in `PlaintextEnvelope`.
pub mod plaintext_envelope {
    /// Version 1 of the encrypted envelope
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V1 {
        /// Expected to be EncodedContent
        #[prost(bytes = "vec", tag = "1")]
        pub content: ::prost::alloc::vec::Vec<u8>,
        /// A unique value that can be used to ensure that the same content can
        /// produce different hashes. May be the sender timestamp.
        #[prost(string, tag = "2")]
        pub idempotency_key: ::prost::alloc::string::String,
    }
    impl ::prost::Name for V1 {
        const NAME: &'static str = "V1";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.PlaintextEnvelope.V1".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.PlaintextEnvelope.V1".into()
        }
    }
    /// Version 2 of the encrypted envelope
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct V2 {
        /// A unique value that can be used to ensure that the same content can
        /// produce different hashes. May be the sender timestamp.
        #[prost(string, tag = "1")]
        pub idempotency_key: ::prost::alloc::string::String,
        #[prost(oneof = "v2::MessageType", tags = "2, 3, 4, 5, 6")]
        pub message_type: ::core::option::Option<v2::MessageType>,
    }
    /// Nested message and enum types in `V2`.
    pub mod v2 {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum MessageType {
            /// Expected to be EncodedContent
            #[prost(bytes, tag = "2")]
            Content(::prost::alloc::vec::Vec<u8>),
            /// Initiator sends a request to receive sync payload
            #[prost(message, tag = "3")]
            DeviceSyncRequest(
                super::super::super::super::device_sync::content::DeviceSyncRequest,
            ),
            /// Some other authorized installation sends a reply with a link to payload
            #[prost(message, tag = "4")]
            DeviceSyncReply(
                super::super::super::super::device_sync::content::DeviceSyncReply,
            ),
            /// A serialized user preference update
            #[prost(message, tag = "5")]
            UserPreferenceUpdate(
                super::super::super::super::device_sync::content::V1UserPreferenceUpdate,
            ),
            /// A readd request for fork recovery
            #[prost(message, tag = "6")]
            ReaddRequest(super::super::ReaddRequest),
        }
    }
    impl ::prost::Name for V2 {
        const NAME: &'static str = "V2";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.PlaintextEnvelope.V2".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.PlaintextEnvelope.V2".into()
        }
    }
    /// Selector which declares which version of the EncodedContent this
    /// PlaintextEnvelope is
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "1")]
        V1(V1),
        #[prost(message, tag = "2")]
        V2(V2),
    }
}
impl ::prost::Name for PlaintextEnvelope {
    const NAME: &'static str = "PlaintextEnvelope";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.PlaintextEnvelope".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.PlaintextEnvelope".into()
    }
}
/// Recognized compression algorithms
/// protolint:disable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Compression {
    Deflate = 0,
    Gzip = 1,
}
impl Compression {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Deflate => "COMPRESSION_DEFLATE",
            Self::Gzip => "COMPRESSION_GZIP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESSION_DEFLATE" => Some(Self::Deflate),
            "COMPRESSION_GZIP" => Some(Self::Gzip),
            _ => None,
        }
    }
}
/// Contains a mapping of `inbox_id` -> `sequence_id` for all members of a group.
/// Designed to be stored in the group context extension of the MLS group
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMembership {
    #[prost(map = "string, uint64", tag = "1")]
    pub members: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    /// List of installations that failed to be added due to errors encountered during the evaluation process.
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub failed_installations: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for GroupMembership {
    const NAME: &'static str = "GroupMembership";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.GroupMembership".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.GroupMembership".into()
    }
}
/// Parent message for group metadata
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupMetadataV1 {
    #[prost(enumeration = "ConversationType", tag = "1")]
    pub conversation_type: i32,
    /// This will be removed soon
    #[prost(string, tag = "2")]
    pub creator_account_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub creator_inbox_id: ::prost::alloc::string::String,
    /// Should only be present for CONVERSATION_TYPE_DM
    #[prost(message, optional, tag = "4")]
    pub dm_members: ::core::option::Option<DmMembers>,
}
impl ::prost::Name for GroupMetadataV1 {
    const NAME: &'static str = "GroupMetadataV1";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.GroupMetadataV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.GroupMetadataV1".into()
    }
}
/// Wrapper around an Inbox Id
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Inbox {
    #[prost(string, tag = "1")]
    pub inbox_id: ::prost::alloc::string::String,
}
impl ::prost::Name for Inbox {
    const NAME: &'static str = "Inbox";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.Inbox".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.Inbox".into()
    }
}
/// Ordering does not matter here
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DmMembers {
    #[prost(message, optional, tag = "1")]
    pub dm_member_one: ::core::option::Option<Inbox>,
    #[prost(message, optional, tag = "2")]
    pub dm_member_two: ::core::option::Option<Inbox>,
}
impl ::prost::Name for DmMembers {
    const NAME: &'static str = "DmMembers";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.DmMembers".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.DmMembers".into()
    }
}
/// Defines the type of conversation
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConversationType {
    Unspecified = 0,
    Group = 1,
    Dm = 2,
    Sync = 3,
}
impl ConversationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONVERSATION_TYPE_UNSPECIFIED",
            Self::Group => "CONVERSATION_TYPE_GROUP",
            Self::Dm => "CONVERSATION_TYPE_DM",
            Self::Sync => "CONVERSATION_TYPE_SYNC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONVERSATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONVERSATION_TYPE_GROUP" => Some(Self::Group),
            "CONVERSATION_TYPE_DM" => Some(Self::Dm),
            "CONVERSATION_TYPE_SYNC" => Some(Self::Sync),
            _ => None,
        }
    }
}
/// Message for group mutable metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMutableMetadataV1 {
    /// Map to store various metadata attributes (Group name, etc.)
    #[prost(map = "string, string", tag = "1")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "2")]
    pub admin_list: ::core::option::Option<Inboxes>,
    /// Creator starts as only super_admin
    /// Only super_admin can add/remove other super_admin
    #[prost(message, optional, tag = "3")]
    pub super_admin_list: ::core::option::Option<Inboxes>,
    /// The ED25519 private key used to sign commit log entries
    /// Must match the first entry in the commit log to be valid
    #[prost(bytes = "vec", optional, tag = "4")]
    pub commit_log_signer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for GroupMutableMetadataV1 {
    const NAME: &'static str = "GroupMutableMetadataV1";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.GroupMutableMetadataV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.GroupMutableMetadataV1".into()
    }
}
/// Wrapper around a list of repeated Inbox Ids
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Inboxes {
    #[prost(string, repeated, tag = "1")]
    pub inbox_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for Inboxes {
    const NAME: &'static str = "Inboxes";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.Inboxes".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.Inboxes".into()
    }
}
/// Message for group mutable metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMutablePermissionsV1 {
    #[prost(message, optional, tag = "1")]
    pub policies: ::core::option::Option<PolicySet>,
}
impl ::prost::Name for GroupMutablePermissionsV1 {
    const NAME: &'static str = "GroupMutablePermissionsV1";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.GroupMutablePermissionsV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.GroupMutablePermissionsV1".into()
    }
}
/// The set of policies that govern the group
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicySet {
    #[prost(message, optional, tag = "1")]
    pub add_member_policy: ::core::option::Option<MembershipPolicy>,
    #[prost(message, optional, tag = "2")]
    pub remove_member_policy: ::core::option::Option<MembershipPolicy>,
    #[prost(map = "string, message", tag = "3")]
    pub update_metadata_policy: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        MetadataPolicy,
    >,
    #[prost(message, optional, tag = "4")]
    pub add_admin_policy: ::core::option::Option<PermissionsUpdatePolicy>,
    #[prost(message, optional, tag = "5")]
    pub remove_admin_policy: ::core::option::Option<PermissionsUpdatePolicy>,
    #[prost(message, optional, tag = "6")]
    pub update_permissions_policy: ::core::option::Option<PermissionsUpdatePolicy>,
}
impl ::prost::Name for PolicySet {
    const NAME: &'static str = "PolicySet";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.PolicySet".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.PolicySet".into()
    }
}
/// A policy that governs adding/removing members or installations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipPolicy {
    #[prost(oneof = "membership_policy::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<membership_policy::Kind>,
}
/// Nested message and enum types in `MembershipPolicy`.
pub mod membership_policy {
    /// Combine multiple policies. All must evaluate to true
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AndCondition {
        #[prost(message, repeated, tag = "1")]
        pub policies: ::prost::alloc::vec::Vec<super::MembershipPolicy>,
    }
    impl ::prost::Name for AndCondition {
        const NAME: &'static str = "AndCondition";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.MembershipPolicy.AndCondition".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.MembershipPolicy.AndCondition".into()
        }
    }
    /// Combine multiple policies. Any must evaluate to true
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnyCondition {
        #[prost(message, repeated, tag = "1")]
        pub policies: ::prost::alloc::vec::Vec<super::MembershipPolicy>,
    }
    impl ::prost::Name for AnyCondition {
        const NAME: &'static str = "AnyCondition";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.MembershipPolicy.AnyCondition".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.MembershipPolicy.AnyCondition".into()
        }
    }
    /// Base policy
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BasePolicy {
        Unspecified = 0,
        Allow = 1,
        Deny = 2,
        AllowIfAdminOrSuperAdmin = 3,
        AllowIfSuperAdmin = 4,
    }
    impl BasePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BASE_POLICY_UNSPECIFIED",
                Self::Allow => "BASE_POLICY_ALLOW",
                Self::Deny => "BASE_POLICY_DENY",
                Self::AllowIfAdminOrSuperAdmin => {
                    "BASE_POLICY_ALLOW_IF_ADMIN_OR_SUPER_ADMIN"
                }
                Self::AllowIfSuperAdmin => "BASE_POLICY_ALLOW_IF_SUPER_ADMIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BASE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "BASE_POLICY_ALLOW" => Some(Self::Allow),
                "BASE_POLICY_DENY" => Some(Self::Deny),
                "BASE_POLICY_ALLOW_IF_ADMIN_OR_SUPER_ADMIN" => {
                    Some(Self::AllowIfAdminOrSuperAdmin)
                }
                "BASE_POLICY_ALLOW_IF_SUPER_ADMIN" => Some(Self::AllowIfSuperAdmin),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(enumeration = "BasePolicy", tag = "1")]
        Base(i32),
        #[prost(message, tag = "2")]
        AndCondition(AndCondition),
        #[prost(message, tag = "3")]
        AnyCondition(AnyCondition),
    }
}
impl ::prost::Name for MembershipPolicy {
    const NAME: &'static str = "MembershipPolicy";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.MembershipPolicy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.MembershipPolicy".into()
    }
}
/// A policy that governs updating metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataPolicy {
    #[prost(oneof = "metadata_policy::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<metadata_policy::Kind>,
}
/// Nested message and enum types in `MetadataPolicy`.
pub mod metadata_policy {
    /// Combine multiple policies. All must evaluate to true
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AndCondition {
        #[prost(message, repeated, tag = "1")]
        pub policies: ::prost::alloc::vec::Vec<super::MetadataPolicy>,
    }
    impl ::prost::Name for AndCondition {
        const NAME: &'static str = "AndCondition";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.MetadataPolicy.AndCondition".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.MetadataPolicy.AndCondition".into()
        }
    }
    /// Combine multiple policies. Any must evaluate to true
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnyCondition {
        #[prost(message, repeated, tag = "1")]
        pub policies: ::prost::alloc::vec::Vec<super::MetadataPolicy>,
    }
    impl ::prost::Name for AnyCondition {
        const NAME: &'static str = "AnyCondition";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.MetadataPolicy.AnyCondition".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.MetadataPolicy.AnyCondition".into()
        }
    }
    /// Base policy
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetadataBasePolicy {
        Unspecified = 0,
        Allow = 1,
        Deny = 2,
        AllowIfAdmin = 3,
        AllowIfSuperAdmin = 4,
    }
    impl MetadataBasePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METADATA_BASE_POLICY_UNSPECIFIED",
                Self::Allow => "METADATA_BASE_POLICY_ALLOW",
                Self::Deny => "METADATA_BASE_POLICY_DENY",
                Self::AllowIfAdmin => "METADATA_BASE_POLICY_ALLOW_IF_ADMIN",
                Self::AllowIfSuperAdmin => "METADATA_BASE_POLICY_ALLOW_IF_SUPER_ADMIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METADATA_BASE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "METADATA_BASE_POLICY_ALLOW" => Some(Self::Allow),
                "METADATA_BASE_POLICY_DENY" => Some(Self::Deny),
                "METADATA_BASE_POLICY_ALLOW_IF_ADMIN" => Some(Self::AllowIfAdmin),
                "METADATA_BASE_POLICY_ALLOW_IF_SUPER_ADMIN" => {
                    Some(Self::AllowIfSuperAdmin)
                }
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(enumeration = "MetadataBasePolicy", tag = "1")]
        Base(i32),
        #[prost(message, tag = "2")]
        AndCondition(AndCondition),
        #[prost(message, tag = "3")]
        AnyCondition(AnyCondition),
    }
}
impl ::prost::Name for MetadataPolicy {
    const NAME: &'static str = "MetadataPolicy";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.MetadataPolicy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.MetadataPolicy".into()
    }
}
/// A policy that governs updating permissions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionsUpdatePolicy {
    #[prost(oneof = "permissions_update_policy::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<permissions_update_policy::Kind>,
}
/// Nested message and enum types in `PermissionsUpdatePolicy`.
pub mod permissions_update_policy {
    /// Combine multiple policies. All must evaluate to true
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AndCondition {
        #[prost(message, repeated, tag = "1")]
        pub policies: ::prost::alloc::vec::Vec<super::PermissionsUpdatePolicy>,
    }
    impl ::prost::Name for AndCondition {
        const NAME: &'static str = "AndCondition";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.PermissionsUpdatePolicy.AndCondition".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.PermissionsUpdatePolicy.AndCondition".into()
        }
    }
    /// Combine multiple policies. Any must evaluate to true
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnyCondition {
        #[prost(message, repeated, tag = "1")]
        pub policies: ::prost::alloc::vec::Vec<super::PermissionsUpdatePolicy>,
    }
    impl ::prost::Name for AnyCondition {
        const NAME: &'static str = "AnyCondition";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.PermissionsUpdatePolicy.AnyCondition".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.PermissionsUpdatePolicy.AnyCondition".into()
        }
    }
    /// Base policy
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PermissionsBasePolicy {
        Unspecified = 0,
        Deny = 1,
        AllowIfAdmin = 2,
        AllowIfSuperAdmin = 3,
    }
    impl PermissionsBasePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PERMISSIONS_BASE_POLICY_UNSPECIFIED",
                Self::Deny => "PERMISSIONS_BASE_POLICY_DENY",
                Self::AllowIfAdmin => "PERMISSIONS_BASE_POLICY_ALLOW_IF_ADMIN",
                Self::AllowIfSuperAdmin => "PERMISSIONS_BASE_POLICY_ALLOW_IF_SUPER_ADMIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERMISSIONS_BASE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "PERMISSIONS_BASE_POLICY_DENY" => Some(Self::Deny),
                "PERMISSIONS_BASE_POLICY_ALLOW_IF_ADMIN" => Some(Self::AllowIfAdmin),
                "PERMISSIONS_BASE_POLICY_ALLOW_IF_SUPER_ADMIN" => {
                    Some(Self::AllowIfSuperAdmin)
                }
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(enumeration = "PermissionsBasePolicy", tag = "1")]
        Base(i32),
        #[prost(message, tag = "2")]
        AndCondition(AndCondition),
        #[prost(message, tag = "3")]
        AnyCondition(AnyCondition),
    }
}
impl ::prost::Name for PermissionsUpdatePolicy {
    const NAME: &'static str = "PermissionsUpdatePolicy";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.PermissionsUpdatePolicy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.PermissionsUpdatePolicy".into()
    }
}
/// A group member and affected installation IDs
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MembershipChange {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub installation_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, tag = "2")]
    pub account_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub initiated_by_account_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MembershipChange {
    const NAME: &'static str = "MembershipChange";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.MembershipChange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.MembershipChange".into()
    }
}
/// The group membership change proto
///
/// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMembershipChanges {
    /// Members that have been added in the commit
    #[prost(message, repeated, tag = "1")]
    pub members_added: ::prost::alloc::vec::Vec<MembershipChange>,
    /// Members that have been removed in the commit
    #[prost(message, repeated, tag = "2")]
    pub members_removed: ::prost::alloc::vec::Vec<MembershipChange>,
    /// Installations that have been added in the commit, grouped by member
    #[prost(message, repeated, tag = "3")]
    pub installations_added: ::prost::alloc::vec::Vec<MembershipChange>,
    /// Installations removed in the commit, grouped by member
    #[prost(message, repeated, tag = "4")]
    pub installations_removed: ::prost::alloc::vec::Vec<MembershipChange>,
}
impl ::prost::Name for GroupMembershipChanges {
    const NAME: &'static str = "GroupMembershipChanges";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.GroupMembershipChanges".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.GroupMembershipChanges".into()
    }
}
/// A summary of the changes in a commit.
/// Includes added/removed inboxes and changes to metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupUpdated {
    #[prost(string, tag = "1")]
    pub initiated_by_inbox_id: ::prost::alloc::string::String,
    /// The inboxes added in the commit
    #[prost(message, repeated, tag = "2")]
    pub added_inboxes: ::prost::alloc::vec::Vec<group_updated::Inbox>,
    /// The inboxes removed in the commit
    #[prost(message, repeated, tag = "3")]
    pub removed_inboxes: ::prost::alloc::vec::Vec<group_updated::Inbox>,
    /// The metadata changes in the commit
    #[prost(message, repeated, tag = "4")]
    pub metadata_field_changes: ::prost::alloc::vec::Vec<
        group_updated::MetadataFieldChange,
    >,
}
/// Nested message and enum types in `GroupUpdated`.
pub mod group_updated {
    /// An inbox that was added or removed in this commit
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Inbox {
        #[prost(string, tag = "1")]
        pub inbox_id: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Inbox {
        const NAME: &'static str = "Inbox";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.GroupUpdated.Inbox".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.GroupUpdated.Inbox".into()
        }
    }
    /// A summary of a change to the mutable metadata
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MetadataFieldChange {
        /// The field that was changed
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        /// The previous value
        #[prost(string, optional, tag = "2")]
        pub old_value: ::core::option::Option<::prost::alloc::string::String>,
        /// The updated value
        #[prost(string, optional, tag = "3")]
        pub new_value: ::core::option::Option<::prost::alloc::string::String>,
    }
    impl ::prost::Name for MetadataFieldChange {
        const NAME: &'static str = "MetadataFieldChange";
        const PACKAGE: &'static str = "xmtp.mls.message_contents";
        fn full_name() -> ::prost::alloc::string::String {
            "xmtp.mls.message_contents.GroupUpdated.MetadataFieldChange".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/xmtp.mls.message_contents.GroupUpdated.MetadataFieldChange".into()
        }
    }
}
impl ::prost::Name for GroupUpdated {
    const NAME: &'static str = "GroupUpdated";
    const PACKAGE: &'static str = "xmtp.mls.message_contents";
    fn full_name() -> ::prost::alloc::string::String {
        "xmtp.mls.message_contents.GroupUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/xmtp.mls.message_contents.GroupUpdated".into()
    }
}
