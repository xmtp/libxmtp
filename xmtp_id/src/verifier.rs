use ethers::types::{Address, BlockId, Signature};
use ethers::providers::{Http, Middleware, Provider};
use std::convert::TryFrom;
use std::sync::Arc;
use crate::bindings::coinbase_smart_wallet::CoinbaseSmartWallet;
use anyhow::Error;

const BASE_SEPOLIA_RPC_URL: &str = "https://sepolia.base.org";
const EIP1271_MAGIC_VALUE: [u8; 4] = [0x16, 0x26, 0xba, 0x7e];

pub struct ERC1271Verifier {
    pub provider: Arc<Provider<Http>>,
}   

impl ERC1271Verifier {
    pub fn new() -> Self {
        let provider =  Arc::new(Provider::<Http>::try_from(BASE_SEPOLIA_RPC_URL).unwrap());
        Self { provider }
    }
    
    /// Verifies an ERC-1271(https://eips.ethereum.org/EIPS/eip-1271) signature.
    ///
    /// # Arguments
    ///
    /// * `hash` - Hash of the message.
    /// * `signature` - generated by signing **Replay safe hash**.
    /// * `wallet_address` - Address of the ERC1271 wallet.
    /// * `block_id` - Block identifier.
    pub async fn verify_erc1271_signature<M: Middleware>(&self, hash: [u8; 32], owner_index: u64, signature: Signature, wallet_address: Address, block_id: BlockId) -> Result<bool, Error> {
        let wallet = CoinbaseSmartWallet::new(wallet_address, self.provider.clone());

        // Used during signature validation, tie a signature with its signer.
        let signature_wrapper = ethers::abi::encode(&[ethers::abi::Token::Tuple(vec![
            ethers::abi::Token::Uint(ethers::types::U256::from(owner_index)),
            ethers::abi::Token::Bytes(signature.to_vec()),
        ])]);
        
        let res: [u8; 4] = wallet
            .is_valid_signature(hash, ethers::types::Bytes::from(signature_wrapper))
            .block(block_id)
            .call()
            .await?
            .into();

        Ok(res == EIP1271_MAGIC_VALUE)
    }
}