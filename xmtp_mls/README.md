# XMTP MLS

## Database Schema

Foreign key constraints and indexes omitted for simplicity.

```sql
-- Would be a table that only holds a single identity (your own)
CREATE TABLE identities {
    id TEXT PRIMARY KEY NOT NULL, -- The installation_id of the identity
    signature_keypair BLOB NOT NULL,
    "credential" BLOB NOT NULL,
    created_at_ns BIGINT NOT NULL,
    wallet_address TEXT NOT NULL,
}

-- Minimum viable group schema
CREATE TABLE groups {
    id TEXT PRIMARY KEY NOT NULL, -- Random ID generated by group creator
    created_at_ns BIGINT NOT NULL, -- Based on the timestamp of the welcome message
    membership_state INT NOT NULL, -- Enum of the GROUP_MEMBERSHIP_STATE listed below
}

-- Successfully processed messages meant to be returned to the user
CREATE TABLE group_messages {
    id TEXT PRIMARY KEY NOT NULL -- Derived via SHA256(CONCAT(decrypted_message_bytes, conversation_id, timestamp))
    group_id TEXT NOT NULL,
    decrypted_message_bytes BLOB NOT NULL, -- Message contents after decryption
    sent_at_ns BIGINT NOT NULL, -- Based on the timestamp of the message
    sender_installation_id TEXT NOT NULL,
    sender_wallet_address TEXT NOT NULL, -- Could remove this if we added a table mapping installation_ids to wallet addresses
}

-- Used to keep track of the last seen message timestamp in a topic
CREATE TABLE topic_refresh_state {
    topic TEXT PRIMARY KEY NOT NULL,
    last_message_timestamp BIGINT NOT NULL
}

-- This table is required to retry messages that do not send successfully due to epoch conflicts
CREATE TABLE group_intents {
    id SERIAL PRIMARY KEY NOT NULL,
    kind INT NOT NULL, -- INTENT_KIND
    group_id TEXT NOT NULL,
    "data" BLOB NOT NULL, -- Some sort of serializable blob that can be used to re-try the message if the first attempt failed due to conflict
    "state" INT NOT NULL, -- INTENT_STATE,
    message_hash TEXT -- The hash of the encrypted, concrete, form of the message if it was published.
}

CREATE TABLE pending_outbound_welcome_messages {
    id TEXT PRIMARY KEY NOT NULL, -- Derived via SHA256(CONCAT(group_id, welcome_message, ratchet_tree, installation_id))
    installation_id TEXT PRIMARY KEY NOT NULL,
    commit_hash TEXT NOT NULL, -- The hash of the commit which created this
    group_id TEXT NOT NULL,
    welcome_message BLOB NOT NULL,
    ratchet_tree BLOB NOT NULL,
}

-- OpenMLS Keystore backing database to lookup objects. Interface and matching types defined here https://github.com/openmls/openmls/blob/main/traits/src/key_store.rs
CREATE TABLE openmls_keystore {
    "key" TEXT PRIMARY KEY NOT NULL,
    "value" BLOB NOT NULL,
}
```

## Enums

### GROUP_MEMBERSHIP_STATE

- ALLOWED // User has agreed to be a member of the group
- REJECTED // User has rejected an invite to the group or left
- PENDING // User has neither accepted or rejected whether they should join the group

### INTENT_STATE

- TO_SEND // Either has never been sent to the network or needs to be re-sent
- PUBLISHED // Sent to the network but has not been read back or committed
- COMMITTED // Committed messages could be deleted

### INTENT_KIND

- APPLICATION // An intent to send a message to the group
- ADD_MEMBERS // An intent to add members to the group
- REMOVE_MEMBERS // An intent to remove members from the group
- KEY_UPDATE // An intent to update your own group key

## State Machine

The [following diagram](https://app.excalidraw.com/s/4nwb0c8ork7/6pPH1kQDoj3) illustrates some common flows in the state machine

![MLS State Machione](../img/mls-state-machine.png "MLS State Machine")

### Known missing items from the state machine

- Key updates
- Processing incoming welcome messages

### Add members to a group

Simplified high level flow for adding members to a group:

1. Consume Key Packages for all new members
1. Create a `group_intent` for adding the members
1. Sync the state of the group with the network
1. Convert the intent into concrete commit and welcome messages for the current epoch
1. Publish commit message
1. Sync the state of the group with the network
1. If no conflicts: Publish welcome messages to new members.
   If conflicts: Go back to step 4 and try again

### Remove members from a group

Simplified high level flow for removing members from a group:

1. Create a `group_intent` for removing the members
1. Sync the state of the group with the network
1. Convert the intent into concrete commit for the current epoch
1. Publish commit to the network
1. Sync the state of the group with the network
1. If no conflicts: Done.
   If conflicts: Go back to step 3 and try again

### Send a message

Simplified high level flow for sending a group message:

1. Create a `group_intent` for sending the message
1. Convert the intent into a concrete message for the current epoch
1. Publish message to the network
1. Sync the state of the group with the network (can be debounced or otherwise only done periodically)
1. If no conflicts: Mark the message as committed. If conflicts: Go back to step 2.

### Updating your list of conversations

1. Read from the welcome topic for your `installation_id`, filtering for messages since `last_message_timestamp`
1. For each message, create a group with a `GROUP_MEMBERSHIP_STATE` of pending
