# XMTP MLS

## Database Schema

Foreign key constraints and indexes omitted for simplicity.

```sql
CREATE TABLE groups (
    -- Random ID generated by group creator
    "id" BLOB PRIMARY KEY NOT NULL,
    -- Based on the timestamp of the welcome message
    "created_at_ns" BIGINT NOT NULL,
    -- Enum of GROUP_MEMBERSHIP_STATE
    "membership_state" INT NOT NULL
);

-- Allow for efficient sorting of groups
CREATE INDEX groups_created_at_idx ON groups(created_at_ns);

CREATE INDEX groups_membership_state ON groups(membership_state);

-- Successfully processed messages meant to be returned to the user
CREATE TABLE group_messages (
    "id" BLOB PRIMARY KEY NOT NULL,
    -- Derived via SHA256(CONCAT(decrypted_message_bytes, conversation_id, timestamp))
    "group_id" BLOB NOT NULL,
    -- Message contents after decryption
    "decrypted_message_bytes" BLOB NOT NULL,
    -- Based on the timestamp of the message
    "sent_at_ns" BIGINT NOT NULL,
    -- Enum GROUP_MESSAGE_KIND
    "kind" INT NOT NULL,
    -- Could remove this if we added a table mapping installation_ids to wallet addresses
    "sender_installation_id" BLOB NOT NULL,
    "sender_wallet_address" TEXT NOT NULL,
    FOREIGN KEY (group_id) REFERENCES groups(id)
);

CREATE INDEX group_messages_group_id_sort_idx ON group_messages(group_id, sent_at_ns);

-- Used to keep track of the last seen message timestamp in a topic
CREATE TABLE topic_refresh_state (
    "topic" TEXT PRIMARY KEY NOT NULL,
    "last_message_timestamp_ns" BIGINT NOT NULL
);

-- This table is required to retry messages that do not send successfully due to epoch conflicts
CREATE TABLE group_intents (
    -- Serial ID auto-generated by the DB
    "id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    -- Enum INTENT_KIND
    "kind" INT NOT NULL,
    "group_id" BLOB NOT NULL,
    -- Some sort of serializable blob that can be used to re-try the message if the first attempt failed due to conflict
    "publish_data" BLOB NOT NULL,
    -- Data needed after applying a commit, such as welcome messages
    "post_commit_data" BLOB NOT NULL,
    -- INTENT_STATE,
    "state" INT NOT NULL,
    -- The hash of the encrypted, concrete, form of the message if it was published.
    "message_hash" BLOB,
    FOREIGN KEY (group_id) REFERENCES groups(id)
);

CREATE INDEX group_intents_group_id_id ON group_intents(group_id, id);

CREATE TABLE topic_refresh_state (
    "topic" TEXT PRIMARY KEY NOT NULL,
    "last_message_timestamp_ns" BIGINT NOT NULL,
    -- Only allow one concurrent sync at a time per topic. This value is 0 when no sync is happening
    -- All locks should be cleared on cold start
    "lock_until_ns" BIGINT NOT NULL
);
```

## Enums

### GROUP_MEMBERSHIP_STATE

- ALLOWED // User has agreed to be a member of the group
- REJECTED // User has rejected an invite to the group or left
- PENDING // User has neither accepted or rejected whether they should join the group

### INTENT_STATE

- TO_SEND // Either has never been sent to the network or needs to be re-sent
- PUBLISHED // Sent to the network but has not been read back or committed
- COMMITTED // Committed messages could be deleted

### INTENT_KIND

- SEND_MESSAGE // An intent to send a message to the group
- ADD_MEMBERS // An intent to add members to the group
- REMOVE_MEMBERS // An intent to remove members from the group
- KEY_UPDATE // An intent to update your own group key

### OUTBOUND_WELCOME_STATE

- PENDING // Needs to wait for commit to be applied before sending
- READY_TO_SEND
- SENT // Messages may be deleted at this point. We may decide to remove this state altogether.

### GROUP_MESSAGE_KIND

- APPLICATION
- MEMBER_ADDED
- MEMBER_REMOVED

## State Machine

The [following diagram](https://app.excalidraw.com/s/4nwb0c8ork7/6pPH1kQDoj3) illustrates some common flows in the state machine

![MLS State Machine](../img/mls-state-machine.png "MLS State Machine")

### Known missing items from the state machine

- Key updates
- Processing incoming welcome messages
- Tracking group membership at the account/user level
- Permissioning for adding/removing accounts/users
- Mechanism for syncing installations under each account/user

### Add members to a group

Simplified high level flow for adding members to a group:

1. Create a `group_intent` for adding the members
1. Consume Key Packages for all new members
1. Convert the intent (and any pending proposals) into concrete commit and welcome messages for the current epoch
   1. Write the welcome messages to the `post_commit_data` field for later
1. Publish commit message
1. Sync the state of the group with the network
1. If no conflicts: Publish welcome messages to new members.
   If conflicts: Go back to step 2 and try again (reset the intent's state to `TO_SEND` and clear the `data` and `post_commit_data` fields)

### Remove members from a group

Simplified high level flow for removing members from a group:

1. Create a `group_intent` for removing the members
1. Convert the intent (and any pending proposals) into concrete commit for the current epoch
   1. If there are welcome messages, write them to the `post_commit_data` field for later
1. Publish commit to the network
1. Sync the state of the group with the network
1. If no conflicts: Done. If there are welcome messages in the `post_commit_data` field, publish them.
   If conflicts: Go back to step 2 and try again (reset the intent's state to `TO_SEND` and clear the `data` and `post_commit_data` fields)

### Send a message

Simplified high level flow for sending a group message:

1. Create a `group_intent` for sending the message
1. Commit any pending proposals
   1. If there are welcome messages, write them to the `post_commit_data` field for later
1. Convert the intent into a concrete message for the current epoch
1. Publish message to the network
1. Sync the state of the group with the network (can be debounced or otherwise only done periodically)
1. If no conflicts: Mark the message as committed. If there are welcome messages in the `post_commit_data` field, publish them.
   If conflicts: Go back to step 2 and try again (reset the intent's state to `TO_SEND` and clear the `data` and `post_commit_data` fields)

### Syncing group state

The server maintains an inbound topic for each group, and a single inbound topic for the client's identity. For each topic, the client maintains a row that stores `last_synced_payload_id` and `lock_sync_until_ns` fields.

1. In a single transaction, validate that `lock_until_ns` is not set to a value greater than `now()`, set it to a timeframe in the future, and fetch the `last_message_timestamp_ns`
1. Fetch all payloads greater than the timestamp from the server
1. Sequentially process each payload. For each payload, update the `last_message_timestamp_ns` and any corresponding database writes for that payload in a single transaction
1. When the sync is complete, release the lock by setting `lock_until_ns` to 0

This flow will be similar regardless of if the sync happens via a poll-based or subscription-based mechanism. For a subscription-based mechanism, the lock will be obtained at the start of the subscription, and extended on a heartbeat time interval, until the subscription is closed.

### Updating your list of conversations

1. Read from the welcome topic for your `installation_id`, filtering for messages since `last_message_timestamp`
1. For each message, create a group with a `GROUP_MEMBERSHIP_STATE` of pending
