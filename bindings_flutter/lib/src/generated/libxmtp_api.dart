// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.22.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'libxmtp_api.freezed.dart';

Future<String> generatePrivatePreferencesTopicIdentifier(
        {required List<int> privateKeyBytes, dynamic hint}) =>
    RustLib.instance.api.generatePrivatePreferencesTopicIdentifier(
        privateKeyBytes: privateKeyBytes, hint: hint);

Future<Uint8List> userPreferencesEncrypt(
        {required List<int> publicKey,
        required List<int> privateKey,
        required List<int> message,
        dynamic hint}) =>
    RustLib.instance.api.userPreferencesEncrypt(
        publicKey: publicKey,
        privateKey: privateKey,
        message: message,
        hint: hint);

Future<Uint8List> userPreferencesDecrypt(
        {required List<int> publicKey,
        required List<int> privateKey,
        required List<int> encryptedMessage,
        dynamic hint}) =>
    RustLib.instance.api.userPreferencesDecrypt(
        publicKey: publicKey,
        privateKey: privateKey,
        encryptedMessage: encryptedMessage,
        hint: hint);

Future<CreatedClient> createClient(
        {required String host,
        required bool isSecure,
        required String dbPath,
        required U8Array32 encryptionKey,
        required String accountAddress,
        dynamic hint}) =>
    RustLib.instance.api.createClient(
        host: host,
        isSecure: isSecure,
        dbPath: dbPath,
        encryptionKey: encryptionKey,
        accountAddress: accountAddress,
        hint: hint);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<ApiError>>
@sealed
class ApiError extends RustOpaque {
  ApiError.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  ApiError.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ApiError,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ApiError,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ApiErrorPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<Arc < XmtpClient >>>
@sealed
class ArcXmtpClient extends RustOpaque {
  ArcXmtpClient.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ArcXmtpClient.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcXmtpClient,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcXmtpClient,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcXmtpClientPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<Client>>
@sealed
class Client extends RustOpaque {
  Client.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Client.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Client,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Client,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ClientPtr,
  );

  Future<void> addMember(
          {required List<int> groupId,
          required String accountAddress,
          dynamic hint}) =>
      RustLib.instance.api.clientAddMember(
        that: this,
        groupId: groupId,
        accountAddress: accountAddress,
      );

  Future<Group> createGroup(
          {required List<String> accountAddresses, dynamic hint}) =>
      RustLib.instance.api.clientCreateGroup(
        that: this,
        accountAddresses: accountAddresses,
      );

  Future<Uint8List> installationPublicKey({dynamic hint}) =>
      RustLib.instance.api.clientInstallationPublicKey(
        that: this,
      );

  Future<List<Group>> listGroups(
          {int? createdAfterNs,
          int? createdBeforeNs,
          int? limit,
          dynamic hint}) =>
      RustLib.instance.api.clientListGroups(
        that: this,
        createdAfterNs: createdAfterNs,
        createdBeforeNs: createdBeforeNs,
        limit: limit,
      );

  Future<List<GroupMember>> listMembers(
          {required List<int> groupId, dynamic hint}) =>
      RustLib.instance.api.clientListMembers(
        that: this,
        groupId: groupId,
      );

  Future<List<Message>> listMessages(
          {required List<int> groupId,
          int? sentBeforeNs,
          int? sentAfterNs,
          int? limit,
          dynamic hint}) =>
      RustLib.instance.api.clientListMessages(
        that: this,
        groupId: groupId,
        sentBeforeNs: sentBeforeNs,
        sentAfterNs: sentAfterNs,
        limit: limit,
      );

  Future<void> removeMember(
          {required List<int> groupId,
          required String accountAddress,
          dynamic hint}) =>
      RustLib.instance.api.clientRemoveMember(
        that: this,
        groupId: groupId,
        accountAddress: accountAddress,
      );

  Future<void> sendMessage(
          {required List<int> groupId,
          required List<int> contentBytes,
          dynamic hint}) =>
      RustLib.instance.api.clientSendMessage(
        that: this,
        groupId: groupId,
        contentBytes: contentBytes,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<ClientBuilderError>>
@sealed
class ClientBuilderError extends RustOpaque {
  ClientBuilderError.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ClientBuilderError.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ClientBuilderError,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ClientBuilderError,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ClientBuilderErrorPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<StorageError>>
@sealed
class StorageError extends RustOpaque {
  StorageError.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  StorageError.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_StorageError,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_StorageError,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_StorageErrorPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<anyhow :: Error>>
@sealed
class AnyhowError extends RustOpaque {
  AnyhowError.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AnyhowError.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AnyhowError,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AnyhowError,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AnyhowErrorPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<xmtp_mls :: client :: ClientError>>
@sealed
class XmtpMlsClientClientError extends RustOpaque {
  XmtpMlsClientClientError.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  XmtpMlsClientClientError.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_XmtpMlsClientClientError,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_XmtpMlsClientClientError,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_XmtpMlsClientClientErrorPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<xmtp_mls :: groups :: GroupError>>
@sealed
class XmtpMlsGroupsGroupError extends RustOpaque {
  XmtpMlsGroupsGroupError.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  XmtpMlsGroupsGroupError.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_XmtpMlsGroupsGroupError,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_XmtpMlsGroupsGroupError,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_XmtpMlsGroupsGroupErrorPtr,
  );
}

@freezed
sealed class CreatedClient with _$CreatedClient {
  const factory CreatedClient.ready(
    Client field0,
  ) = CreatedClient_Ready;
  const factory CreatedClient.requiresSignature(
    SignatureRequiredClient field0,
  ) = CreatedClient_RequiresSignature;
}

class Group {
  final Uint8List groupId;
  final int createdAtNs;

  const Group({
    required this.groupId,
    required this.createdAtNs,
  });

  @override
  int get hashCode => groupId.hashCode ^ createdAtNs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Group &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          createdAtNs == other.createdAtNs;
}

class GroupMember {
  final String accountAddress;
  final List<Uint8List> installationIds;

  const GroupMember({
    required this.accountAddress,
    required this.installationIds,
  });

  @override
  int get hashCode => accountAddress.hashCode ^ installationIds.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupMember &&
          runtimeType == other.runtimeType &&
          accountAddress == other.accountAddress &&
          installationIds == other.installationIds;
}

class Message {
  final Uint8List id;
  final int sentAtNs;
  final Uint8List groupId;
  final String senderAccountAddress;
  final Uint8List contentBytes;

  const Message({
    required this.id,
    required this.sentAtNs,
    required this.groupId,
    required this.senderAccountAddress,
    required this.contentBytes,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      sentAtNs.hashCode ^
      groupId.hashCode ^
      senderAccountAddress.hashCode ^
      contentBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Message &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          sentAtNs == other.sentAtNs &&
          groupId == other.groupId &&
          senderAccountAddress == other.senderAccountAddress &&
          contentBytes == other.contentBytes;
}

class SignatureRequiredClient {
  final String textToSign;
  final ArcXmtpClient inner;

  const SignatureRequiredClient({
    required this.textToSign,
    required this.inner,
  });

  Future<Client> sign({required List<int> signature, dynamic hint}) =>
      RustLib.instance.api.signatureRequiredClientSign(
        that: this,
        signature: signature,
      );

  @override
  int get hashCode => textToSign.hashCode ^ inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignatureRequiredClient &&
          runtimeType == other.runtimeType &&
          textToSign == other.textToSign &&
          inner == other.inner;
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

@freezed
sealed class XmtpError with _$XmtpError implements FrbException {
  const factory XmtpError.apiError(
    ApiError field0,
  ) = XmtpError_ApiError;
  const factory XmtpError.clientBuilderError(
    ClientBuilderError field0,
  ) = XmtpError_ClientBuilderError;
  const factory XmtpError.clientError(
    XmtpMlsClientClientError field0,
  ) = XmtpError_ClientError;
  const factory XmtpError.groupError(
    XmtpMlsGroupsGroupError field0,
  ) = XmtpError_GroupError;
  const factory XmtpError.storageError(
    StorageError field0,
  ) = XmtpError_StorageError;
  const factory XmtpError.generic(
    AnyhowError field0,
  ) = XmtpError_Generic;
}
