name: iOS Integration Tests

on:
  push:
    branches: [main]
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GPR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GPR_USER: ${{ secrets.GITHUB_ACTOR }}

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Fly Registry
        uses: docker/login-action@v3
        with:
          registry: registry.fly.io
          username: x
          password: ${{ secrets.FLY_API_TOKEN }}

      - name: Build and push
        id: build
        run: |
          # Use a persistent app just for hosting the registry image
          IMAGE="registry.fly.io/xmtp-ios-ci:${{ github.run_id }}-${{ github.run_attempt }}"
          docker build -t "$IMAGE" -f ci/fly/Dockerfile ci/fly/
          docker push "$IMAGE"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"

  deploy-backend:
    runs-on: ubuntu-latest
    needs: build-and-push-image
    outputs:
      node_url: ${{ steps.deploy.outputs.node_url }}
      history_url: ${{ steps.deploy.outputs.history_url }}
    steps:
      - uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Deploy ephemeral machine
        id: deploy
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          # Run ephemeral machine - creates temp app that auto-destroys with machine
          # The --rm flag + no app specified = fully ephemeral
          OUTPUT=$(flyctl machine run "${{ needs.build-and-push-image.outputs.image }}" \
            --org xmtp-labs \
            --region sjc \
            --rm \
            --restart no \
            --vm-size shared-cpu-4x \
            --vm-memory 4096 \
            --env MAX_LIFETIME_SECONDS=3600 \
            --port 443:5556/tcp:tls:http \
            --port 5558:5558/tcp:tls:http \
            --json)

          echo "Machine output: $OUTPUT"

          # Extract app name from output
          APP_NAME=$(echo "$OUTPUT" | jq -r '.app // .name // empty' | head -1)
          if [ -z "$APP_NAME" ]; then
            # Fallback: parse from machine info
            MACHINE_ID=$(echo "$OUTPUT" | jq -r '.id')
            APP_NAME=$(flyctl machine status "$MACHINE_ID" --json | jq -r '.app')
          fi

          echo "App name: $APP_NAME"
          echo "node_url=https://${APP_NAME}.fly.dev" >> "$GITHUB_OUTPUT"
          echo "history_url=https://${APP_NAME}.fly.dev:5558" >> "$GITHUB_OUTPUT"

      - name: Wait for services to be ready
        run: |
          NODE_URL="${{ steps.deploy.outputs.node_url }}"
          echo "Waiting for services at ${NODE_URL}..."

          for i in {1..60}; do
            # Try to connect - the service might return an error but that's OK
            # We just need to verify TLS handshake works
            if curl -sf --max-time 10 "${NODE_URL}" > /dev/null 2>&1 || \
               curl -sf --max-time 10 -o /dev/null -w '%{http_code}' "${NODE_URL}" 2>&1 | grep -qE '^[2-5]'; then
              echo "Services are ready!"
              exit 0
            fi
            echo "Waiting... (attempt $i/60)"
            sleep 5
          done

          echo "Services failed to become ready"
          exit 1

  tests:
    runs-on: warp-macos-15-arm64-6x
    needs: deploy-backend
    steps:
      - uses: actions/checkout@v4

      - uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.0"

      - name: Build everything
        run: swift build --build-tests -q

      - name: Run iOS tests
        env:
          XMTP_NODE_ADDRESS: ${{ needs.deploy-backend.outputs.node_url }}
          XMTP_HISTORY_SERVER_ADDRESS: ${{ needs.deploy-backend.outputs.history_url }}
        run: |
          echo "Node URL: $XMTP_NODE_ADDRESS"
          echo "History URL: $XMTP_HISTORY_SERVER_ADDRESS"
          ./script/run_tests.sh

  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy-backend, tests]
    if: always()
    steps:
      - uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop machine (triggers auto-destroy via --rm)
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          # The temp app name is derived from the URL
          NODE_URL="${{ needs.deploy-backend.outputs.node_url }}"
          if [ -n "$NODE_URL" ]; then
            APP_NAME=$(echo "$NODE_URL" | sed 's|https://||' | sed 's|\.fly\.dev.*||')
            echo "Stopping machine in app: $APP_NAME"
            # Stop all machines - this triggers the --rm auto-destroy
            flyctl machine stop --app "$APP_NAME" --select || true
            # Give it a moment to clean up
            sleep 5
            # Force destroy if still exists
            flyctl apps destroy "$APP_NAME" --yes 2>/dev/null || true
          fi
          echo "Cleanup complete (timeout provides fallback if this fails)"
