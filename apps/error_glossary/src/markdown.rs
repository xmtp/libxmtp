use crate::model::{CrateInfo, ErrorTypeKind};

/// Render the full glossary as a markdown string.
pub fn render(crates: &[CrateInfo]) -> String {
    let mut md = String::with_capacity(64 * 1024);

    // Header
    md.push_str("<!-- This file is auto-generated by error_glossary. Do not edit manually. -->\n\n");
    md.push_str("# XMTP error code glossary\n\n");
    md.push_str(
        "This document lists all error codes defined in LibXMTP, \
         the core library underlying the XMTP SDKs. \
         Each error code is a unique identifier returned to help diagnose issues.\n\n",
    );

    let total_types: usize = crates.iter().map(|c| c.error_types.len()).sum();
    let total_variants: usize = crates
        .iter()
        .flat_map(|c| &c.error_types)
        .flat_map(|t| &t.variants)
        .filter(|v| !v.inherit)
        .count();

    md.push_str(&format!(
        "**{} error types** across **{} crates** with **{} total error codes**.\n\n",
        total_types,
        crates.len(),
        total_variants
    ));

    // Body
    for c in crates {
        md.push_str(&format!("## {}\n\n", c.name));

        for t in &c.error_types {
            let kind_label = match t.kind {
                ErrorTypeKind::Enum => "enum",
                ErrorTypeKind::Struct => "struct",
            };
            // Use a combined anchor: crate-typename
            md.push_str(&format!("### {} <sub>{}</sub>\n\n", t.name, kind_label));
            md.push_str(&format!(
                "<small>`{}`</small>\n\n",
                t.source_file,
            ));

            if let Some(ref doc) = t.doc_comment {
                md.push_str(doc);
                md.push_str("\n\n");
            }

            if t.variants.is_empty() {
                continue;
            }

            // For structs, there's only a single "variant" representing the struct itself
            if matches!(t.kind, ErrorTypeKind::Struct) {
                let v = &t.variants[0];
                md.push_str(&format!("**Error code:** `{}`\n\n", v.error_code));
                continue;
            }

            // For enums, render each variant
            md.push_str("| Error Code | Description |\n");
            md.push_str("|:-----------|:------------|\n");

            for v in &t.variants {
                // Skip inherited variants â€” SDK consumers never see these codes
                if v.inherit {
                    continue;
                }

                let desc = if let Some(ref doc) = v.doc_comment {
                    flatten_doc(doc)
                } else {
                    String::new()
                };

                md.push_str(&format!(
                    "| `{}` | {} |\n",
                    v.error_code,
                    escape_pipes(&desc),
                ));
            }
            md.push('\n');
        }
    }

    md
}

/// Flatten a multi-line doc comment into a single line for table display.
fn flatten_doc(doc: &str) -> String {
    doc.lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .collect::<Vec<_>>()
        .join(" ")
}

/// Escape pipe characters for markdown tables.
fn escape_pipes(s: &str) -> String {
    s.replace('|', "\\|")
}
