#!/bin/bash
# Annotate generated Swift files so DocC hides proto/FFI internals.
# Runs in CI before DocC generation — does NOT modify committed files.
# Requires: Perl (standard on macOS, used for multiline regex transforms)
SETUP_FILE="$(dirname "$0")/.setup"
[[ -f "$SETUP_FILE" ]] || { echo "Error: .setup file not found at $SETUP_FILE" >&2; exit 1; }
source "$SETUP_FILE" || { echo "Error: failed to source .setup" >&2; exit 1; }
[[ -n "${IOS_SDK_DIR}" ]] || { echo "Error: IOS_SDK_DIR not set in .setup" >&2; exit 1; }

PROTO_DIR="${IOS_SDK_DIR}/Sources/XMTPiOS/Proto"
PUSH_DIR="${IOS_SDK_DIR}/Sources/XMTPiOS/Push"
FFI_FILE="${IOS_SDK_DIR}/Sources/XMTPiOS/Libxmtp/xmtpv3.swift"

[[ -f "$FFI_FILE" ]] || { echo "Error: FFI file not found at $FFI_FILE — was the bindings build step run first?" >&2; exit 1; }

# ── Proto files ──────────────────────────────────────────────────
# Annotate every public struct/enum except whitelisted types that
# the SDK re-exports via typealiases.

SCRIPT_DIR="$(dirname "$0")"
PROTO_WHITELIST=$(grep -v '^#' "$SCRIPT_DIR/docc-proto-whitelist.txt" | grep -v '^$' | paste -sd'|' -)
FFI_WHITELIST=$(grep -v '^#' "$SCRIPT_DIR/docc-ffi-whitelist.txt" | grep -v '^$' | paste -sd'|' -)

proto_files=(
    "${PROTO_DIR}"/*.pb.swift
    "${PUSH_DIR}/service.pb.swift"
    "${PUSH_DIR}/service.connect.swift"
)

found=0
for f in "${proto_files[@]}"; do
    if [[ ! -f "$f" ]]; then
        echo "Warning: expected proto file not found: $f" >&2
        continue
    fi
    found=$((found + 1))
    perl -i -0777 -pe '
        my $wl = qr/'"${PROTO_WHITELIST}"'/;
        s{
            (?<!\#endif\n)^(public \s+ (?:struct|enum|protocol|final\s+class) \s+ (\S+) [^\n]*)
        }{
            my ($line, $name) = ($1, $2);
            if ($name =~ /^(?:$wl)\b/) {
                $line;
            } else {
                "#if swift(>=5.8)\n\@_documentation(visibility: internal)\n#endif\n$line";
            }
        }xmge;
    ' "$f"
done

if [[ $found -eq 0 ]]; then
    echo "Error: no proto files found — was the build step run first?" >&2
    exit 1
fi
echo "Annotated $found proto/push files"

# ── FFI file (xmtpv3.swift) ─────────────────────────────────────
# Annotate public protocols, open classes, public structs (non-Converter),
# public enums, and public top-level funcs. Use visibility: private to
# match existing uniffi convention. Skip already-annotated lines,
# FfiConverterType* structs, and whitelisted types.

perl -i -ne '
    BEGIN {
        @buf = ();
        $wl = qr/'"${FFI_WHITELIST}"'/;
    }

    # Track last 3 lines for already-annotated check
    push @buf, $_;
    shift @buf if @buf > 4;  # keep current + 3 preceding

    my $need_annotate = 0;
    my $name;

    if (/^public\s+protocol\s+(\S+)/)    { $name = $1; $need_annotate = 1; }
    elsif (/^open\s+class\s+(\S+)/)       { $name = $1; $need_annotate = 1; }
    elsif (/^public\s+struct\s+(\S+)/)    { $name = $1; $need_annotate = 1; }
    elsif (/^public\s+enum\s+(\S+)/)      { $name = $1; $need_annotate = 1; }
    elsif (/^public\s+func\s+([a-z]\S*)/) { $name = $1; $need_annotate = 1; }

    if ($need_annotate) {
        # Skip whitelisted types
        if (defined $name && $name =~ /^(?:$wl)\b/) {
            print;
            next;
        }
        # Skip FfiConverterType* structs (already annotated by uniffi)
        if (defined $name && $name =~ /^FfiConverterType/) {
            print;
            next;
        }
        # Skip if already annotated (check preceding lines for @_documentation)
        my $already = 0;
        for my $i (0 .. $#buf - 1) {
            if ($buf[$i] =~ /\@_documentation\(visibility:/) {
                $already = 1;
                last;
            }
        }
        if ($already) {
            print;
            next;
        }
        # Insert annotation
        print "#if swift(>=5.8)\n";
        print "\@_documentation(visibility: private)\n";
        print "#endif\n";
    }

    print;
' "$FFI_FILE"

echo "Annotated FFI file: $FFI_FILE"
