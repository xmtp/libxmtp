// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mls/api/v1/mls.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Message API

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Sort direction for queries
public enum Xmtp_Mls_Api_V1_SortDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case ascending // = 1
  case descending // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ascending
    case 2: self = .descending
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ascending: return 1
    case .descending: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xmtp_Mls_Api_V1_SortDirection] = [
    .unspecified,
    .ascending,
    .descending,
  ]

}

/// Full representation of a welcome message
public struct Xmtp_Mls_Api_V1_WelcomeMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_WelcomeMessage.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_WelcomeMessage.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessage.V1()
    }
    set {version = .v1(newValue)}
  }

  public var welcomePointer: Xmtp_Mls_Api_V1_WelcomeMessage.WelcomePointer {
    get {
      if case .welcomePointer(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessage.WelcomePointer()
    }
    set {version = .welcomePointer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable, Sendable {
    case v1(Xmtp_Mls_Api_V1_WelcomeMessage.V1)
    case welcomePointer(Xmtp_Mls_Api_V1_WelcomeMessage.WelcomePointer)

  }

  /// Version 1 of the WelcomeMessage format
  public struct V1: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: UInt64 = 0

    public var createdNs: UInt64 = 0

    public var installationKey: Data = Data()

    public var data: Data = Data()

    public var hpkePublicKey: Data = Data()

    public var wrapperAlgorithm: Xmtp_Mls_MessageContents_WelcomeWrapperAlgorithm = .unspecified

    public var welcomeMetadata: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WelcomePointer: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: UInt64 = 0

    public var createdNs: UInt64 = 0

    /// The topic of the welcome message (generally the installation id)
    public var installationKey: Data = Data()

    /// A WelcomePointer encrypted using the algorithm specified by
    /// wrapper_algorithm
    public var welcomePointer: Data = Data()

    /// The public key used to encrypt the welcome pointer
    public var hpkePublicKey: Data = Data()

    /// The algorithm used to encrypt the welcome pointer
    public var wrapperAlgorithm: Xmtp_Mls_MessageContents_WelcomePointerWrapperAlgorithm = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Input type for a welcome message
public struct Xmtp_Mls_Api_V1_WelcomeMessageInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_WelcomeMessageInput.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessageInput.V1()
    }
    set {version = .v1(newValue)}
  }

  public var welcomePointer: Xmtp_Mls_Api_V1_WelcomeMessageInput.WelcomePointer {
    get {
      if case .welcomePointer(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessageInput.WelcomePointer()
    }
    set {version = .welcomePointer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable, Sendable {
    case v1(Xmtp_Mls_Api_V1_WelcomeMessageInput.V1)
    case welcomePointer(Xmtp_Mls_Api_V1_WelcomeMessageInput.WelcomePointer)

  }

  /// Version 1 of the WelcomeMessageInput format, if used as the pointee of a
  /// WelcomePointer then the hpke_public_key will be unset, and the
  /// wrapper_algorithm will be WELCOME_WRAPPER_ALGORITHM_SYMMETRIC_KEY
  public struct V1: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The topic of the welcome message (generally the installation id)
    public var installationKey: Data = Data()

    /// An encrypted mls `Welcome` struct
    public var data: Data = Data()

    /// The public key of the welcome message
    public var hpkePublicKey: Data = Data()

    /// The algorithm used to encrypt the welcome message
    public var wrapperAlgorithm: Xmtp_Mls_MessageContents_WelcomeWrapperAlgorithm = .unspecified

    /// The metadata of the welcome message
    public var welcomeMetadata: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Version 2 of the WelcomeMessageInput format which uses a WelcomePointer
  /// to point to the welcome message for several installations at once
  public struct WelcomePointer: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The topic of the welcome message (generally the installation id)
    public var installationKey: Data = Data()

    /// A WelcomePointer encrypted using the wrapper_algorithm
    public var welcomePointer: Data = Data()

    /// The public key used to encrypt the welcome pointer
    public var hpkePublicKey: Data = Data()

    /// The algorithm used to encrypt the welcome pointer
    public var wrapperAlgorithm: Xmtp_Mls_MessageContents_WelcomePointerWrapperAlgorithm = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// This field is encrypted along with the `data` field on the welcome message.
public struct Xmtp_Mls_Api_V1_WelcomeMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageCursor: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Full representation of a group message
public struct Xmtp_Mls_Api_V1_GroupMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_GroupMessage.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_GroupMessage.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_GroupMessage.V1()
    }
    set {version = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable, Sendable {
    case v1(Xmtp_Mls_Api_V1_GroupMessage.V1)

  }

  /// Version 1 of the GroupMessage format
  public struct V1: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: UInt64 = 0

    public var createdNs: UInt64 = 0

    public var groupID: Data = Data()

    public var data: Data = Data()

    public var senderHmac: Data = Data()

    public var shouldPush: Bool = false

    public var isCommit: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Input type for a group message
public struct Xmtp_Mls_Api_V1_GroupMessageInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_GroupMessageInput.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_GroupMessageInput.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_GroupMessageInput.V1()
    }
    set {version = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable, Sendable {
    case v1(Xmtp_Mls_Api_V1_GroupMessageInput.V1)

  }

  /// Version 1 of the GroupMessageInput payload format
  public struct V1: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Serialized MlsProtocolMessage
    public var data: Data = Data()

    public var senderHmac: Data = Data()

    public var shouldPush: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Send a batch of MLS messages
public struct Xmtp_Mls_Api_V1_SendGroupMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_GroupMessageInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a batch of welcome messages
public struct Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_WelcomeMessageInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A wrapper around the Key Package bytes
public struct Xmtp_Mls_Api_V1_KeyPackageUpload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner's wallet address would be extracted from the identity
  /// credential in the key package, and all signatures would be validated.
  public var keyPackageTlsSerialized: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Register a new installation
public struct Xmtp_Mls_Api_V1_RegisterInstallationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Key Package contains all information needed to register an installation
  public var keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload {
    get {return _keyPackage ?? Xmtp_Mls_Api_V1_KeyPackageUpload()}
    set {_keyPackage = newValue}
  }
  /// Returns true if `keyPackage` has been explicitly set.
  public var hasKeyPackage: Bool {return self._keyPackage != nil}
  /// Clears the value of `keyPackage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyPackage() {self._keyPackage = nil}

  public var isInboxIDCredential: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload? = nil
}

/// The response to a RegisterInstallationRequest
public struct Xmtp_Mls_Api_V1_RegisterInstallationResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Upload a new key packages
public struct Xmtp_Mls_Api_V1_UploadKeyPackageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An individual key package upload request
  public var keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload {
    get {return _keyPackage ?? Xmtp_Mls_Api_V1_KeyPackageUpload()}
    set {_keyPackage = newValue}
  }
  /// Returns true if `keyPackage` has been explicitly set.
  public var hasKeyPackage: Bool {return self._keyPackage != nil}
  /// Clears the value of `keyPackage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyPackage() {self._keyPackage = nil}

  public var isInboxIDCredential: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload? = nil
}

/// Fetch one or more key packages
public struct Xmtp_Mls_Api_V1_FetchKeyPackagesRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The caller can provide an array of installation keys, and the API
  /// will return one key package for each installation associated with each
  /// installation key
  public var installationKeys: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response to a FetchKeyPackagesRequest
public struct Xmtp_Mls_Api_V1_FetchKeyPackagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Returns one key package per installation in the original order of the
  /// request. If any installations are missing key packages, an empty entry is
  /// left in their respective spots in the array.
  public var keyPackages: [Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An individual key package
  public struct KeyPackage: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var keyPackageTlsSerialized: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Revoke an installation
public struct Xmtp_Mls_Api_V1_RevokeInstallationRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationKey: Data = Data()

  /// All revocations must be validated with a wallet signature over the
  /// installation_id being revoked (and some sort of standard prologue)
  public var walletSignature: Xmtp_MessageContents_Signature {
    get {return _walletSignature ?? Xmtp_MessageContents_Signature()}
    set {_walletSignature = newValue}
  }
  /// Returns true if `walletSignature` has been explicitly set.
  public var hasWalletSignature: Bool {return self._walletSignature != nil}
  /// Clears the value of `walletSignature`. Subsequent reads from it will return its default value.
  public mutating func clearWalletSignature() {self._walletSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _walletSignature: Xmtp_MessageContents_Signature? = nil
}

/// Get all updates for an identity since the specified time
public struct Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountAddresses: [String] = []

  public var startTimeNs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to get any new or revoked installations for a list of wallet addresses
public struct Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of updates (or empty objects if no changes) in the original order
  /// of the request
  public var updates: [Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A new installation key was seen for the first time by the nodes
  public struct NewInstallationUpdate: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationKey: Data = Data()

    public var credentialIdentity: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// An installation was revoked
  public struct RevokedInstallationUpdate: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationKey: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A wrapper for any update to the wallet
  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestampNs: UInt64 = 0

    public var kind: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update.OneOf_Kind? = nil

    public var newInstallation: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate {
      get {
        if case .newInstallation(let v)? = kind {return v}
        return Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate()
      }
      set {kind = .newInstallation(newValue)}
    }

    public var revokedInstallation: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate {
      get {
        if case .revokedInstallation(let v)? = kind {return v}
        return Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate()
      }
      set {kind = .revokedInstallation(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable, Sendable {
      case newInstallation(Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate)
      case revokedInstallation(Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate)

    }

    public init() {}
  }

  /// A wrapper for the updates for a single wallet
  public struct WalletUpdates: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var updates: [Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Pagination config for queries
public struct Xmtp_Mls_Api_V1_PagingInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var direction: Xmtp_Mls_Api_V1_SortDirection = .unspecified

  public var limit: UInt32 = 0

  public var idCursor: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for group message queries
public struct Xmtp_Mls_Api_V1_QueryGroupMessagesRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Data = Data()

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Response for group message queries
public struct Xmtp_Mls_Api_V1_QueryGroupMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_GroupMessage] = []

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Request for welcome message queries
public struct Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationKey: Data = Data()

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Response for welcome message queries
public struct Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_WelcomeMessage] = []

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Request for subscribing to group messages
public struct Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filters: [Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Subscription filter
  public struct Filter: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var groupID: Data = Data()

    public var idCursor: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Request for subscribing to welcome messages
public struct Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filters: [Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Subscription filter
  public struct Filter: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationKey: Data = Data()

    public var idCursor: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Xmtp_Mls_Api_V1_BatchPublishCommitLogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_Mls_Api_V1_PublishCommitLogRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_Mls_Api_V1_PublishCommitLogRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Data = Data()

  public var serializedCommitLogEntry: Data = Data()

  public var signature: Xmtp_Identity_Associations_RecoverableEd25519Signature {
    get {return _signature ?? Xmtp_Identity_Associations_RecoverableEd25519Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signature: Xmtp_Identity_Associations_RecoverableEd25519Signature? = nil
}

public struct Xmtp_Mls_Api_V1_QueryCommitLogRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Data = Data()

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

public struct Xmtp_Mls_Api_V1_QueryCommitLogResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Data = Data()

  public var commitLogEntries: [Xmtp_Mls_MessageContents_CommitLogEntry] = []

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

public struct Xmtp_Mls_Api_V1_BatchQueryCommitLogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Xmtp_Mls_Api_V1_QueryCommitLogRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_Mls_Api_V1_BatchQueryCommitLogResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Xmtp_Mls_Api_V1_QueryCommitLogResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get the newest group message from a range of topics
public struct Xmtp_Mls_Api_V1_GetNewestGroupMessageRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Get the newest message from each of these topics
  public var groupIds: [Data] = []

  public var includeContent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Returns a list of responses that will always be the same length as the
/// request
public struct Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If no message is found on the topic, will be nil
    public var groupMessage: Xmtp_Mls_Api_V1_GroupMessage {
      get {return _groupMessage ?? Xmtp_Mls_Api_V1_GroupMessage()}
      set {_groupMessage = newValue}
    }
    /// Returns true if `groupMessage` has been explicitly set.
    public var hasGroupMessage: Bool {return self._groupMessage != nil}
    /// Clears the value of `groupMessage`. Subsequent reads from it will return its default value.
    public mutating func clearGroupMessage() {self._groupMessage = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _groupMessage: Xmtp_Mls_Api_V1_GroupMessage? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.mls.api.v1"

extension Xmtp_Mls_Api_V1_SortDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SORT_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "SORT_DIRECTION_ASCENDING"),
    2: .same(proto: "SORT_DIRECTION_DESCENDING"),
  ]
}

extension Xmtp_Mls_Api_V1_WelcomeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
    2: .standard(proto: "welcome_pointer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessage.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      case 2: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessage.WelcomePointer?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .welcomePointer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .welcomePointer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.version {
    case .v1?: try {
      guard case .v1(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .welcomePointer?: try {
      guard case .welcomePointer(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessage, rhs: Xmtp_Mls_Api_V1_WelcomeMessage) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessage.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_WelcomeMessage.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_ns"),
    3: .standard(proto: "installation_key"),
    4: .same(proto: "data"),
    5: .standard(proto: "hpke_public_key"),
    6: .standard(proto: "wrapper_algorithm"),
    7: .standard(proto: "welcome_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.createdNs) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.hpkePublicKey) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.wrapperAlgorithm) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.welcomeMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.createdNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdNs, fieldNumber: 2)
    }
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if !self.hpkePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hpkePublicKey, fieldNumber: 5)
    }
    if self.wrapperAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.wrapperAlgorithm, fieldNumber: 6)
    }
    if !self.welcomeMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.welcomeMetadata, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessage.V1, rhs: Xmtp_Mls_Api_V1_WelcomeMessage.V1) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.data != rhs.data {return false}
    if lhs.hpkePublicKey != rhs.hpkePublicKey {return false}
    if lhs.wrapperAlgorithm != rhs.wrapperAlgorithm {return false}
    if lhs.welcomeMetadata != rhs.welcomeMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessage.WelcomePointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_WelcomeMessage.protoMessageName + ".WelcomePointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_ns"),
    3: .standard(proto: "installation_key"),
    4: .standard(proto: "welcome_pointer"),
    5: .standard(proto: "hpke_public_key"),
    6: .standard(proto: "wrapper_algorithm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.createdNs) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.welcomePointer) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.hpkePublicKey) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.wrapperAlgorithm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.createdNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdNs, fieldNumber: 2)
    }
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 3)
    }
    if !self.welcomePointer.isEmpty {
      try visitor.visitSingularBytesField(value: self.welcomePointer, fieldNumber: 4)
    }
    if !self.hpkePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hpkePublicKey, fieldNumber: 5)
    }
    if self.wrapperAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.wrapperAlgorithm, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessage.WelcomePointer, rhs: Xmtp_Mls_Api_V1_WelcomeMessage.WelcomePointer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.welcomePointer != rhs.welcomePointer {return false}
    if lhs.hpkePublicKey != rhs.hpkePublicKey {return false}
    if lhs.wrapperAlgorithm != rhs.wrapperAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessageInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeMessageInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
    2: .standard(proto: "welcome_pointer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      case 2: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessageInput.WelcomePointer?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .welcomePointer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .welcomePointer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.version {
    case .v1?: try {
      guard case .v1(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .welcomePointer?: try {
      guard case .welcomePointer(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessageInput, rhs: Xmtp_Mls_Api_V1_WelcomeMessageInput) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessageInput.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_WelcomeMessageInput.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .same(proto: "data"),
    3: .standard(proto: "hpke_public_key"),
    4: .standard(proto: "wrapper_algorithm"),
    7: .standard(proto: "welcome_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hpkePublicKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.wrapperAlgorithm) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.welcomeMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.hpkePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hpkePublicKey, fieldNumber: 3)
    }
    if self.wrapperAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.wrapperAlgorithm, fieldNumber: 4)
    }
    if !self.welcomeMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.welcomeMetadata, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1, rhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.data != rhs.data {return false}
    if lhs.hpkePublicKey != rhs.hpkePublicKey {return false}
    if lhs.wrapperAlgorithm != rhs.wrapperAlgorithm {return false}
    if lhs.welcomeMetadata != rhs.welcomeMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessageInput.WelcomePointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_WelcomeMessageInput.protoMessageName + ".WelcomePointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "welcome_pointer"),
    3: .standard(proto: "hpke_public_key"),
    4: .standard(proto: "wrapper_algorithm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.welcomePointer) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hpkePublicKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.wrapperAlgorithm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    if !self.welcomePointer.isEmpty {
      try visitor.visitSingularBytesField(value: self.welcomePointer, fieldNumber: 2)
    }
    if !self.hpkePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hpkePublicKey, fieldNumber: 3)
    }
    if self.wrapperAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.wrapperAlgorithm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.WelcomePointer, rhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.WelcomePointer) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.welcomePointer != rhs.welcomePointer {return false}
    if lhs.hpkePublicKey != rhs.hpkePublicKey {return false}
    if lhs.wrapperAlgorithm != rhs.wrapperAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.messageCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageCursor != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageCursor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMetadata, rhs: Xmtp_Mls_Api_V1_WelcomeMetadata) -> Bool {
    if lhs.messageCursor != rhs.messageCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_GroupMessage.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessage, rhs: Xmtp_Mls_Api_V1_GroupMessage) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessage.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GroupMessage.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_ns"),
    3: .standard(proto: "group_id"),
    4: .same(proto: "data"),
    5: .standard(proto: "sender_hmac"),
    6: .standard(proto: "should_push"),
    7: .standard(proto: "is_commit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.createdNs) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.senderHmac) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.shouldPush) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isCommit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.createdNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdNs, fieldNumber: 2)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if !self.senderHmac.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderHmac, fieldNumber: 5)
    }
    if self.shouldPush != false {
      try visitor.visitSingularBoolField(value: self.shouldPush, fieldNumber: 6)
    }
    if self.isCommit != false {
      try visitor.visitSingularBoolField(value: self.isCommit, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessage.V1, rhs: Xmtp_Mls_Api_V1_GroupMessage.V1) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.senderHmac != rhs.senderHmac {return false}
    if lhs.shouldPush != rhs.shouldPush {return false}
    if lhs.isCommit != rhs.isCommit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessageInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMessageInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_GroupMessageInput.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessageInput, rhs: Xmtp_Mls_Api_V1_GroupMessageInput) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessageInput.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GroupMessageInput.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "sender_hmac"),
    3: .standard(proto: "should_push"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.senderHmac) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.shouldPush) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.senderHmac.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderHmac, fieldNumber: 2)
    }
    if self.shouldPush != false {
      try visitor.visitSingularBoolField(value: self.shouldPush, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessageInput.V1, rhs: Xmtp_Mls_Api_V1_GroupMessageInput.V1) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.senderHmac != rhs.senderHmac {return false}
    if lhs.shouldPush != rhs.shouldPush {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SendGroupMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendGroupMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SendGroupMessagesRequest, rhs: Xmtp_Mls_Api_V1_SendGroupMessagesRequest) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendWelcomeMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest, rhs: Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_KeyPackageUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyPackageUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package_tls_serialized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.keyPackageTlsSerialized) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackageTlsSerialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyPackageTlsSerialized, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_KeyPackageUpload, rhs: Xmtp_Mls_Api_V1_KeyPackageUpload) -> Bool {
    if lhs.keyPackageTlsSerialized != rhs.keyPackageTlsSerialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_RegisterInstallationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterInstallationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package"),
    2: .standard(proto: "is_inbox_id_credential"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyPackage) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isInboxIDCredential) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyPackage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isInboxIDCredential != false {
      try visitor.visitSingularBoolField(value: self.isInboxIDCredential, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_RegisterInstallationRequest, rhs: Xmtp_Mls_Api_V1_RegisterInstallationRequest) -> Bool {
    if lhs._keyPackage != rhs._keyPackage {return false}
    if lhs.isInboxIDCredential != rhs.isInboxIDCredential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_RegisterInstallationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterInstallationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_RegisterInstallationResponse, rhs: Xmtp_Mls_Api_V1_RegisterInstallationResponse) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_UploadKeyPackageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadKeyPackageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package"),
    2: .standard(proto: "is_inbox_id_credential"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyPackage) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isInboxIDCredential) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyPackage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isInboxIDCredential != false {
      try visitor.visitSingularBoolField(value: self.isInboxIDCredential, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_UploadKeyPackageRequest, rhs: Xmtp_Mls_Api_V1_UploadKeyPackageRequest) -> Bool {
    if lhs._keyPackage != rhs._keyPackage {return false}
    if lhs.isInboxIDCredential != rhs.isInboxIDCredential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_FetchKeyPackagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchKeyPackagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.installationKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.installationKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_FetchKeyPackagesRequest, rhs: Xmtp_Mls_Api_V1_FetchKeyPackagesRequest) -> Bool {
    if lhs.installationKeys != rhs.installationKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_FetchKeyPackagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchKeyPackagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyPackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyPackages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse, rhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse) -> Bool {
    if lhs.keyPackages != rhs.keyPackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.protoMessageName + ".KeyPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package_tls_serialized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.keyPackageTlsSerialized) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackageTlsSerialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyPackageTlsSerialized, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage, rhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage) -> Bool {
    if lhs.keyPackageTlsSerialized != rhs.keyPackageTlsSerialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_RevokeInstallationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeInstallationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "wallet_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._walletSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try { if let v = self._walletSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_RevokeInstallationRequest, rhs: Xmtp_Mls_Api_V1_RevokeInstallationRequest) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs._walletSignature != rhs._walletSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIdentityUpdatesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_addresses"),
    2: .standard(proto: "start_time_ns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accountAddresses) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.startTimeNs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accountAddresses, fieldNumber: 1)
    }
    if self.startTimeNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTimeNs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest) -> Bool {
    if lhs.accountAddresses != rhs.accountAddresses {return false}
    if lhs.startTimeNs != rhs.startTimeNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIdentityUpdatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".NewInstallationUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "credential_identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.credentialIdentity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    if !self.credentialIdentity.isEmpty {
      try visitor.visitSingularBytesField(value: self.credentialIdentity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.credentialIdentity != rhs.credentialIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".RevokedInstallationUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_ns"),
    2: .standard(proto: "new_installation"),
    3: .standard(proto: "revoked_installation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestampNs) }()
      case 2: try {
        var v: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .newInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .newInstallation(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .revokedInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .revokedInstallation(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampNs, fieldNumber: 1)
    }
    switch self.kind {
    case .newInstallation?: try {
      guard case .newInstallation(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .revokedInstallation?: try {
      guard case .revokedInstallation(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update) -> Bool {
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".WalletUpdates"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_PagingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PagingInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .same(proto: "limit"),
    3: .standard(proto: "id_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.idCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    if self.idCursor != 0 {
      try visitor.visitSingularUInt64Field(value: self.idCursor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_PagingInfo, rhs: Xmtp_Mls_Api_V1_PagingInfo) -> Bool {
    if lhs.direction != rhs.direction {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.idCursor != rhs.idCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryGroupMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryGroupMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryGroupMessagesRequest, rhs: Xmtp_Mls_Api_V1_QueryGroupMessagesRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryGroupMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryGroupMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryGroupMessagesResponse, rhs: Xmtp_Mls_Api_V1_QueryGroupMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryWelcomeMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest, rhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryWelcomeMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse, rhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeGroupMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest, rhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "id_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.idCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if self.idCursor != 0 {
      try visitor.visitSingularUInt64Field(value: self.idCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter, rhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.idCursor != rhs.idCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeWelcomeMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest, rhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "id_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.idCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    if self.idCursor != 0 {
      try visitor.visitSingularUInt64Field(value: self.idCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter, rhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.idCursor != rhs.idCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_BatchPublishCommitLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchPublishCommitLogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_BatchPublishCommitLogRequest, rhs: Xmtp_Mls_Api_V1_BatchPublishCommitLogRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_PublishCommitLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishCommitLogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "serialized_commit_log_entry"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.serializedCommitLogEntry) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.serializedCommitLogEntry.isEmpty {
      try visitor.visitSingularBytesField(value: self.serializedCommitLogEntry, fieldNumber: 2)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_PublishCommitLogRequest, rhs: Xmtp_Mls_Api_V1_PublishCommitLogRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.serializedCommitLogEntry != rhs.serializedCommitLogEntry {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryCommitLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryCommitLogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryCommitLogRequest, rhs: Xmtp_Mls_Api_V1_QueryCommitLogRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryCommitLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryCommitLogResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "commit_log_entries"),
    3: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.commitLogEntries) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.commitLogEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commitLogEntries, fieldNumber: 2)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryCommitLogResponse, rhs: Xmtp_Mls_Api_V1_QueryCommitLogResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.commitLogEntries != rhs.commitLogEntries {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_BatchQueryCommitLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchQueryCommitLogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_BatchQueryCommitLogRequest, rhs: Xmtp_Mls_Api_V1_BatchQueryCommitLogRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_BatchQueryCommitLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchQueryCommitLogResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_BatchQueryCommitLogResponse, rhs: Xmtp_Mls_Api_V1_BatchQueryCommitLogResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetNewestGroupMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNewestGroupMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_ids"),
    2: .standard(proto: "include_content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.groupIds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.groupIds, fieldNumber: 1)
    }
    if self.includeContent != false {
      try visitor.visitSingularBoolField(value: self.includeContent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetNewestGroupMessageRequest, rhs: Xmtp_Mls_Api_V1_GetNewestGroupMessageRequest) -> Bool {
    if lhs.groupIds != rhs.groupIds {return false}
    if lhs.includeContent != rhs.includeContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNewestGroupMessageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse, rhs: Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse.Response, rhs: Xmtp_Mls_Api_V1_GetNewestGroupMessageResponse.Response) -> Bool {
    if lhs._groupMessage != rhs._groupMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
