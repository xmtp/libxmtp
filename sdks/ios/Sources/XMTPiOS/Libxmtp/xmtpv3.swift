// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(xmtpv3FFI)
import xmtpv3FFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_xmtpv3_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_xmtpv3_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureXmtpv3Initialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol FfiAuthCallback: AnyObject, Sendable {
    
    func onAuthRequired() async throws  -> FfiCredential
    
}
open class FfiAuthCallbackImpl: FfiAuthCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffiauthcallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffiauthcallback(pointer, $0) }
    }

    

    
open func onAuthRequired()async throws  -> FfiCredential  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiauthcallback_on_auth_required(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiCredential_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiAuthCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiAuthCallback] = [UniffiVTableCallbackInterfaceFfiAuthCallback(
        onAuthRequired: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> FfiCredential in
                guard let uniffiObj = try? FfiConverterTypeFfiAuthCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.onAuthRequired(
                )
            }

            let uniffiHandleSuccess = { (returnValue: FfiCredential) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeFfiCredential_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFfiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiAuthCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiAuthCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiAuthCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffiauthcallback(UniffiCallbackInterfaceFfiAuthCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiAuthCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiAuthCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiAuthCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiAuthCallback {
        return FfiAuthCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiAuthCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiAuthCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiAuthCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAuthCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiAuthCallback {
    return try FfiConverterTypeFfiAuthCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAuthCallback_lower(_ value: FfiAuthCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiAuthCallback.lower(value)
}






public protocol FfiAuthHandleProtocol: AnyObject, Sendable {
    
    func id()  -> UInt64
    
    func set(credential: FfiCredential) async throws 
    
}
open class FfiAuthHandle: FfiAuthHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffiauthhandle(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_xmtpv3_fn_constructor_ffiauthhandle_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffiauthhandle(pointer, $0) }
    }

    

    
open func id() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffiauthhandle_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func set(credential: FfiCredential)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiauthhandle_set(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiCredential_lower(credential)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiAuthHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiAuthHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiAuthHandle {
        return FfiAuthHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiAuthHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiAuthHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiAuthHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAuthHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiAuthHandle {
    return try FfiConverterTypeFfiAuthHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAuthHandle_lower(_ value: FfiAuthHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiAuthHandle.lower(value)
}






public protocol FfiConsentCallback: AnyObject, Sendable {
    
    func onConsentUpdate(consent: [FfiConsent]) 
    
    func onError(error: FfiError) 
    
    func onClose() 
    
}
open class FfiConsentCallbackImpl: FfiConsentCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonsentcallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonsentcallback(pointer, $0) }
    }

    

    
open func onConsentUpdate(consent: [FfiConsent])  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonsentcallback_on_consent_update(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFfiConsent.lower(consent),$0
    )
}
}
    
open func onError(error: FfiError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonsentcallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonsentcallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiConsentCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiConsentCallback] = [UniffiVTableCallbackInterfaceFfiConsentCallback(
        onConsentUpdate: { (
            uniffiHandle: UInt64,
            consent: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConsentCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConsentUpdate(
                     consent: try FfiConverterSequenceTypeFfiConsent.lift(consent)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConsentCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConsentCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiConsentCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiConsentCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiConsentCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_fficonsentcallback(UniffiCallbackInterfaceFfiConsentCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsentCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiConsentCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConsentCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConsentCallback {
        return FfiConsentCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConsentCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConsentCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConsentCallback {
    return try FfiConverterTypeFfiConsentCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentCallback_lower(_ value: FfiConsentCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConsentCallback.lower(value)
}






public protocol FfiConversationProtocol: AnyObject, Sendable {
    
    func addAdmin(inboxId: String) async throws 
    
    func addMembers(inboxIds: [String]) async throws  -> FfiUpdateGroupMembershipResult
    
    func addMembersByIdentity(accountIdentifiers: [FfiIdentifier]) async throws  -> FfiUpdateGroupMembershipResult
    
    func addSuperAdmin(inboxId: String) async throws 
    
    func addedByInboxId() throws  -> String
    
    func adminList() throws  -> [String]
    
    func appData() throws  -> String
    
    func consentState() throws  -> FfiConsentState
    
    func conversationDebugInfo() async throws  -> FfiConversationDebugInfo
    
    func conversationMessageDisappearingSettings() throws  -> FfiMessageDisappearingSettings?
    
    func conversationType()  -> FfiConversationType
    
    func countMessages(opts: FfiListMessagesOptions) throws  -> Int64
    
    func createdAtNs()  -> Int64
    
    /**
     * Delete a message by its ID. Returns the ID of the deletion message.
     */
    func deleteMessage(messageId: Data) throws  -> Data
    
    func dmPeerInboxId()  -> String?
    
    func findDuplicateDms() async throws  -> [FfiConversation]
    
    func findEnrichedMessages(opts: FfiListMessagesOptions) throws  -> [FfiDecodedMessage]
    
    func findMessages(opts: FfiListMessagesOptions) async throws  -> [FfiMessage]
    
    func findMessagesWithReactions(opts: FfiListMessagesOptions) throws  -> [FfiMessageWithReactions]
    
    func getHmacKeys() throws  -> [Data: [FfiHmacKey]]
    
    func getLastReadTimes() throws  -> [String: Int64]
    
    func groupDescription() throws  -> String
    
    func groupImageUrlSquare() throws  -> String
    
    func groupMetadata() async throws  -> FfiConversationMetadata
    
    func groupName() throws  -> String
    
    func groupPermissions() throws  -> FfiGroupPermissions
    
    func id()  -> Data
    
    func isActive() throws  -> Bool
    
    func isAdmin(inboxId: String) throws  -> Bool
    
    func isConversationMessageDisappearingEnabled() throws  -> Bool
    
    func isSuperAdmin(inboxId: String) throws  -> Bool
    
    func leaveGroup() async throws 
    
    func listMembers() async throws  -> [FfiConversationMember]
    
    func membershipState() throws  -> FfiGroupMembershipState
    
    func pausedForVersion() throws  -> String?
    
    /**
     * Prepare a message for later publishing.
     * Stores the message locally without publishing. Returns the message ID.
     */
    func prepareMessage(contentBytes: Data, shouldPush: Bool) throws  -> Data
    
    func processStreamedConversationMessage(envelopeBytes: Data) async throws  -> [FfiMessage]
    
    /**
     * Publish all unpublished messages
     */
    func publishMessages() async throws 
    
    /**
     * Publish a previously prepared message by ID.
     */
    func publishStoredMessage(messageId: Data) async throws 
    
    func removeAdmin(inboxId: String) async throws 
    
    func removeConversationMessageDisappearingSettings() async throws 
    
    func removeMembers(inboxIds: [String]) async throws 
    
    func removeMembersByIdentity(accountIdentifiers: [FfiIdentifier]) async throws 
    
    func removeSuperAdmin(inboxId: String) async throws 
    
    func send(contentBytes: Data, opts: FfiSendMessageOpts) async throws  -> Data
    
    /**
     * send a message without immediately publishing to the delivery service.
     */
    func sendOptimistic(contentBytes: Data, opts: FfiSendMessageOpts) throws  -> Data
    
    func sendText(text: String) async throws  -> Data
    
    func stream(messageCallback: FfiMessageCallback) async  -> FfiStreamCloser
    
    func superAdminList() throws  -> [String]
    
    func sync() async throws 
    
    func updateAppData(appData: String) async throws 
    
    func updateConsentState(state: FfiConsentState) throws 
    
    func updateConversationMessageDisappearingSettings(settings: FfiMessageDisappearingSettings) async throws 
    
    func updateGroupDescription(groupDescription: String) async throws 
    
    func updateGroupImageUrlSquare(groupImageUrlSquare: String) async throws 
    
    func updateGroupName(groupName: String) async throws 
    
    func updatePermissionPolicy(permissionUpdateType: FfiPermissionUpdateType, permissionPolicyOption: FfiPermissionPolicy, metadataField: FfiMetadataField?) async throws 
    
}
open class FfiConversation: FfiConversationProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversation(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversation(pointer, $0) }
    }

    

    
open func addAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func addMembers(inboxIds: [String])async throws  -> FfiUpdateGroupMembershipResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_members(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiUpdateGroupMembershipResult_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func addMembersByIdentity(accountIdentifiers: [FfiIdentifier])async throws  -> FfiUpdateGroupMembershipResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_members_by_identity(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentifiers)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiUpdateGroupMembershipResult_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func addSuperAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_super_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func addedByInboxId()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_added_by_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func adminList()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_admin_list(self.uniffiClonePointer(),$0
    )
})
}
    
open func appData()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_app_data(self.uniffiClonePointer(),$0
    )
})
}
    
open func consentState()throws  -> FfiConsentState  {
    return try  FfiConverterTypeFfiConsentState_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_consent_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func conversationDebugInfo()async throws  -> FfiConversationDebugInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_conversation_debug_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiConversationDebugInfo_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func conversationMessageDisappearingSettings()throws  -> FfiMessageDisappearingSettings?  {
    return try  FfiConverterOptionTypeFfiMessageDisappearingSettings.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_conversation_message_disappearing_settings(self.uniffiClonePointer(),$0
    )
})
}
    
open func conversationType() -> FfiConversationType  {
    return try!  FfiConverterTypeFfiConversationType_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_conversation_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func countMessages(opts: FfiListMessagesOptions)throws  -> Int64  {
    return try  FfiConverterInt64.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_count_messages(self.uniffiClonePointer(),
        FfiConverterTypeFfiListMessagesOptions_lower(opts),$0
    )
})
}
    
open func createdAtNs() -> Int64  {
    return try!  FfiConverterInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_created_at_ns(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Delete a message by its ID. Returns the ID of the deletion message.
     */
open func deleteMessage(messageId: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_delete_message(self.uniffiClonePointer(),
        FfiConverterData.lower(messageId),$0
    )
})
}
    
open func dmPeerInboxId() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_dm_peer_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func findDuplicateDms()async throws  -> [FfiConversation]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_find_duplicate_dms(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiConversation.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func findEnrichedMessages(opts: FfiListMessagesOptions)throws  -> [FfiDecodedMessage]  {
    return try  FfiConverterSequenceTypeFfiDecodedMessage.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_find_enriched_messages(self.uniffiClonePointer(),
        FfiConverterTypeFfiListMessagesOptions_lower(opts),$0
    )
})
}
    
open func findMessages(opts: FfiListMessagesOptions)async throws  -> [FfiMessage]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_find_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiListMessagesOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiMessage.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func findMessagesWithReactions(opts: FfiListMessagesOptions)throws  -> [FfiMessageWithReactions]  {
    return try  FfiConverterSequenceTypeFfiMessageWithReactions.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_find_messages_with_reactions(self.uniffiClonePointer(),
        FfiConverterTypeFfiListMessagesOptions_lower(opts),$0
    )
})
}
    
open func getHmacKeys()throws  -> [Data: [FfiHmacKey]]  {
    return try  FfiConverterDictionaryDataSequenceTypeFfiHmacKey.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_get_hmac_keys(self.uniffiClonePointer(),$0
    )
})
}
    
open func getLastReadTimes()throws  -> [String: Int64]  {
    return try  FfiConverterDictionaryStringInt64.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_get_last_read_times(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupDescription()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupImageUrlSquare()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_image_url_square(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupMetadata()async throws  -> FfiConversationMetadata  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_group_metadata(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversationMetadata_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func groupName()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupPermissions()throws  -> FfiGroupPermissions  {
    return try  FfiConverterTypeFfiGroupPermissions_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_permissions(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func isActive()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_active(self.uniffiClonePointer(),$0
    )
})
}
    
open func isAdmin(inboxId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_admin(self.uniffiClonePointer(),
        FfiConverterString.lower(inboxId),$0
    )
})
}
    
open func isConversationMessageDisappearingEnabled()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_conversation_message_disappearing_enabled(self.uniffiClonePointer(),$0
    )
})
}
    
open func isSuperAdmin(inboxId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_super_admin(self.uniffiClonePointer(),
        FfiConverterString.lower(inboxId),$0
    )
})
}
    
open func leaveGroup()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_leave_group(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func listMembers()async throws  -> [FfiConversationMember]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_list_members(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiConversationMember.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func membershipState()throws  -> FfiGroupMembershipState  {
    return try  FfiConverterTypeFfiGroupMembershipState_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_membership_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func pausedForVersion()throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_paused_for_version(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Prepare a message for later publishing.
     * Stores the message locally without publishing. Returns the message ID.
     */
open func prepareMessage(contentBytes: Data, shouldPush: Bool)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_prepare_message(self.uniffiClonePointer(),
        FfiConverterData.lower(contentBytes),
        FfiConverterBool.lower(shouldPush),$0
    )
})
}
    
open func processStreamedConversationMessage(envelopeBytes: Data)async throws  -> [FfiMessage]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_process_streamed_conversation_message(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(envelopeBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiMessage.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * Publish all unpublished messages
     */
open func publishMessages()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_publish_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * Publish a previously prepared message by ID.
     */
open func publishStoredMessage(messageId: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_publish_stored_message(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(messageId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func removeAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func removeConversationMessageDisappearingSettings()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_conversation_message_disappearing_settings(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func removeMembers(inboxIds: [String])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_members(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func removeMembersByIdentity(accountIdentifiers: [FfiIdentifier])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_members_by_identity(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentifiers)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func removeSuperAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_super_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func send(contentBytes: Data, opts: FfiSendMessageOpts)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_send(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(contentBytes),FfiConverterTypeFfiSendMessageOpts_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * send a message without immediately publishing to the delivery service.
     */
open func sendOptimistic(contentBytes: Data, opts: FfiSendMessageOpts)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_send_optimistic(self.uniffiClonePointer(),
        FfiConverterData.lower(contentBytes),
        FfiConverterTypeFfiSendMessageOpts_lower(opts),$0
    )
})
}
    
open func sendText(text: String)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_send_text(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(text)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func stream(messageCallback: FfiMessageCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_stream(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func superAdminList()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_super_admin_list(self.uniffiClonePointer(),$0
    )
})
}
    
open func sync()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_sync(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func updateAppData(appData: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_app_data(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(appData)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func updateConsentState(state: FfiConsentState)throws   {try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_update_consent_state(self.uniffiClonePointer(),
        FfiConverterTypeFfiConsentState_lower(state),$0
    )
}
}
    
open func updateConversationMessageDisappearingSettings(settings: FfiMessageDisappearingSettings)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_conversation_message_disappearing_settings(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageDisappearingSettings_lower(settings)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func updateGroupDescription(groupDescription: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_group_description(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(groupDescription)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func updateGroupImageUrlSquare(groupImageUrlSquare: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_group_image_url_square(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(groupImageUrlSquare)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func updateGroupName(groupName: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_group_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(groupName)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func updatePermissionPolicy(permissionUpdateType: FfiPermissionUpdateType, permissionPolicyOption: FfiPermissionPolicy, metadataField: FfiMetadataField?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_permission_policy(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiPermissionUpdateType_lower(permissionUpdateType),FfiConverterTypeFfiPermissionPolicy_lower(permissionPolicyOption),FfiConverterOptionTypeFfiMetadataField.lower(metadataField)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversation: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversation

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversation {
        return FfiConversation(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversation) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversation {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversation, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversation_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversation {
    return try FfiConverterTypeFfiConversation.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversation_lower(_ value: FfiConversation) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversation.lower(value)
}






public protocol FfiConversationCallback: AnyObject, Sendable {
    
    func onConversation(conversation: FfiConversation) 
    
    func onError(error: FfiError) 
    
    func onClose() 
    
}
open class FfiConversationCallbackImpl: FfiConversationCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversationcallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversationcallback(pointer, $0) }
    }

    

    
open func onConversation(conversation: FfiConversation)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationcallback_on_conversation(self.uniffiClonePointer(),
        FfiConverterTypeFfiConversation_lower(conversation),$0
    )
}
}
    
open func onError(error: FfiError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationcallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationcallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiConversationCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiConversationCallback] = [UniffiVTableCallbackInterfaceFfiConversationCallback(
        onConversation: { (
            uniffiHandle: UInt64,
            conversation: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConversationCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConversation(
                     conversation: try FfiConverterTypeFfiConversation_lift(conversation)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConversationCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConversationCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiConversationCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiConversationCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiConversationCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_fficonversationcallback(UniffiCallbackInterfaceFfiConversationCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiConversationCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversationCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationCallback {
        return FfiConversationCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversationCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversationCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationCallback {
    return try FfiConverterTypeFfiConversationCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationCallback_lower(_ value: FfiConversationCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversationCallback.lower(value)
}






public protocol FfiConversationListItemProtocol: AnyObject, Sendable {
    
    func conversation()  -> FfiConversation
    
    func isCommitLogForked()  -> Bool?
    
    func lastMessage()  -> FfiMessage?
    
}
open class FfiConversationListItem: FfiConversationListItemProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversationlistitem(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversationlistitem(pointer, $0) }
    }

    

    
open func conversation() -> FfiConversation  {
    return try!  FfiConverterTypeFfiConversation_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationlistitem_conversation(self.uniffiClonePointer(),$0
    )
})
}
    
open func isCommitLogForked() -> Bool?  {
    return try!  FfiConverterOptionBool.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationlistitem_is_commit_log_forked(self.uniffiClonePointer(),$0
    )
})
}
    
open func lastMessage() -> FfiMessage?  {
    return try!  FfiConverterOptionTypeFfiMessage.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationlistitem_last_message(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationListItem: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversationListItem

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationListItem {
        return FfiConversationListItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversationListItem) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationListItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversationListItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationListItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationListItem {
    return try FfiConverterTypeFfiConversationListItem.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationListItem_lower(_ value: FfiConversationListItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversationListItem.lower(value)
}






public protocol FfiConversationMetadataProtocol: AnyObject, Sendable {
    
    func conversationType()  -> FfiConversationType
    
    func creatorInboxId()  -> String
    
}
open class FfiConversationMetadata: FfiConversationMetadataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversationmetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversationmetadata(pointer, $0) }
    }

    

    
open func conversationType() -> FfiConversationType  {
    return try!  FfiConverterTypeFfiConversationType_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationmetadata_conversation_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func creatorInboxId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationmetadata_creator_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversationMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationMetadata {
        return FfiConversationMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversationMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversationMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationMetadata {
    return try FfiConverterTypeFfiConversationMetadata.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMetadata_lower(_ value: FfiConversationMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversationMetadata.lower(value)
}






public protocol FfiConversationsProtocol: AnyObject, Sendable {
    
    func createGroup(inboxIds: [String], opts: FfiCreateGroupOptions) async throws  -> FfiConversation
    
    func createGroupByIdentity(accountIdentities: [FfiIdentifier], opts: FfiCreateGroupOptions) async throws  -> FfiConversation
    
    func createGroupOptimistic(opts: FfiCreateGroupOptions) throws  -> FfiConversation
    
    func findOrCreateDm(inboxId: String, opts: FfiCreateDmOptions) async throws  -> FfiConversation
    
    func findOrCreateDmByIdentity(targetIdentity: FfiIdentifier, opts: FfiCreateDmOptions) async throws  -> FfiConversation
    
    func getHmacKeys() throws  -> [Data: [FfiHmacKey]]
    
    func list(opts: FfiListConversationsOptions) throws  -> [FfiConversationListItem]
    
    func listDms(opts: FfiListConversationsOptions) throws  -> [FfiConversationListItem]
    
    func listGroups(opts: FfiListConversationsOptions) throws  -> [FfiConversationListItem]
    
    func processStreamedWelcomeMessage(envelopeBytes: Data) async throws  -> [FfiConversation]
    
    func stream(callback: FfiConversationCallback) async  -> FfiStreamCloser
    
    func streamAllDmMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    func streamAllGroupMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    func streamAllMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    /**
     * Get notified when there is a new consent update either locally or is synced from another device
     * allowing the user to re-render the new state appropriately
     */
    func streamConsent(callback: FfiConsentCallback) async  -> FfiStreamCloser
    
    func streamDms(callback: FfiConversationCallback) async  -> FfiStreamCloser
    
    func streamGroups(callback: FfiConversationCallback) async  -> FfiStreamCloser
    
    /**
     * Get notified when a message is deleted by the disappearing messages worker.
     * The callback receives the decoded message that was deleted.
     */
    func streamMessageDeletions(callback: FfiMessageDeletionCallback) async  -> FfiStreamCloser
    
    func streamMessages(messageCallback: FfiMessageCallback, conversationType: FfiConversationType?, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    /**
     * Get notified when a preference changes either locally or is synced from another device
     * allowing the user to re-render the new state appropriately.
     */
    func streamPreferences(callback: FfiPreferenceCallback) async  -> FfiStreamCloser
    
    func sync() async throws 
    
    func syncAllConversations(consentStates: [FfiConsentState]?) async throws  -> FfiGroupSyncSummary
    
}
open class FfiConversations: FfiConversationsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversations(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversations(pointer, $0) }
    }

    

    
open func createGroup(inboxIds: [String], opts: FfiCreateGroupOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_create_group(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(inboxIds),FfiConverterTypeFfiCreateGroupOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func createGroupByIdentity(accountIdentities: [FfiIdentifier], opts: FfiCreateGroupOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_create_group_by_identity(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentities),FfiConverterTypeFfiCreateGroupOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func createGroupOptimistic(opts: FfiCreateGroupOptions)throws  -> FfiConversation  {
    return try  FfiConverterTypeFfiConversation_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_create_group_optimistic(self.uniffiClonePointer(),
        FfiConverterTypeFfiCreateGroupOptions_lower(opts),$0
    )
})
}
    
open func findOrCreateDm(inboxId: String, opts: FfiCreateDmOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId),FfiConverterTypeFfiCreateDMOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func findOrCreateDmByIdentity(targetIdentity: FfiIdentifier, opts: FfiCreateDmOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm_by_identity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(targetIdentity),FfiConverterTypeFfiCreateDMOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func getHmacKeys()throws  -> [Data: [FfiHmacKey]]  {
    return try  FfiConverterDictionaryDataSequenceTypeFfiHmacKey.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_get_hmac_keys(self.uniffiClonePointer(),$0
    )
})
}
    
open func list(opts: FfiListConversationsOptions)throws  -> [FfiConversationListItem]  {
    return try  FfiConverterSequenceTypeFfiConversationListItem.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_list(self.uniffiClonePointer(),
        FfiConverterTypeFfiListConversationsOptions_lower(opts),$0
    )
})
}
    
open func listDms(opts: FfiListConversationsOptions)throws  -> [FfiConversationListItem]  {
    return try  FfiConverterSequenceTypeFfiConversationListItem.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_list_dms(self.uniffiClonePointer(),
        FfiConverterTypeFfiListConversationsOptions_lower(opts),$0
    )
})
}
    
open func listGroups(opts: FfiListConversationsOptions)throws  -> [FfiConversationListItem]  {
    return try  FfiConverterSequenceTypeFfiConversationListItem.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_list_groups(self.uniffiClonePointer(),
        FfiConverterTypeFfiListConversationsOptions_lower(opts),$0
    )
})
}
    
open func processStreamedWelcomeMessage(envelopeBytes: Data)async throws  -> [FfiConversation]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_process_streamed_welcome_message(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(envelopeBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiConversation.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func stream(callback: FfiConversationCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConversationCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamAllDmMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_all_dm_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamAllGroupMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_all_group_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamAllMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_all_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get notified when there is a new consent update either locally or is synced from another device
     * allowing the user to re-render the new state appropriately
     */
open func streamConsent(callback: FfiConsentCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_consent(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConsentCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamDms(callback: FfiConversationCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_dms(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConversationCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamGroups(callback: FfiConversationCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_groups(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConversationCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get notified when a message is deleted by the disappearing messages worker.
     * The callback receives the decoded message that was deleted.
     */
open func streamMessageDeletions(callback: FfiMessageDeletionCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_message_deletions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageDeletionCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamMessages(messageCallback: FfiMessageCallback, conversationType: FfiConversationType?, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionTypeFfiConversationType.lower(conversationType),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get notified when a preference changes either locally or is synced from another device
     * allowing the user to re-render the new state appropriately.
     */
open func streamPreferences(callback: FfiPreferenceCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_preferences(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiPreferenceCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func sync()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_sync(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func syncAllConversations(consentStates: [FfiConsentState]?)async throws  -> FfiGroupSyncSummary  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_sync_all_conversations(
                    self.uniffiClonePointer(),
                    FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiGroupSyncSummary_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversations: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversations

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
        return FfiConversations(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversations {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversations, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversations_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
    return try FfiConverterTypeFfiConversations.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversations_lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversations.lower(value)
}






public protocol FfiDecodedMessageProtocol: AnyObject, Sendable {
    
    func content()  -> FfiDecodedMessageContent
    
    func contentTypeId()  -> FfiContentTypeId
    
    func conversationId()  -> Data
    
    func deliveryStatus()  -> FfiDeliveryStatus
    
    func expiresAtNs()  -> Int64?
    
    func fallbackText()  -> String?
    
    func hasReactions()  -> Bool
    
    func id()  -> Data
    
    func insertedAtNs()  -> Int64
    
    func kind()  -> FfiGroupMessageKind
    
    func numReplies()  -> UInt64
    
    func reactionCount()  -> UInt64
    
    func reactions()  -> [FfiDecodedMessage]
    
    func senderInboxId()  -> String
    
    func senderInstallationId()  -> Data
    
    func sentAtNs()  -> Int64
    
}
open class FfiDecodedMessage: FfiDecodedMessageProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffidecodedmessage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffidecodedmessage(pointer, $0) }
    }

    

    
open func content() -> FfiDecodedMessageContent  {
    return try!  FfiConverterTypeFfiDecodedMessageContent_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_content(self.uniffiClonePointer(),$0
    )
})
}
    
open func contentTypeId() -> FfiContentTypeId  {
    return try!  FfiConverterTypeFfiContentTypeId_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_content_type_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func conversationId() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_conversation_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func deliveryStatus() -> FfiDeliveryStatus  {
    return try!  FfiConverterTypeFfiDeliveryStatus_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_delivery_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func expiresAtNs() -> Int64?  {
    return try!  FfiConverterOptionInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_expires_at_ns(self.uniffiClonePointer(),$0
    )
})
}
    
open func fallbackText() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_fallback_text(self.uniffiClonePointer(),$0
    )
})
}
    
open func hasReactions() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_has_reactions(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func insertedAtNs() -> Int64  {
    return try!  FfiConverterInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_inserted_at_ns(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> FfiGroupMessageKind  {
    return try!  FfiConverterTypeFfiGroupMessageKind_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_kind(self.uniffiClonePointer(),$0
    )
})
}
    
open func numReplies() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_num_replies(self.uniffiClonePointer(),$0
    )
})
}
    
open func reactionCount() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_reaction_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func reactions() -> [FfiDecodedMessage]  {
    return try!  FfiConverterSequenceTypeFfiDecodedMessage.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_reactions(self.uniffiClonePointer(),$0
    )
})
}
    
open func senderInboxId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func senderInstallationId() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_installation_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func sentAtNs() -> Int64  {
    return try!  FfiConverterInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffidecodedmessage_sent_at_ns(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDecodedMessage: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiDecodedMessage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiDecodedMessage {
        return FfiDecodedMessage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiDecodedMessage) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDecodedMessage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiDecodedMessage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiDecodedMessage {
    return try FfiConverterTypeFfiDecodedMessage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessage_lower(_ value: FfiDecodedMessage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiDecodedMessage.lower(value)
}






public protocol FfiGroupPermissionsProtocol: AnyObject, Sendable {
    
    func policySet() throws  -> FfiPermissionPolicySet
    
    func policyType() throws  -> FfiGroupPermissionsOptions
    
}
open class FfiGroupPermissions: FfiGroupPermissionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffigrouppermissions(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffigrouppermissions(pointer, $0) }
    }

    

    
open func policySet()throws  -> FfiPermissionPolicySet  {
    return try  FfiConverterTypeFfiPermissionPolicySet_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_set(self.uniffiClonePointer(),$0
    )
})
}
    
open func policyType()throws  -> FfiGroupPermissionsOptions  {
    return try  FfiConverterTypeFfiGroupPermissionsOptions_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_type(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupPermissions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiGroupPermissions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupPermissions {
        return FfiGroupPermissions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiGroupPermissions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupPermissions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiGroupPermissions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissions_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupPermissions {
    return try FfiConverterTypeFfiGroupPermissions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissions_lower(_ value: FfiGroupPermissions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiGroupPermissions.lower(value)
}






public protocol FfiInboxOwner: AnyObject, Sendable {
    
    func getIdentifier() throws  -> FfiIdentifier
    
    func sign(text: String) throws  -> Data
    
}
open class FfiInboxOwnerImpl: FfiInboxOwner, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffiinboxowner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffiinboxowner(pointer, $0) }
    }

    

    
open func getIdentifier()throws  -> FfiIdentifier  {
    return try  FfiConverterTypeFfiIdentifier_lift(try rustCallWithError(FfiConverterTypeIdentityValidationError_lift) {
    uniffi_xmtpv3_fn_method_ffiinboxowner_get_identifier(self.uniffiClonePointer(),$0
    )
})
}
    
open func sign(text: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSigningError_lift) {
    uniffi_xmtpv3_fn_method_ffiinboxowner_sign(self.uniffiClonePointer(),
        FfiConverterString.lower(text),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiInboxOwner {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiInboxOwner] = [UniffiVTableCallbackInterfaceFfiInboxOwner(
        getIdentifier: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> FfiIdentifier in
                guard let uniffiObj = try? FfiConverterTypeFfiInboxOwner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.getIdentifier(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeFfiIdentifier_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeIdentityValidationError_lower
            )
        },
        sign: { (
            uniffiHandle: UInt64,
            text: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeFfiInboxOwner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.sign(
                     text: try FfiConverterString.lift(text)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeSigningError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiInboxOwner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiInboxOwner: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiInboxOwner() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffiinboxowner(UniffiCallbackInterfaceFfiInboxOwner.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiInboxOwner: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiInboxOwner>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiInboxOwner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiInboxOwner {
        return FfiInboxOwnerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiInboxOwner) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInboxOwner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiInboxOwner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxOwner_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiInboxOwner {
    return try FfiConverterTypeFfiInboxOwner.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxOwner_lower(_ value: FfiInboxOwner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiInboxOwner.lower(value)
}






public protocol FfiMessageCallback: AnyObject, Sendable {
    
    func onMessage(message: FfiMessage) 
    
    func onError(error: FfiError) 
    
    func onClose() 
    
}
open class FfiMessageCallbackImpl: FfiMessageCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffimessagecallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffimessagecallback(pointer, $0) }
    }

    

    
open func onMessage(message: FfiMessage)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffimessagecallback_on_message(self.uniffiClonePointer(),
        FfiConverterTypeFfiMessage_lower(message),$0
    )
}
}
    
open func onError(error: FfiError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffimessagecallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffimessagecallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiMessageCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiMessageCallback] = [UniffiVTableCallbackInterfaceFfiMessageCallback(
        onMessage: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onMessage(
                     message: try FfiConverterTypeFfiMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiMessageCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiMessageCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiMessageCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffimessagecallback(UniffiCallbackInterfaceFfiMessageCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiMessageCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiMessageCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiMessageCallback {
        return FfiMessageCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiMessageCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiMessageCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiMessageCallback {
    return try FfiConverterTypeFfiMessageCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageCallback_lower(_ value: FfiMessageCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiMessageCallback.lower(value)
}






public protocol FfiMessageDeletionCallback: AnyObject, Sendable {
    
    func onMessageDeleted(message: FfiDecodedMessage) 
    
}
open class FfiMessageDeletionCallbackImpl: FfiMessageDeletionCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffimessagedeletioncallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffimessagedeletioncallback(pointer, $0) }
    }

    

    
open func onMessageDeleted(message: FfiDecodedMessage)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffimessagedeletioncallback_on_message_deleted(self.uniffiClonePointer(),
        FfiConverterTypeFfiDecodedMessage_lower(message),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiMessageDeletionCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiMessageDeletionCallback] = [UniffiVTableCallbackInterfaceFfiMessageDeletionCallback(
        onMessageDeleted: { (
            uniffiHandle: UInt64,
            message: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiMessageDeletionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onMessageDeleted(
                     message: try FfiConverterTypeFfiDecodedMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiMessageDeletionCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiMessageDeletionCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiMessageDeletionCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffimessagedeletioncallback(UniffiCallbackInterfaceFfiMessageDeletionCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageDeletionCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiMessageDeletionCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiMessageDeletionCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiMessageDeletionCallback {
        return FfiMessageDeletionCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiMessageDeletionCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageDeletionCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiMessageDeletionCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageDeletionCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiMessageDeletionCallback {
    return try FfiConverterTypeFfiMessageDeletionCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageDeletionCallback_lower(_ value: FfiMessageDeletionCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiMessageDeletionCallback.lower(value)
}






public protocol FfiPreferenceCallback: AnyObject, Sendable {
    
    func onPreferenceUpdate(preference: [FfiPreferenceUpdate]) 
    
    func onError(error: FfiError) 
    
    func onClose() 
    
}
open class FfiPreferenceCallbackImpl: FfiPreferenceCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffipreferencecallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffipreferencecallback(pointer, $0) }
    }

    

    
open func onPreferenceUpdate(preference: [FfiPreferenceUpdate])  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffipreferencecallback_on_preference_update(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFfiPreferenceUpdate.lower(preference),$0
    )
}
}
    
open func onError(error: FfiError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffipreferencecallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffipreferencecallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiPreferenceCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiPreferenceCallback] = [UniffiVTableCallbackInterfaceFfiPreferenceCallback(
        onPreferenceUpdate: { (
            uniffiHandle: UInt64,
            preference: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiPreferenceCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onPreferenceUpdate(
                     preference: try FfiConverterSequenceTypeFfiPreferenceUpdate.lift(preference)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiPreferenceCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiPreferenceCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiPreferenceCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiPreferenceCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiPreferenceCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffipreferencecallback(UniffiCallbackInterfaceFfiPreferenceCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPreferenceCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiPreferenceCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiPreferenceCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiPreferenceCallback {
        return FfiPreferenceCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiPreferenceCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPreferenceCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiPreferenceCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiPreferenceCallback {
    return try FfiConverterTypeFfiPreferenceCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceCallback_lower(_ value: FfiPreferenceCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiPreferenceCallback.lower(value)
}






public protocol FfiSignatureRequestProtocol: AnyObject, Sendable {
    
    func addEcdsaSignature(signatureBytes: Data) async throws 
    
    func addPasskeySignature(signature: FfiPasskeySignature) async throws 
    
    func addScwSignature(signatureBytes: Data, address: String, chainId: UInt64, blockNumber: UInt64?) async throws 
    
    func isReady() async  -> Bool
    
    /**
     * missing signatures that are from `MemberKind::Address`
     */
    func missingAddressSignatures() async throws  -> [String]
    
    func signatureText() async throws  -> String
    
}
open class FfiSignatureRequest: FfiSignatureRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffisignaturerequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffisignaturerequest(pointer, $0) }
    }

    

    
open func addEcdsaSignature(signatureBytes: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_add_ecdsa_signature(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(signatureBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func addPasskeySignature(signature: FfiPasskeySignature)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_add_passkey_signature(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiPasskeySignature_lower(signature)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func addScwSignature(signatureBytes: Data, address: String, chainId: UInt64, blockNumber: UInt64?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_add_scw_signature(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(signatureBytes),FfiConverterString.lower(address),FfiConverterUInt64.lower(chainId),FfiConverterOptionUInt64.lower(blockNumber)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func isReady()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_is_ready(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_i8,
            completeFunc: ffi_xmtpv3_rust_future_complete_i8,
            freeFunc: ffi_xmtpv3_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * missing signatures that are from `MemberKind::Address`
     */
open func missingAddressSignatures()async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_missing_address_signatures(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func signatureText()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_signature_text(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSignatureRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiSignatureRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSignatureRequest {
        return FfiSignatureRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiSignatureRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSignatureRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiSignatureRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignatureRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSignatureRequest {
    return try FfiConverterTypeFfiSignatureRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignatureRequest_lower(_ value: FfiSignatureRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiSignatureRequest.lower(value)
}






public protocol FfiStreamCloserProtocol: AnyObject, Sendable {
    
    /**
     * Signal the stream to end
     * Does not wait for the stream to end.
     */
    func end() 
    
    /**
     * End the stream and asynchronously wait for it to shutdown
     */
    func endAndWait() async throws 
    
    func isClosed()  -> Bool
    
    func waitForReady() async 
    
}
open class FfiStreamCloser: FfiStreamCloserProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffistreamcloser(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffistreamcloser(pointer, $0) }
    }

    

    
    /**
     * Signal the stream to end
     * Does not wait for the stream to end.
     */
open func end()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffistreamcloser_end(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * End the stream and asynchronously wait for it to shutdown
     */
open func endAndWait()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffistreamcloser_end_and_wait(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func isClosed() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed(self.uniffiClonePointer(),$0
    )
})
}
    
open func waitForReady()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffistreamcloser_wait_for_ready(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiStreamCloser: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiStreamCloser

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
        return FfiStreamCloser(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiStreamCloser {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiStreamCloser, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiStreamCloser_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
    return try FfiConverterTypeFfiStreamCloser.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiStreamCloser_lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiStreamCloser.lower(value)
}






public protocol FfiSyncWorkerProtocol: AnyObject, Sendable {
    
    func wait(metric: FfiSyncMetric, count: UInt64) async throws 
    
}
open class FfiSyncWorker: FfiSyncWorkerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffisyncworker(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffisyncworker(pointer, $0) }
    }

    

    
open func wait(metric: FfiSyncMetric, count: UInt64)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisyncworker_wait(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiSyncMetric_lower(metric),FfiConverterUInt64.lower(count)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSyncWorker: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiSyncWorker

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSyncWorker {
        return FfiSyncWorker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiSyncWorker) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSyncWorker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiSyncWorker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncWorker_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSyncWorker {
    return try FfiConverterTypeFfiSyncWorker.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncWorker_lower(_ value: FfiSyncWorker) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiSyncWorker.lower(value)
}






public protocol FfiXmtpClientProtocol: AnyObject, Sendable {
    
    /**
     * Adds a wallet address to the existing client
     */
    func addIdentity(newIdentity: FfiIdentifier) async throws  -> FfiSignatureRequest
    
    /**
     * * Get the inbox state for each `inbox_id`.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
    func addressesFromInboxId(refreshFromNetwork: Bool, inboxIds: [String]) async throws  -> [FfiInboxState]
    
    func apiAggregateStatistics()  -> String
    
    func apiIdentityStatistics()  -> FfiIdentityStats
    
    func apiStatistics()  -> FfiApiStats
    
    func applySignatureRequest(signatureRequest: FfiSignatureRequest) async throws 
    
    /**
     * Load the metadata for an archive to see what it contains.
     * Reads only the metadata without loading the entire file, so this function is quick.
     */
    func archiveMetadata(path: String, key: Data) async throws  -> FfiBackupMetadata
    
    func canMessage(accountIdentifiers: [FfiIdentifier]) async throws  -> [FfiIdentifier: Bool]
    
    /**
     * * Change the recovery identifier for your inboxId
     */
    func changeRecoveryIdentifier(newRecoveryIdentifier: FfiIdentifier) async throws  -> FfiSignatureRequest
    
    func clearAllStatistics() 
    
    func conversation(conversationId: Data) throws  -> FfiConversation
    
    func conversations()  -> FfiConversations
    
    /**
     * Archive application elements to file for later restoration.
     */
    func createArchive(path: String, opts: FfiArchiveOptions, key: Data) async throws  -> FfiBackupMetadata
    
    func dbReconnect() async throws 
    
    func deleteMessage(messageId: Data) throws  -> UInt32
    
    func dmConversation(targetInboxId: String) throws  -> FfiConversation
    
    func enrichedMessage(messageId: Data) throws  -> FfiDecodedMessage
    
    func fetchInboxUpdatesCount(refreshFromNetwork: Bool, inboxIds: [String]) async throws  -> [String: UInt32]
    
    func fetchOwnInboxUpdatesCount(refreshFromNetwork: Bool) async throws  -> UInt32
    
    func findInboxId(identifier: FfiIdentifier) async throws  -> String?
    
    func getConsentState(entityType: FfiConsentEntityType, entity: String) async throws  -> FfiConsentState
    
    func getKeyPackageStatusesForInstallationIds(installationIds: [Data]) async throws  -> [Data: FfiKeyPackageStatus]
    
    func getLatestInboxState(inboxId: String) async throws  -> FfiInboxState
    
    /**
     * Import a previous archive from file.
     */
    func importArchive(path: String, key: Data) async throws 
    
    func inboxId()  -> String
    
    /**
     * * Get the client's inbox state.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
    func inboxState(refreshFromNetwork: Bool) async throws  -> FfiInboxState
    
    func installationId()  -> Data
    
    /**
     * List the archives available for import in the sync group.
     * You may need to manually sync the sync group before calling
     * this function to see recently uploaded archives.
     */
    func listAvailableArchives(daysCutoff: Int64) throws  -> [FfiAvailableArchive]
    
    func message(messageId: Data) throws  -> FfiMessage
    
    /**
     * Manually process a sync archive that matches the pin given.
     * If no pin is given, then it will process the last archive sent.
     */
    func processSyncArchive(archivePin: String?) async throws 
    
    func registerIdentity(signatureRequest: FfiSignatureRequest) async throws 
    
    func releaseDbConnection() throws 
    
    /**
     * * Revokes all installations except the one the client is currently using
     *      * Returns Some FfiSignatureRequest if we have installations to revoke.
     *      * If we have no other installations to revoke, returns None.
     */
    func revokeAllOtherInstallationsSignatureRequest() async throws  -> FfiSignatureRequest?
    
    /**
     * Revokes or removes an identity from the existing client
     */
    func revokeIdentity(identifier: FfiIdentifier) async throws  -> FfiSignatureRequest
    
    /**
     * * Revoke a list of installations
     */
    func revokeInstallations(installationIds: [Data]) async throws  -> FfiSignatureRequest
    
    /**
     * Manually send a sync archive to the sync group.
     * The pin will be later used as a reference when importing.
     */
    func sendSyncArchive(options: FfiArchiveOptions, serverUrl: String, pin: String) async throws 
    
    /**
     * Manually trigger a device sync request to sync records from another active device on this account.
     */
    func sendSyncRequest(options: FfiArchiveOptions, serverUrl: String) async throws 
    
    func setConsentStates(records: [FfiConsent]) async throws 
    
    /**
     * A utility function to sign a piece of text with this installation's private key.
     */
    func signWithInstallationKey(text: String) throws  -> Data
    
    func signatureRequest()  -> FfiSignatureRequest?
    
    /**
     * Manually sync all device sync groups.
     */
    func syncAllDeviceSyncGroups() async throws  -> FfiGroupSyncSummary
    
    func syncPreferences() async throws  -> FfiGroupSyncSummary
    
    /**
     * A utility function to easily verify that a piece of text was signed by this installation.
     */
    func verifySignedWithInstallationKey(signatureText: String, signatureBytes: Data) throws 
    
    /**
     * A utility function to easily verify that a string has been signed by another libXmtp installation.
     * Only works for verifying libXmtp public context signatures.
     */
    func verifySignedWithPublicKey(signatureText: String, signatureBytes: Data, publicKey: Data) throws 
    
}
open class FfiXmtpClient: FfiXmtpClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffixmtpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffixmtpclient(pointer, $0) }
    }

    

    
    /**
     * Adds a wallet address to the existing client
     */
open func addIdentity(newIdentity: FfiIdentifier)async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_add_identity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(newIdentity)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * * Get the inbox state for each `inbox_id`.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
open func addressesFromInboxId(refreshFromNetwork: Bool, inboxIds: [String])async throws  -> [FfiInboxState]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_addresses_from_inbox_id(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(refreshFromNetwork),FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiInboxState.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func apiAggregateStatistics() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_api_aggregate_statistics(self.uniffiClonePointer(),$0
    )
})
}
    
open func apiIdentityStatistics() -> FfiIdentityStats  {
    return try!  FfiConverterTypeFfiIdentityStats_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_api_identity_statistics(self.uniffiClonePointer(),$0
    )
})
}
    
open func apiStatistics() -> FfiApiStats  {
    return try!  FfiConverterTypeFfiApiStats_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_api_statistics(self.uniffiClonePointer(),$0
    )
})
}
    
open func applySignatureRequest(signatureRequest: FfiSignatureRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_apply_signature_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiSignatureRequest_lower(signatureRequest)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * Load the metadata for an archive to see what it contains.
     * Reads only the metadata without loading the entire file, so this function is quick.
     */
open func archiveMetadata(path: String, key: Data)async throws  -> FfiBackupMetadata  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_archive_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path),FfiConverterData.lower(key)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiBackupMetadata_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func canMessage(accountIdentifiers: [FfiIdentifier])async throws  -> [FfiIdentifier: Bool]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_can_message(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentifiers)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryTypeFfiIdentifierBool.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * * Change the recovery identifier for your inboxId
     */
open func changeRecoveryIdentifier(newRecoveryIdentifier: FfiIdentifier)async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_change_recovery_identifier(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(newRecoveryIdentifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func clearAllStatistics()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_clear_all_statistics(self.uniffiClonePointer(),$0
    )
}
}
    
open func conversation(conversationId: Data)throws  -> FfiConversation  {
    return try  FfiConverterTypeFfiConversation_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_conversation(self.uniffiClonePointer(),
        FfiConverterData.lower(conversationId),$0
    )
})
}
    
open func conversations() -> FfiConversations  {
    return try!  FfiConverterTypeFfiConversations_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_conversations(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Archive application elements to file for later restoration.
     */
open func createArchive(path: String, opts: FfiArchiveOptions, key: Data)async throws  -> FfiBackupMetadata  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_create_archive(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path),FfiConverterTypeFfiArchiveOptions_lower(opts),FfiConverterData.lower(key)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiBackupMetadata_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func dbReconnect()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_db_reconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func deleteMessage(messageId: Data)throws  -> UInt32  {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_delete_message(self.uniffiClonePointer(),
        FfiConverterData.lower(messageId),$0
    )
})
}
    
open func dmConversation(targetInboxId: String)throws  -> FfiConversation  {
    return try  FfiConverterTypeFfiConversation_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_dm_conversation(self.uniffiClonePointer(),
        FfiConverterString.lower(targetInboxId),$0
    )
})
}
    
open func enrichedMessage(messageId: Data)throws  -> FfiDecodedMessage  {
    return try  FfiConverterTypeFfiDecodedMessage_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_enriched_message(self.uniffiClonePointer(),
        FfiConverterData.lower(messageId),$0
    )
})
}
    
open func fetchInboxUpdatesCount(refreshFromNetwork: Bool, inboxIds: [String])async throws  -> [String: UInt32]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_fetch_inbox_updates_count(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(refreshFromNetwork),FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringUInt32.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func fetchOwnInboxUpdatesCount(refreshFromNetwork: Bool)async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_fetch_own_inbox_updates_count(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(refreshFromNetwork)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_u32,
            completeFunc: ffi_xmtpv3_rust_future_complete_u32,
            freeFunc: ffi_xmtpv3_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func findInboxId(identifier: FfiIdentifier)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_find_inbox_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(identifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func getConsentState(entityType: FfiConsentEntityType, entity: String)async throws  -> FfiConsentState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_get_consent_state(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConsentEntityType_lower(entityType),FfiConverterString.lower(entity)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiConsentState_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func getKeyPackageStatusesForInstallationIds(installationIds: [Data])async throws  -> [Data: FfiKeyPackageStatus]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_get_key_package_statuses_for_installation_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceData.lower(installationIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryDataTypeFfiKeyPackageStatus.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func getLatestInboxState(inboxId: String)async throws  -> FfiInboxState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_get_latest_inbox_state(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiInboxState_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * Import a previous archive from file.
     */
open func importArchive(path: String, key: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_import_archive(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path),FfiConverterData.lower(key)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func inboxId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * * Get the client's inbox state.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
open func inboxState(refreshFromNetwork: Bool)async throws  -> FfiInboxState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_state(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(refreshFromNetwork)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiInboxState_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func installationId() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_installation_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List the archives available for import in the sync group.
     * You may need to manually sync the sync group before calling
     * this function to see recently uploaded archives.
     */
open func listAvailableArchives(daysCutoff: Int64)throws  -> [FfiAvailableArchive]  {
    return try  FfiConverterSequenceTypeFfiAvailableArchive.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_list_available_archives(self.uniffiClonePointer(),
        FfiConverterInt64.lower(daysCutoff),$0
    )
})
}
    
open func message(messageId: Data)throws  -> FfiMessage  {
    return try  FfiConverterTypeFfiMessage_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_message(self.uniffiClonePointer(),
        FfiConverterData.lower(messageId),$0
    )
})
}
    
    /**
     * Manually process a sync archive that matches the pin given.
     * If no pin is given, then it will process the last archive sent.
     */
open func processSyncArchive(archivePin: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_process_sync_archive(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(archivePin)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func registerIdentity(signatureRequest: FfiSignatureRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiSignatureRequest_lower(signatureRequest)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func releaseDbConnection()throws   {try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_release_db_connection(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * * Revokes all installations except the one the client is currently using
     *      * Returns Some FfiSignatureRequest if we have installations to revoke.
     *      * If we have no other installations to revoke, returns None.
     */
open func revokeAllOtherInstallationsSignatureRequest()async throws  -> FfiSignatureRequest?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_all_other_installations_signature_request(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeFfiSignatureRequest.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * Revokes or removes an identity from the existing client
     */
open func revokeIdentity(identifier: FfiIdentifier)async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_identity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(identifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * * Revoke a list of installations
     */
open func revokeInstallations(installationIds: [Data])async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_installations(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceData.lower(installationIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * Manually send a sync archive to the sync group.
     * The pin will be later used as a reference when importing.
     */
open func sendSyncArchive(options: FfiArchiveOptions, serverUrl: String, pin: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_send_sync_archive(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiArchiveOptions_lower(options),FfiConverterString.lower(serverUrl),FfiConverterString.lower(pin)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * Manually trigger a device sync request to sync records from another active device on this account.
     */
open func sendSyncRequest(options: FfiArchiveOptions, serverUrl: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_send_sync_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiArchiveOptions_lower(options),FfiConverterString.lower(serverUrl)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func setConsentStates(records: [FfiConsent])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_set_consent_states(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiConsent.lower(records)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * A utility function to sign a piece of text with this installation's private key.
     */
open func signWithInstallationKey(text: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_sign_with_installation_key(self.uniffiClonePointer(),
        FfiConverterString.lower(text),$0
    )
})
}
    
open func signatureRequest() -> FfiSignatureRequest?  {
    return try!  FfiConverterOptionTypeFfiSignatureRequest.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_signature_request(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Manually sync all device sync groups.
     */
open func syncAllDeviceSyncGroups()async throws  -> FfiGroupSyncSummary  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_sync_all_device_sync_groups(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiGroupSyncSummary_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
open func syncPreferences()async throws  -> FfiGroupSyncSummary  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_sync_preferences(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiGroupSyncSummary_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
    
    /**
     * A utility function to easily verify that a piece of text was signed by this installation.
     */
open func verifySignedWithInstallationKey(signatureText: String, signatureBytes: Data)throws   {try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_installation_key(self.uniffiClonePointer(),
        FfiConverterString.lower(signatureText),
        FfiConverterData.lower(signatureBytes),$0
    )
}
}
    
    /**
     * A utility function to easily verify that a string has been signed by another libXmtp installation.
     * Only works for verifying libXmtp public context signatures.
     */
open func verifySignedWithPublicKey(signatureText: String, signatureBytes: Data, publicKey: Data)throws   {try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_public_key(self.uniffiClonePointer(),
        FfiConverterString.lower(signatureText),
        FfiConverterData.lower(signatureBytes),
        FfiConverterData.lower(publicKey),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiXmtpClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiXmtpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
        return FfiXmtpClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiXmtpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiXmtpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiXmtpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
    return try FfiConverterTypeFfiXmtpClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiXmtpClient_lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiXmtpClient.lower(value)
}






/**
 * the opaque Xmtp Api Client for iOS/Android bindings
 */
public protocol XmtpApiClientProtocol: AnyObject, Sendable {
    
}
/**
 * the opaque Xmtp Api Client for iOS/Android bindings
 */
open class XmtpApiClient: XmtpApiClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_xmtpapiclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_xmtpapiclient(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeXmtpApiClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = XmtpApiClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> XmtpApiClient {
        return XmtpApiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: XmtpApiClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> XmtpApiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: XmtpApiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXmtpApiClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> XmtpApiClient {
    return try FfiConverterTypeXmtpApiClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXmtpApiClient_lower(_ value: XmtpApiClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeXmtpApiClient.lower(value)
}




public struct DbOptions {
    public var db: String?
    public var encryptionKey: Data?
    public var maxDbPoolSize: UInt32?
    public var minDbPoolSize: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(db: String?, encryptionKey: Data?, maxDbPoolSize: UInt32?, minDbPoolSize: UInt32?) {
        self.db = db
        self.encryptionKey = encryptionKey
        self.maxDbPoolSize = maxDbPoolSize
        self.minDbPoolSize = minDbPoolSize
    }
}

#if compiler(>=6)
extension DbOptions: Sendable {}
#endif


extension DbOptions: Equatable, Hashable {
    public static func ==(lhs: DbOptions, rhs: DbOptions) -> Bool {
        if lhs.db != rhs.db {
            return false
        }
        if lhs.encryptionKey != rhs.encryptionKey {
            return false
        }
        if lhs.maxDbPoolSize != rhs.maxDbPoolSize {
            return false
        }
        if lhs.minDbPoolSize != rhs.minDbPoolSize {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(db)
        hasher.combine(encryptionKey)
        hasher.combine(maxDbPoolSize)
        hasher.combine(minDbPoolSize)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDbOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DbOptions {
        return
            try DbOptions(
                db: FfiConverterOptionString.read(from: &buf), 
                encryptionKey: FfiConverterOptionData.read(from: &buf), 
                maxDbPoolSize: FfiConverterOptionUInt32.read(from: &buf), 
                minDbPoolSize: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: DbOptions, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.db, into: &buf)
        FfiConverterOptionData.write(value.encryptionKey, into: &buf)
        FfiConverterOptionUInt32.write(value.maxDbPoolSize, into: &buf)
        FfiConverterOptionUInt32.write(value.minDbPoolSize, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDbOptions_lift(_ buf: RustBuffer) throws -> DbOptions {
    return try FfiConverterTypeDbOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDbOptions_lower(_ value: DbOptions) -> RustBuffer {
    return FfiConverterTypeDbOptions.lower(value)
}


public struct FfiAction {
    public var id: String
    public var label: String
    public var imageUrl: String?
    public var style: FfiActionStyle?
    public var expiresAtNs: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, label: String, imageUrl: String?, style: FfiActionStyle?, expiresAtNs: Int64?) {
        self.id = id
        self.label = label
        self.imageUrl = imageUrl
        self.style = style
        self.expiresAtNs = expiresAtNs
    }
}

#if compiler(>=6)
extension FfiAction: Sendable {}
#endif


extension FfiAction: Equatable, Hashable {
    public static func ==(lhs: FfiAction, rhs: FfiAction) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.imageUrl != rhs.imageUrl {
            return false
        }
        if lhs.style != rhs.style {
            return false
        }
        if lhs.expiresAtNs != rhs.expiresAtNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(label)
        hasher.combine(imageUrl)
        hasher.combine(style)
        hasher.combine(expiresAtNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiAction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiAction {
        return
            try FfiAction(
                id: FfiConverterString.read(from: &buf), 
                label: FfiConverterString.read(from: &buf), 
                imageUrl: FfiConverterOptionString.read(from: &buf), 
                style: FfiConverterOptionTypeFfiActionStyle.read(from: &buf), 
                expiresAtNs: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiAction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.imageUrl, into: &buf)
        FfiConverterOptionTypeFfiActionStyle.write(value.style, into: &buf)
        FfiConverterOptionInt64.write(value.expiresAtNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAction_lift(_ buf: RustBuffer) throws -> FfiAction {
    return try FfiConverterTypeFfiAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAction_lower(_ value: FfiAction) -> RustBuffer {
    return FfiConverterTypeFfiAction.lower(value)
}


public struct FfiActions {
    public var id: String
    public var description: String
    public var actions: [FfiAction]
    public var expiresAtNs: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, description: String, actions: [FfiAction], expiresAtNs: Int64?) {
        self.id = id
        self.description = description
        self.actions = actions
        self.expiresAtNs = expiresAtNs
    }
}

#if compiler(>=6)
extension FfiActions: Sendable {}
#endif


extension FfiActions: Equatable, Hashable {
    public static func ==(lhs: FfiActions, rhs: FfiActions) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.actions != rhs.actions {
            return false
        }
        if lhs.expiresAtNs != rhs.expiresAtNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(description)
        hasher.combine(actions)
        hasher.combine(expiresAtNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiActions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiActions {
        return
            try FfiActions(
                id: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                actions: FfiConverterSequenceTypeFfiAction.read(from: &buf), 
                expiresAtNs: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiActions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterSequenceTypeFfiAction.write(value.actions, into: &buf)
        FfiConverterOptionInt64.write(value.expiresAtNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiActions_lift(_ buf: RustBuffer) throws -> FfiActions {
    return try FfiConverterTypeFfiActions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiActions_lower(_ value: FfiActions) -> RustBuffer {
    return FfiConverterTypeFfiActions.lower(value)
}


public struct FfiApiStats {
    public var uploadKeyPackage: UInt64
    public var fetchKeyPackage: UInt64
    public var sendGroupMessages: UInt64
    public var sendWelcomeMessages: UInt64
    public var queryGroupMessages: UInt64
    public var queryWelcomeMessages: UInt64
    public var subscribeMessages: UInt64
    public var subscribeWelcomes: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uploadKeyPackage: UInt64, fetchKeyPackage: UInt64, sendGroupMessages: UInt64, sendWelcomeMessages: UInt64, queryGroupMessages: UInt64, queryWelcomeMessages: UInt64, subscribeMessages: UInt64, subscribeWelcomes: UInt64) {
        self.uploadKeyPackage = uploadKeyPackage
        self.fetchKeyPackage = fetchKeyPackage
        self.sendGroupMessages = sendGroupMessages
        self.sendWelcomeMessages = sendWelcomeMessages
        self.queryGroupMessages = queryGroupMessages
        self.queryWelcomeMessages = queryWelcomeMessages
        self.subscribeMessages = subscribeMessages
        self.subscribeWelcomes = subscribeWelcomes
    }
}

#if compiler(>=6)
extension FfiApiStats: Sendable {}
#endif


extension FfiApiStats: Equatable, Hashable {
    public static func ==(lhs: FfiApiStats, rhs: FfiApiStats) -> Bool {
        if lhs.uploadKeyPackage != rhs.uploadKeyPackage {
            return false
        }
        if lhs.fetchKeyPackage != rhs.fetchKeyPackage {
            return false
        }
        if lhs.sendGroupMessages != rhs.sendGroupMessages {
            return false
        }
        if lhs.sendWelcomeMessages != rhs.sendWelcomeMessages {
            return false
        }
        if lhs.queryGroupMessages != rhs.queryGroupMessages {
            return false
        }
        if lhs.queryWelcomeMessages != rhs.queryWelcomeMessages {
            return false
        }
        if lhs.subscribeMessages != rhs.subscribeMessages {
            return false
        }
        if lhs.subscribeWelcomes != rhs.subscribeWelcomes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uploadKeyPackage)
        hasher.combine(fetchKeyPackage)
        hasher.combine(sendGroupMessages)
        hasher.combine(sendWelcomeMessages)
        hasher.combine(queryGroupMessages)
        hasher.combine(queryWelcomeMessages)
        hasher.combine(subscribeMessages)
        hasher.combine(subscribeWelcomes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiApiStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiApiStats {
        return
            try FfiApiStats(
                uploadKeyPackage: FfiConverterUInt64.read(from: &buf), 
                fetchKeyPackage: FfiConverterUInt64.read(from: &buf), 
                sendGroupMessages: FfiConverterUInt64.read(from: &buf), 
                sendWelcomeMessages: FfiConverterUInt64.read(from: &buf), 
                queryGroupMessages: FfiConverterUInt64.read(from: &buf), 
                queryWelcomeMessages: FfiConverterUInt64.read(from: &buf), 
                subscribeMessages: FfiConverterUInt64.read(from: &buf), 
                subscribeWelcomes: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiApiStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.uploadKeyPackage, into: &buf)
        FfiConverterUInt64.write(value.fetchKeyPackage, into: &buf)
        FfiConverterUInt64.write(value.sendGroupMessages, into: &buf)
        FfiConverterUInt64.write(value.sendWelcomeMessages, into: &buf)
        FfiConverterUInt64.write(value.queryGroupMessages, into: &buf)
        FfiConverterUInt64.write(value.queryWelcomeMessages, into: &buf)
        FfiConverterUInt64.write(value.subscribeMessages, into: &buf)
        FfiConverterUInt64.write(value.subscribeWelcomes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApiStats_lift(_ buf: RustBuffer) throws -> FfiApiStats {
    return try FfiConverterTypeFfiApiStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApiStats_lower(_ value: FfiApiStats) -> RustBuffer {
    return FfiConverterTypeFfiApiStats.lower(value)
}


public struct FfiArchiveOptions {
    public var startNs: Int64?
    public var endNs: Int64?
    public var elements: [FfiBackupElementSelection]
    public var excludeDisappearingMessages: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(startNs: Int64?, endNs: Int64?, elements: [FfiBackupElementSelection], excludeDisappearingMessages: Bool) {
        self.startNs = startNs
        self.endNs = endNs
        self.elements = elements
        self.excludeDisappearingMessages = excludeDisappearingMessages
    }
}

#if compiler(>=6)
extension FfiArchiveOptions: Sendable {}
#endif


extension FfiArchiveOptions: Equatable, Hashable {
    public static func ==(lhs: FfiArchiveOptions, rhs: FfiArchiveOptions) -> Bool {
        if lhs.startNs != rhs.startNs {
            return false
        }
        if lhs.endNs != rhs.endNs {
            return false
        }
        if lhs.elements != rhs.elements {
            return false
        }
        if lhs.excludeDisappearingMessages != rhs.excludeDisappearingMessages {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(startNs)
        hasher.combine(endNs)
        hasher.combine(elements)
        hasher.combine(excludeDisappearingMessages)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiArchiveOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiArchiveOptions {
        return
            try FfiArchiveOptions(
                startNs: FfiConverterOptionInt64.read(from: &buf), 
                endNs: FfiConverterOptionInt64.read(from: &buf), 
                elements: FfiConverterSequenceTypeFfiBackupElementSelection.read(from: &buf), 
                excludeDisappearingMessages: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiArchiveOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.startNs, into: &buf)
        FfiConverterOptionInt64.write(value.endNs, into: &buf)
        FfiConverterSequenceTypeFfiBackupElementSelection.write(value.elements, into: &buf)
        FfiConverterBool.write(value.excludeDisappearingMessages, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiArchiveOptions_lift(_ buf: RustBuffer) throws -> FfiArchiveOptions {
    return try FfiConverterTypeFfiArchiveOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiArchiveOptions_lower(_ value: FfiArchiveOptions) -> RustBuffer {
    return FfiConverterTypeFfiArchiveOptions.lower(value)
}


public struct FfiAttachment {
    public var filename: String?
    public var mimeType: String
    public var content: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(filename: String?, mimeType: String, content: Data) {
        self.filename = filename
        self.mimeType = mimeType
        self.content = content
    }
}

#if compiler(>=6)
extension FfiAttachment: Sendable {}
#endif


extension FfiAttachment: Equatable, Hashable {
    public static func ==(lhs: FfiAttachment, rhs: FfiAttachment) -> Bool {
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(filename)
        hasher.combine(mimeType)
        hasher.combine(content)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiAttachment {
        return
            try FfiAttachment(
                filename: FfiConverterOptionString.read(from: &buf), 
                mimeType: FfiConverterString.read(from: &buf), 
                content: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiAttachment, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterData.write(value.content, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAttachment_lift(_ buf: RustBuffer) throws -> FfiAttachment {
    return try FfiConverterTypeFfiAttachment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAttachment_lower(_ value: FfiAttachment) -> RustBuffer {
    return FfiConverterTypeFfiAttachment.lower(value)
}


public struct FfiAvailableArchive {
    public var pin: String
    public var metadata: FfiBackupMetadata
    public var sentByInstallation: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pin: String, metadata: FfiBackupMetadata, sentByInstallation: Data) {
        self.pin = pin
        self.metadata = metadata
        self.sentByInstallation = sentByInstallation
    }
}

#if compiler(>=6)
extension FfiAvailableArchive: Sendable {}
#endif


extension FfiAvailableArchive: Equatable, Hashable {
    public static func ==(lhs: FfiAvailableArchive, rhs: FfiAvailableArchive) -> Bool {
        if lhs.pin != rhs.pin {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.sentByInstallation != rhs.sentByInstallation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pin)
        hasher.combine(metadata)
        hasher.combine(sentByInstallation)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiAvailableArchive: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiAvailableArchive {
        return
            try FfiAvailableArchive(
                pin: FfiConverterString.read(from: &buf), 
                metadata: FfiConverterTypeFfiBackupMetadata.read(from: &buf), 
                sentByInstallation: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiAvailableArchive, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pin, into: &buf)
        FfiConverterTypeFfiBackupMetadata.write(value.metadata, into: &buf)
        FfiConverterData.write(value.sentByInstallation, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAvailableArchive_lift(_ buf: RustBuffer) throws -> FfiAvailableArchive {
    return try FfiConverterTypeFfiAvailableArchive.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiAvailableArchive_lower(_ value: FfiAvailableArchive) -> RustBuffer {
    return FfiConverterTypeFfiAvailableArchive.lower(value)
}


public struct FfiBackupMetadata {
    public var backupVersion: UInt16
    public var elements: [FfiBackupElementSelection]
    public var exportedAtNs: Int64
    public var startNs: Int64?
    public var endNs: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backupVersion: UInt16, elements: [FfiBackupElementSelection], exportedAtNs: Int64, startNs: Int64?, endNs: Int64?) {
        self.backupVersion = backupVersion
        self.elements = elements
        self.exportedAtNs = exportedAtNs
        self.startNs = startNs
        self.endNs = endNs
    }
}

#if compiler(>=6)
extension FfiBackupMetadata: Sendable {}
#endif


extension FfiBackupMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiBackupMetadata, rhs: FfiBackupMetadata) -> Bool {
        if lhs.backupVersion != rhs.backupVersion {
            return false
        }
        if lhs.elements != rhs.elements {
            return false
        }
        if lhs.exportedAtNs != rhs.exportedAtNs {
            return false
        }
        if lhs.startNs != rhs.startNs {
            return false
        }
        if lhs.endNs != rhs.endNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(backupVersion)
        hasher.combine(elements)
        hasher.combine(exportedAtNs)
        hasher.combine(startNs)
        hasher.combine(endNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiBackupMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBackupMetadata {
        return
            try FfiBackupMetadata(
                backupVersion: FfiConverterUInt16.read(from: &buf), 
                elements: FfiConverterSequenceTypeFfiBackupElementSelection.read(from: &buf), 
                exportedAtNs: FfiConverterInt64.read(from: &buf), 
                startNs: FfiConverterOptionInt64.read(from: &buf), 
                endNs: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiBackupMetadata, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.backupVersion, into: &buf)
        FfiConverterSequenceTypeFfiBackupElementSelection.write(value.elements, into: &buf)
        FfiConverterInt64.write(value.exportedAtNs, into: &buf)
        FfiConverterOptionInt64.write(value.startNs, into: &buf)
        FfiConverterOptionInt64.write(value.endNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupMetadata_lift(_ buf: RustBuffer) throws -> FfiBackupMetadata {
    return try FfiConverterTypeFfiBackupMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupMetadata_lower(_ value: FfiBackupMetadata) -> RustBuffer {
    return FfiConverterTypeFfiBackupMetadata.lower(value)
}


public struct FfiConsent {
    public var entityType: FfiConsentEntityType
    public var state: FfiConsentState
    public var entity: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entityType: FfiConsentEntityType, state: FfiConsentState, entity: String) {
        self.entityType = entityType
        self.state = state
        self.entity = entity
    }
}

#if compiler(>=6)
extension FfiConsent: Sendable {}
#endif


extension FfiConsent: Equatable, Hashable {
    public static func ==(lhs: FfiConsent, rhs: FfiConsent) -> Bool {
        if lhs.entityType != rhs.entityType {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.entity != rhs.entity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entityType)
        hasher.combine(state)
        hasher.combine(entity)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsent {
        return
            try FfiConsent(
                entityType: FfiConverterTypeFfiConsentEntityType.read(from: &buf), 
                state: FfiConverterTypeFfiConsentState.read(from: &buf), 
                entity: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiConsent, into buf: inout [UInt8]) {
        FfiConverterTypeFfiConsentEntityType.write(value.entityType, into: &buf)
        FfiConverterTypeFfiConsentState.write(value.state, into: &buf)
        FfiConverterString.write(value.entity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsent_lift(_ buf: RustBuffer) throws -> FfiConsent {
    return try FfiConverterTypeFfiConsent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsent_lower(_ value: FfiConsent) -> RustBuffer {
    return FfiConverterTypeFfiConsent.lower(value)
}


public struct FfiContentTypeId {
    public var authorityId: String
    public var typeId: String
    public var versionMajor: UInt32
    public var versionMinor: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authorityId: String, typeId: String, versionMajor: UInt32, versionMinor: UInt32) {
        self.authorityId = authorityId
        self.typeId = typeId
        self.versionMajor = versionMajor
        self.versionMinor = versionMinor
    }
}

#if compiler(>=6)
extension FfiContentTypeId: Sendable {}
#endif


extension FfiContentTypeId: Equatable, Hashable {
    public static func ==(lhs: FfiContentTypeId, rhs: FfiContentTypeId) -> Bool {
        if lhs.authorityId != rhs.authorityId {
            return false
        }
        if lhs.typeId != rhs.typeId {
            return false
        }
        if lhs.versionMajor != rhs.versionMajor {
            return false
        }
        if lhs.versionMinor != rhs.versionMinor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authorityId)
        hasher.combine(typeId)
        hasher.combine(versionMajor)
        hasher.combine(versionMinor)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiContentTypeId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiContentTypeId {
        return
            try FfiContentTypeId(
                authorityId: FfiConverterString.read(from: &buf), 
                typeId: FfiConverterString.read(from: &buf), 
                versionMajor: FfiConverterUInt32.read(from: &buf), 
                versionMinor: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: FfiContentTypeId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.authorityId, into: &buf)
        FfiConverterString.write(value.typeId, into: &buf)
        FfiConverterUInt32.write(value.versionMajor, into: &buf)
        FfiConverterUInt32.write(value.versionMinor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiContentTypeId_lift(_ buf: RustBuffer) throws -> FfiContentTypeId {
    return try FfiConverterTypeFfiContentTypeId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiContentTypeId_lower(_ value: FfiContentTypeId) -> RustBuffer {
    return FfiConverterTypeFfiContentTypeId.lower(value)
}


public struct FfiConversationDebugInfo {
    public var epoch: UInt64
    public var maybeForked: Bool
    public var forkDetails: String
    public var isCommitLogForked: Bool?
    public var localCommitLog: String
    public var remoteCommitLog: String
    public var cursor: [FfiCursor]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(epoch: UInt64, maybeForked: Bool, forkDetails: String, isCommitLogForked: Bool?, localCommitLog: String, remoteCommitLog: String, cursor: [FfiCursor]) {
        self.epoch = epoch
        self.maybeForked = maybeForked
        self.forkDetails = forkDetails
        self.isCommitLogForked = isCommitLogForked
        self.localCommitLog = localCommitLog
        self.remoteCommitLog = remoteCommitLog
        self.cursor = cursor
    }
}

#if compiler(>=6)
extension FfiConversationDebugInfo: Sendable {}
#endif


extension FfiConversationDebugInfo: Equatable, Hashable {
    public static func ==(lhs: FfiConversationDebugInfo, rhs: FfiConversationDebugInfo) -> Bool {
        if lhs.epoch != rhs.epoch {
            return false
        }
        if lhs.maybeForked != rhs.maybeForked {
            return false
        }
        if lhs.forkDetails != rhs.forkDetails {
            return false
        }
        if lhs.isCommitLogForked != rhs.isCommitLogForked {
            return false
        }
        if lhs.localCommitLog != rhs.localCommitLog {
            return false
        }
        if lhs.remoteCommitLog != rhs.remoteCommitLog {
            return false
        }
        if lhs.cursor != rhs.cursor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(epoch)
        hasher.combine(maybeForked)
        hasher.combine(forkDetails)
        hasher.combine(isCommitLogForked)
        hasher.combine(localCommitLog)
        hasher.combine(remoteCommitLog)
        hasher.combine(cursor)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationDebugInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationDebugInfo {
        return
            try FfiConversationDebugInfo(
                epoch: FfiConverterUInt64.read(from: &buf), 
                maybeForked: FfiConverterBool.read(from: &buf), 
                forkDetails: FfiConverterString.read(from: &buf), 
                isCommitLogForked: FfiConverterOptionBool.read(from: &buf), 
                localCommitLog: FfiConverterString.read(from: &buf), 
                remoteCommitLog: FfiConverterString.read(from: &buf), 
                cursor: FfiConverterSequenceTypeFfiCursor.read(from: &buf)
        )
    }

    public static func write(_ value: FfiConversationDebugInfo, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterBool.write(value.maybeForked, into: &buf)
        FfiConverterString.write(value.forkDetails, into: &buf)
        FfiConverterOptionBool.write(value.isCommitLogForked, into: &buf)
        FfiConverterString.write(value.localCommitLog, into: &buf)
        FfiConverterString.write(value.remoteCommitLog, into: &buf)
        FfiConverterSequenceTypeFfiCursor.write(value.cursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationDebugInfo_lift(_ buf: RustBuffer) throws -> FfiConversationDebugInfo {
    return try FfiConverterTypeFfiConversationDebugInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationDebugInfo_lower(_ value: FfiConversationDebugInfo) -> RustBuffer {
    return FfiConverterTypeFfiConversationDebugInfo.lower(value)
}


public struct FfiConversationMember {
    public var inboxId: String
    public var accountIdentifiers: [FfiIdentifier]
    public var installationIds: [Data]
    public var permissionLevel: FfiPermissionLevel
    public var consentState: FfiConsentState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inboxId: String, accountIdentifiers: [FfiIdentifier], installationIds: [Data], permissionLevel: FfiPermissionLevel, consentState: FfiConsentState) {
        self.inboxId = inboxId
        self.accountIdentifiers = accountIdentifiers
        self.installationIds = installationIds
        self.permissionLevel = permissionLevel
        self.consentState = consentState
    }
}

#if compiler(>=6)
extension FfiConversationMember: Sendable {}
#endif


extension FfiConversationMember: Equatable, Hashable {
    public static func ==(lhs: FfiConversationMember, rhs: FfiConversationMember) -> Bool {
        if lhs.inboxId != rhs.inboxId {
            return false
        }
        if lhs.accountIdentifiers != rhs.accountIdentifiers {
            return false
        }
        if lhs.installationIds != rhs.installationIds {
            return false
        }
        if lhs.permissionLevel != rhs.permissionLevel {
            return false
        }
        if lhs.consentState != rhs.consentState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inboxId)
        hasher.combine(accountIdentifiers)
        hasher.combine(installationIds)
        hasher.combine(permissionLevel)
        hasher.combine(consentState)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationMember {
        return
            try FfiConversationMember(
                inboxId: FfiConverterString.read(from: &buf), 
                accountIdentifiers: FfiConverterSequenceTypeFfiIdentifier.read(from: &buf), 
                installationIds: FfiConverterSequenceData.read(from: &buf), 
                permissionLevel: FfiConverterTypeFfiPermissionLevel.read(from: &buf), 
                consentState: FfiConverterTypeFfiConsentState.read(from: &buf)
        )
    }

    public static func write(_ value: FfiConversationMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.inboxId, into: &buf)
        FfiConverterSequenceTypeFfiIdentifier.write(value.accountIdentifiers, into: &buf)
        FfiConverterSequenceData.write(value.installationIds, into: &buf)
        FfiConverterTypeFfiPermissionLevel.write(value.permissionLevel, into: &buf)
        FfiConverterTypeFfiConsentState.write(value.consentState, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMember_lift(_ buf: RustBuffer) throws -> FfiConversationMember {
    return try FfiConverterTypeFfiConversationMember.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMember_lower(_ value: FfiConversationMember) -> RustBuffer {
    return FfiConverterTypeFfiConversationMember.lower(value)
}


public struct FfiCreateDmOptions {
    public var messageDisappearingSettings: FfiMessageDisappearingSettings?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageDisappearingSettings: FfiMessageDisappearingSettings?) {
        self.messageDisappearingSettings = messageDisappearingSettings
    }
}

#if compiler(>=6)
extension FfiCreateDmOptions: Sendable {}
#endif


extension FfiCreateDmOptions: Equatable, Hashable {
    public static func ==(lhs: FfiCreateDmOptions, rhs: FfiCreateDmOptions) -> Bool {
        if lhs.messageDisappearingSettings != rhs.messageDisappearingSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageDisappearingSettings)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCreateDMOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCreateDmOptions {
        return
            try FfiCreateDmOptions(
                messageDisappearingSettings: FfiConverterOptionTypeFfiMessageDisappearingSettings.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCreateDmOptions, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiMessageDisappearingSettings.write(value.messageDisappearingSettings, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateDMOptions_lift(_ buf: RustBuffer) throws -> FfiCreateDmOptions {
    return try FfiConverterTypeFfiCreateDMOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateDMOptions_lower(_ value: FfiCreateDmOptions) -> RustBuffer {
    return FfiConverterTypeFfiCreateDMOptions.lower(value)
}


public struct FfiCreateGroupOptions {
    public var permissions: FfiGroupPermissionsOptions?
    public var groupName: String?
    public var groupImageUrlSquare: String?
    public var groupDescription: String?
    public var customPermissionPolicySet: FfiPermissionPolicySet?
    public var messageDisappearingSettings: FfiMessageDisappearingSettings?
    public var appData: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(permissions: FfiGroupPermissionsOptions?, groupName: String?, groupImageUrlSquare: String?, groupDescription: String?, customPermissionPolicySet: FfiPermissionPolicySet?, messageDisappearingSettings: FfiMessageDisappearingSettings?, appData: String?) {
        self.permissions = permissions
        self.groupName = groupName
        self.groupImageUrlSquare = groupImageUrlSquare
        self.groupDescription = groupDescription
        self.customPermissionPolicySet = customPermissionPolicySet
        self.messageDisappearingSettings = messageDisappearingSettings
        self.appData = appData
    }
}

#if compiler(>=6)
extension FfiCreateGroupOptions: Sendable {}
#endif


extension FfiCreateGroupOptions: Equatable, Hashable {
    public static func ==(lhs: FfiCreateGroupOptions, rhs: FfiCreateGroupOptions) -> Bool {
        if lhs.permissions != rhs.permissions {
            return false
        }
        if lhs.groupName != rhs.groupName {
            return false
        }
        if lhs.groupImageUrlSquare != rhs.groupImageUrlSquare {
            return false
        }
        if lhs.groupDescription != rhs.groupDescription {
            return false
        }
        if lhs.customPermissionPolicySet != rhs.customPermissionPolicySet {
            return false
        }
        if lhs.messageDisappearingSettings != rhs.messageDisappearingSettings {
            return false
        }
        if lhs.appData != rhs.appData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(permissions)
        hasher.combine(groupName)
        hasher.combine(groupImageUrlSquare)
        hasher.combine(groupDescription)
        hasher.combine(customPermissionPolicySet)
        hasher.combine(messageDisappearingSettings)
        hasher.combine(appData)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCreateGroupOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCreateGroupOptions {
        return
            try FfiCreateGroupOptions(
                permissions: FfiConverterOptionTypeFfiGroupPermissionsOptions.read(from: &buf), 
                groupName: FfiConverterOptionString.read(from: &buf), 
                groupImageUrlSquare: FfiConverterOptionString.read(from: &buf), 
                groupDescription: FfiConverterOptionString.read(from: &buf), 
                customPermissionPolicySet: FfiConverterOptionTypeFfiPermissionPolicySet.read(from: &buf), 
                messageDisappearingSettings: FfiConverterOptionTypeFfiMessageDisappearingSettings.read(from: &buf), 
                appData: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCreateGroupOptions, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiGroupPermissionsOptions.write(value.permissions, into: &buf)
        FfiConverterOptionString.write(value.groupName, into: &buf)
        FfiConverterOptionString.write(value.groupImageUrlSquare, into: &buf)
        FfiConverterOptionString.write(value.groupDescription, into: &buf)
        FfiConverterOptionTypeFfiPermissionPolicySet.write(value.customPermissionPolicySet, into: &buf)
        FfiConverterOptionTypeFfiMessageDisappearingSettings.write(value.messageDisappearingSettings, into: &buf)
        FfiConverterOptionString.write(value.appData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateGroupOptions_lift(_ buf: RustBuffer) throws -> FfiCreateGroupOptions {
    return try FfiConverterTypeFfiCreateGroupOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateGroupOptions_lower(_ value: FfiCreateGroupOptions) -> RustBuffer {
    return FfiConverterTypeFfiCreateGroupOptions.lower(value)
}


public struct FfiCredential {
    public var name: String?
    public var value: String
    public var expiresAtSeconds: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, value: String, expiresAtSeconds: Int64) {
        self.name = name
        self.value = value
        self.expiresAtSeconds = expiresAtSeconds
    }
}

#if compiler(>=6)
extension FfiCredential: Sendable {}
#endif


extension FfiCredential: Equatable, Hashable {
    public static func ==(lhs: FfiCredential, rhs: FfiCredential) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.expiresAtSeconds != rhs.expiresAtSeconds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
        hasher.combine(expiresAtSeconds)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCredential {
        return
            try FfiCredential(
                name: FfiConverterOptionString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf), 
                expiresAtSeconds: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCredential, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterInt64.write(value.expiresAtSeconds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCredential_lift(_ buf: RustBuffer) throws -> FfiCredential {
    return try FfiConverterTypeFfiCredential.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCredential_lower(_ value: FfiCredential) -> RustBuffer {
    return FfiConverterTypeFfiCredential.lower(value)
}


public struct FfiCursor {
    public var originatorId: UInt32
    public var sequenceId: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(originatorId: UInt32, sequenceId: UInt64) {
        self.originatorId = originatorId
        self.sequenceId = sequenceId
    }
}

#if compiler(>=6)
extension FfiCursor: Sendable {}
#endif


extension FfiCursor: Equatable, Hashable {
    public static func ==(lhs: FfiCursor, rhs: FfiCursor) -> Bool {
        if lhs.originatorId != rhs.originatorId {
            return false
        }
        if lhs.sequenceId != rhs.sequenceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(originatorId)
        hasher.combine(sequenceId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCursor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCursor {
        return
            try FfiCursor(
                originatorId: FfiConverterUInt32.read(from: &buf), 
                sequenceId: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCursor, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.originatorId, into: &buf)
        FfiConverterUInt64.write(value.sequenceId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCursor_lift(_ buf: RustBuffer) throws -> FfiCursor {
    return try FfiConverterTypeFfiCursor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCursor_lower(_ value: FfiCursor) -> RustBuffer {
    return FfiConverterTypeFfiCursor.lower(value)
}


public struct FfiDecodedMessageMetadata {
    public var id: Data
    public var sentAtNs: Int64
    public var kind: FfiGroupMessageKind
    public var senderInstallationId: Data
    public var senderInboxId: String
    public var contentType: FfiContentTypeId
    public var conversationId: Data
    public var insertedAtNs: Int64
    public var expiresAtNs: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, sentAtNs: Int64, kind: FfiGroupMessageKind, senderInstallationId: Data, senderInboxId: String, contentType: FfiContentTypeId, conversationId: Data, insertedAtNs: Int64, expiresAtNs: Int64?) {
        self.id = id
        self.sentAtNs = sentAtNs
        self.kind = kind
        self.senderInstallationId = senderInstallationId
        self.senderInboxId = senderInboxId
        self.contentType = contentType
        self.conversationId = conversationId
        self.insertedAtNs = insertedAtNs
        self.expiresAtNs = expiresAtNs
    }
}

#if compiler(>=6)
extension FfiDecodedMessageMetadata: Sendable {}
#endif


extension FfiDecodedMessageMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiDecodedMessageMetadata, rhs: FfiDecodedMessageMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.sentAtNs != rhs.sentAtNs {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.senderInstallationId != rhs.senderInstallationId {
            return false
        }
        if lhs.senderInboxId != rhs.senderInboxId {
            return false
        }
        if lhs.contentType != rhs.contentType {
            return false
        }
        if lhs.conversationId != rhs.conversationId {
            return false
        }
        if lhs.insertedAtNs != rhs.insertedAtNs {
            return false
        }
        if lhs.expiresAtNs != rhs.expiresAtNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(sentAtNs)
        hasher.combine(kind)
        hasher.combine(senderInstallationId)
        hasher.combine(senderInboxId)
        hasher.combine(contentType)
        hasher.combine(conversationId)
        hasher.combine(insertedAtNs)
        hasher.combine(expiresAtNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDecodedMessageMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDecodedMessageMetadata {
        return
            try FfiDecodedMessageMetadata(
                id: FfiConverterData.read(from: &buf), 
                sentAtNs: FfiConverterInt64.read(from: &buf), 
                kind: FfiConverterTypeFfiGroupMessageKind.read(from: &buf), 
                senderInstallationId: FfiConverterData.read(from: &buf), 
                senderInboxId: FfiConverterString.read(from: &buf), 
                contentType: FfiConverterTypeFfiContentTypeId.read(from: &buf), 
                conversationId: FfiConverterData.read(from: &buf), 
                insertedAtNs: FfiConverterInt64.read(from: &buf), 
                expiresAtNs: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiDecodedMessageMetadata, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterInt64.write(value.sentAtNs, into: &buf)
        FfiConverterTypeFfiGroupMessageKind.write(value.kind, into: &buf)
        FfiConverterData.write(value.senderInstallationId, into: &buf)
        FfiConverterString.write(value.senderInboxId, into: &buf)
        FfiConverterTypeFfiContentTypeId.write(value.contentType, into: &buf)
        FfiConverterData.write(value.conversationId, into: &buf)
        FfiConverterInt64.write(value.insertedAtNs, into: &buf)
        FfiConverterOptionInt64.write(value.expiresAtNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessageMetadata_lift(_ buf: RustBuffer) throws -> FfiDecodedMessageMetadata {
    return try FfiConverterTypeFfiDecodedMessageMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessageMetadata_lower(_ value: FfiDecodedMessageMetadata) -> RustBuffer {
    return FfiConverterTypeFfiDecodedMessageMetadata.lower(value)
}


/**
 * Represents a request to delete a message.
 */
public struct FfiDeleteMessage {
    /**
     * The ID of the message to delete
     */
    public var messageId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the message to delete
         */messageId: String) {
        self.messageId = messageId
    }
}

#if compiler(>=6)
extension FfiDeleteMessage: Sendable {}
#endif


extension FfiDeleteMessage: Equatable, Hashable {
    public static func ==(lhs: FfiDeleteMessage, rhs: FfiDeleteMessage) -> Bool {
        if lhs.messageId != rhs.messageId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDeleteMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeleteMessage {
        return
            try FfiDeleteMessage(
                messageId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiDeleteMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.messageId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeleteMessage_lift(_ buf: RustBuffer) throws -> FfiDeleteMessage {
    return try FfiConverterTypeFfiDeleteMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeleteMessage_lower(_ value: FfiDeleteMessage) -> RustBuffer {
    return FfiConverterTypeFfiDeleteMessage.lower(value)
}


public struct FfiDeletedMessage {
    public var deletedBy: FfiDeletedBy

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deletedBy: FfiDeletedBy) {
        self.deletedBy = deletedBy
    }
}

#if compiler(>=6)
extension FfiDeletedMessage: Sendable {}
#endif


extension FfiDeletedMessage: Equatable, Hashable {
    public static func ==(lhs: FfiDeletedMessage, rhs: FfiDeletedMessage) -> Bool {
        if lhs.deletedBy != rhs.deletedBy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deletedBy)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDeletedMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeletedMessage {
        return
            try FfiDeletedMessage(
                deletedBy: FfiConverterTypeFfiDeletedBy.read(from: &buf)
        )
    }

    public static func write(_ value: FfiDeletedMessage, into buf: inout [UInt8]) {
        FfiConverterTypeFfiDeletedBy.write(value.deletedBy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeletedMessage_lift(_ buf: RustBuffer) throws -> FfiDeletedMessage {
    return try FfiConverterTypeFfiDeletedMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeletedMessage_lower(_ value: FfiDeletedMessage) -> RustBuffer {
    return FfiConverterTypeFfiDeletedMessage.lower(value)
}


public struct FfiEncodedContent {
    public var typeId: FfiContentTypeId?
    public var parameters: [String: String]
    public var fallback: String?
    public var compression: Int32?
    public var content: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typeId: FfiContentTypeId?, parameters: [String: String], fallback: String?, compression: Int32?, content: Data) {
        self.typeId = typeId
        self.parameters = parameters
        self.fallback = fallback
        self.compression = compression
        self.content = content
    }
}

#if compiler(>=6)
extension FfiEncodedContent: Sendable {}
#endif


extension FfiEncodedContent: Equatable, Hashable {
    public static func ==(lhs: FfiEncodedContent, rhs: FfiEncodedContent) -> Bool {
        if lhs.typeId != rhs.typeId {
            return false
        }
        if lhs.parameters != rhs.parameters {
            return false
        }
        if lhs.fallback != rhs.fallback {
            return false
        }
        if lhs.compression != rhs.compression {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typeId)
        hasher.combine(parameters)
        hasher.combine(fallback)
        hasher.combine(compression)
        hasher.combine(content)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiEncodedContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiEncodedContent {
        return
            try FfiEncodedContent(
                typeId: FfiConverterOptionTypeFfiContentTypeId.read(from: &buf), 
                parameters: FfiConverterDictionaryStringString.read(from: &buf), 
                fallback: FfiConverterOptionString.read(from: &buf), 
                compression: FfiConverterOptionInt32.read(from: &buf), 
                content: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiEncodedContent, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiContentTypeId.write(value.typeId, into: &buf)
        FfiConverterDictionaryStringString.write(value.parameters, into: &buf)
        FfiConverterOptionString.write(value.fallback, into: &buf)
        FfiConverterOptionInt32.write(value.compression, into: &buf)
        FfiConverterData.write(value.content, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiEncodedContent_lift(_ buf: RustBuffer) throws -> FfiEncodedContent {
    return try FfiConverterTypeFfiEncodedContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiEncodedContent_lower(_ value: FfiEncodedContent) -> RustBuffer {
    return FfiConverterTypeFfiEncodedContent.lower(value)
}


public struct FfiEnrichedReply {
    public var inReplyTo: FfiDecodedMessage?
    public var content: FfiDecodedMessageBody?
    public var referenceId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inReplyTo: FfiDecodedMessage?, content: FfiDecodedMessageBody?, referenceId: String) {
        self.inReplyTo = inReplyTo
        self.content = content
        self.referenceId = referenceId
    }
}

#if compiler(>=6)
extension FfiEnrichedReply: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiEnrichedReply: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiEnrichedReply {
        return
            try FfiEnrichedReply(
                inReplyTo: FfiConverterOptionTypeFfiDecodedMessage.read(from: &buf), 
                content: FfiConverterOptionTypeFfiDecodedMessageBody.read(from: &buf), 
                referenceId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiEnrichedReply, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiDecodedMessage.write(value.inReplyTo, into: &buf)
        FfiConverterOptionTypeFfiDecodedMessageBody.write(value.content, into: &buf)
        FfiConverterString.write(value.referenceId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiEnrichedReply_lift(_ buf: RustBuffer) throws -> FfiEnrichedReply {
    return try FfiConverterTypeFfiEnrichedReply.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiEnrichedReply_lower(_ value: FfiEnrichedReply) -> RustBuffer {
    return FfiConverterTypeFfiEnrichedReply.lower(value)
}


public struct FfiErrorInfo {
    public var code: String
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: String, message: String) {
        self.code = code
        self.message = message
    }
}

#if compiler(>=6)
extension FfiErrorInfo: Sendable {}
#endif


extension FfiErrorInfo: Equatable, Hashable {
    public static func ==(lhs: FfiErrorInfo, rhs: FfiErrorInfo) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiErrorInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiErrorInfo {
        return
            try FfiErrorInfo(
                code: FfiConverterString.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiErrorInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiErrorInfo_lift(_ buf: RustBuffer) throws -> FfiErrorInfo {
    return try FfiConverterTypeFfiErrorInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiErrorInfo_lower(_ value: FfiErrorInfo) -> RustBuffer {
    return FfiConverterTypeFfiErrorInfo.lower(value)
}


public struct FfiForkRecoveryOpts {
    public var enableRecoveryRequests: FfiForkRecoveryPolicy
    public var groupsToRequestRecovery: [String]
    public var disableRecoveryResponses: Bool?
    public var workerIntervalNs: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(enableRecoveryRequests: FfiForkRecoveryPolicy, groupsToRequestRecovery: [String], disableRecoveryResponses: Bool?, workerIntervalNs: UInt64?) {
        self.enableRecoveryRequests = enableRecoveryRequests
        self.groupsToRequestRecovery = groupsToRequestRecovery
        self.disableRecoveryResponses = disableRecoveryResponses
        self.workerIntervalNs = workerIntervalNs
    }
}

#if compiler(>=6)
extension FfiForkRecoveryOpts: Sendable {}
#endif


extension FfiForkRecoveryOpts: Equatable, Hashable {
    public static func ==(lhs: FfiForkRecoveryOpts, rhs: FfiForkRecoveryOpts) -> Bool {
        if lhs.enableRecoveryRequests != rhs.enableRecoveryRequests {
            return false
        }
        if lhs.groupsToRequestRecovery != rhs.groupsToRequestRecovery {
            return false
        }
        if lhs.disableRecoveryResponses != rhs.disableRecoveryResponses {
            return false
        }
        if lhs.workerIntervalNs != rhs.workerIntervalNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(enableRecoveryRequests)
        hasher.combine(groupsToRequestRecovery)
        hasher.combine(disableRecoveryResponses)
        hasher.combine(workerIntervalNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiForkRecoveryOpts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiForkRecoveryOpts {
        return
            try FfiForkRecoveryOpts(
                enableRecoveryRequests: FfiConverterTypeFfiForkRecoveryPolicy.read(from: &buf), 
                groupsToRequestRecovery: FfiConverterSequenceString.read(from: &buf), 
                disableRecoveryResponses: FfiConverterOptionBool.read(from: &buf), 
                workerIntervalNs: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiForkRecoveryOpts, into buf: inout [UInt8]) {
        FfiConverterTypeFfiForkRecoveryPolicy.write(value.enableRecoveryRequests, into: &buf)
        FfiConverterSequenceString.write(value.groupsToRequestRecovery, into: &buf)
        FfiConverterOptionBool.write(value.disableRecoveryResponses, into: &buf)
        FfiConverterOptionUInt64.write(value.workerIntervalNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiForkRecoveryOpts_lift(_ buf: RustBuffer) throws -> FfiForkRecoveryOpts {
    return try FfiConverterTypeFfiForkRecoveryOpts.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiForkRecoveryOpts_lower(_ value: FfiForkRecoveryOpts) -> RustBuffer {
    return FfiConverterTypeFfiForkRecoveryOpts.lower(value)
}


public struct FfiGroupSyncSummary {
    public var numEligible: UInt64
    public var numSynced: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numEligible: UInt64, numSynced: UInt64) {
        self.numEligible = numEligible
        self.numSynced = numSynced
    }
}

#if compiler(>=6)
extension FfiGroupSyncSummary: Sendable {}
#endif


extension FfiGroupSyncSummary: Equatable, Hashable {
    public static func ==(lhs: FfiGroupSyncSummary, rhs: FfiGroupSyncSummary) -> Bool {
        if lhs.numEligible != rhs.numEligible {
            return false
        }
        if lhs.numSynced != rhs.numSynced {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numEligible)
        hasher.combine(numSynced)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupSyncSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupSyncSummary {
        return
            try FfiGroupSyncSummary(
                numEligible: FfiConverterUInt64.read(from: &buf), 
                numSynced: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiGroupSyncSummary, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.numEligible, into: &buf)
        FfiConverterUInt64.write(value.numSynced, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupSyncSummary_lift(_ buf: RustBuffer) throws -> FfiGroupSyncSummary {
    return try FfiConverterTypeFfiGroupSyncSummary.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupSyncSummary_lower(_ value: FfiGroupSyncSummary) -> RustBuffer {
    return FfiConverterTypeFfiGroupSyncSummary.lower(value)
}


public struct FfiGroupUpdated {
    public var initiatedByInboxId: String
    public var addedInboxes: [FfiInbox]
    public var removedInboxes: [FfiInbox]
    public var leftInboxes: [FfiInbox]
    public var metadataFieldChanges: [FfiMetadataFieldChange]
    public var addedAdminInboxes: [FfiInbox]
    public var removedAdminInboxes: [FfiInbox]
    public var addedSuperAdminInboxes: [FfiInbox]
    public var removedSuperAdminInboxes: [FfiInbox]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(initiatedByInboxId: String, addedInboxes: [FfiInbox], removedInboxes: [FfiInbox], leftInboxes: [FfiInbox], metadataFieldChanges: [FfiMetadataFieldChange], addedAdminInboxes: [FfiInbox], removedAdminInboxes: [FfiInbox], addedSuperAdminInboxes: [FfiInbox], removedSuperAdminInboxes: [FfiInbox]) {
        self.initiatedByInboxId = initiatedByInboxId
        self.addedInboxes = addedInboxes
        self.removedInboxes = removedInboxes
        self.leftInboxes = leftInboxes
        self.metadataFieldChanges = metadataFieldChanges
        self.addedAdminInboxes = addedAdminInboxes
        self.removedAdminInboxes = removedAdminInboxes
        self.addedSuperAdminInboxes = addedSuperAdminInboxes
        self.removedSuperAdminInboxes = removedSuperAdminInboxes
    }
}

#if compiler(>=6)
extension FfiGroupUpdated: Sendable {}
#endif


extension FfiGroupUpdated: Equatable, Hashable {
    public static func ==(lhs: FfiGroupUpdated, rhs: FfiGroupUpdated) -> Bool {
        if lhs.initiatedByInboxId != rhs.initiatedByInboxId {
            return false
        }
        if lhs.addedInboxes != rhs.addedInboxes {
            return false
        }
        if lhs.removedInboxes != rhs.removedInboxes {
            return false
        }
        if lhs.leftInboxes != rhs.leftInboxes {
            return false
        }
        if lhs.metadataFieldChanges != rhs.metadataFieldChanges {
            return false
        }
        if lhs.addedAdminInboxes != rhs.addedAdminInboxes {
            return false
        }
        if lhs.removedAdminInboxes != rhs.removedAdminInboxes {
            return false
        }
        if lhs.addedSuperAdminInboxes != rhs.addedSuperAdminInboxes {
            return false
        }
        if lhs.removedSuperAdminInboxes != rhs.removedSuperAdminInboxes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(initiatedByInboxId)
        hasher.combine(addedInboxes)
        hasher.combine(removedInboxes)
        hasher.combine(leftInboxes)
        hasher.combine(metadataFieldChanges)
        hasher.combine(addedAdminInboxes)
        hasher.combine(removedAdminInboxes)
        hasher.combine(addedSuperAdminInboxes)
        hasher.combine(removedSuperAdminInboxes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupUpdated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupUpdated {
        return
            try FfiGroupUpdated(
                initiatedByInboxId: FfiConverterString.read(from: &buf), 
                addedInboxes: FfiConverterSequenceTypeFfiInbox.read(from: &buf), 
                removedInboxes: FfiConverterSequenceTypeFfiInbox.read(from: &buf), 
                leftInboxes: FfiConverterSequenceTypeFfiInbox.read(from: &buf), 
                metadataFieldChanges: FfiConverterSequenceTypeFfiMetadataFieldChange.read(from: &buf), 
                addedAdminInboxes: FfiConverterSequenceTypeFfiInbox.read(from: &buf), 
                removedAdminInboxes: FfiConverterSequenceTypeFfiInbox.read(from: &buf), 
                addedSuperAdminInboxes: FfiConverterSequenceTypeFfiInbox.read(from: &buf), 
                removedSuperAdminInboxes: FfiConverterSequenceTypeFfiInbox.read(from: &buf)
        )
    }

    public static func write(_ value: FfiGroupUpdated, into buf: inout [UInt8]) {
        FfiConverterString.write(value.initiatedByInboxId, into: &buf)
        FfiConverterSequenceTypeFfiInbox.write(value.addedInboxes, into: &buf)
        FfiConverterSequenceTypeFfiInbox.write(value.removedInboxes, into: &buf)
        FfiConverterSequenceTypeFfiInbox.write(value.leftInboxes, into: &buf)
        FfiConverterSequenceTypeFfiMetadataFieldChange.write(value.metadataFieldChanges, into: &buf)
        FfiConverterSequenceTypeFfiInbox.write(value.addedAdminInboxes, into: &buf)
        FfiConverterSequenceTypeFfiInbox.write(value.removedAdminInboxes, into: &buf)
        FfiConverterSequenceTypeFfiInbox.write(value.addedSuperAdminInboxes, into: &buf)
        FfiConverterSequenceTypeFfiInbox.write(value.removedSuperAdminInboxes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupUpdated_lift(_ buf: RustBuffer) throws -> FfiGroupUpdated {
    return try FfiConverterTypeFfiGroupUpdated.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupUpdated_lower(_ value: FfiGroupUpdated) -> RustBuffer {
    return FfiConverterTypeFfiGroupUpdated.lower(value)
}


public struct FfiHmacKey {
    public var key: Data
    public var epoch: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: Data, epoch: Int64) {
        self.key = key
        self.epoch = epoch
    }
}

#if compiler(>=6)
extension FfiHmacKey: Sendable {}
#endif


extension FfiHmacKey: Equatable, Hashable {
    public static func ==(lhs: FfiHmacKey, rhs: FfiHmacKey) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.epoch != rhs.epoch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(epoch)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiHmacKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiHmacKey {
        return
            try FfiHmacKey(
                key: FfiConverterData.read(from: &buf), 
                epoch: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiHmacKey, into buf: inout [UInt8]) {
        FfiConverterData.write(value.key, into: &buf)
        FfiConverterInt64.write(value.epoch, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHmacKey_lift(_ buf: RustBuffer) throws -> FfiHmacKey {
    return try FfiConverterTypeFfiHmacKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHmacKey_lower(_ value: FfiHmacKey) -> RustBuffer {
    return FfiConverterTypeFfiHmacKey.lower(value)
}


public struct FfiIdentifier {
    public var identifier: String
    public var identifierKind: FfiIdentifierKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: String, identifierKind: FfiIdentifierKind) {
        self.identifier = identifier
        self.identifierKind = identifierKind
    }
}

#if compiler(>=6)
extension FfiIdentifier: Sendable {}
#endif


extension FfiIdentifier: Equatable, Hashable {
    public static func ==(lhs: FfiIdentifier, rhs: FfiIdentifier) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.identifierKind != rhs.identifierKind {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(identifierKind)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiIdentifier {
        return
            try FfiIdentifier(
                identifier: FfiConverterString.read(from: &buf), 
                identifierKind: FfiConverterTypeFfiIdentifierKind.read(from: &buf)
        )
    }

    public static func write(_ value: FfiIdentifier, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterTypeFfiIdentifierKind.write(value.identifierKind, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifier_lift(_ buf: RustBuffer) throws -> FfiIdentifier {
    return try FfiConverterTypeFfiIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifier_lower(_ value: FfiIdentifier) -> RustBuffer {
    return FfiConverterTypeFfiIdentifier.lower(value)
}


public struct FfiIdentityStats {
    public var publishIdentityUpdate: UInt64
    public var getIdentityUpdatesV2: UInt64
    public var getInboxIds: UInt64
    public var verifySmartContractWalletSignature: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publishIdentityUpdate: UInt64, getIdentityUpdatesV2: UInt64, getInboxIds: UInt64, verifySmartContractWalletSignature: UInt64) {
        self.publishIdentityUpdate = publishIdentityUpdate
        self.getIdentityUpdatesV2 = getIdentityUpdatesV2
        self.getInboxIds = getInboxIds
        self.verifySmartContractWalletSignature = verifySmartContractWalletSignature
    }
}

#if compiler(>=6)
extension FfiIdentityStats: Sendable {}
#endif


extension FfiIdentityStats: Equatable, Hashable {
    public static func ==(lhs: FfiIdentityStats, rhs: FfiIdentityStats) -> Bool {
        if lhs.publishIdentityUpdate != rhs.publishIdentityUpdate {
            return false
        }
        if lhs.getIdentityUpdatesV2 != rhs.getIdentityUpdatesV2 {
            return false
        }
        if lhs.getInboxIds != rhs.getInboxIds {
            return false
        }
        if lhs.verifySmartContractWalletSignature != rhs.verifySmartContractWalletSignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publishIdentityUpdate)
        hasher.combine(getIdentityUpdatesV2)
        hasher.combine(getInboxIds)
        hasher.combine(verifySmartContractWalletSignature)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiIdentityStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiIdentityStats {
        return
            try FfiIdentityStats(
                publishIdentityUpdate: FfiConverterUInt64.read(from: &buf), 
                getIdentityUpdatesV2: FfiConverterUInt64.read(from: &buf), 
                getInboxIds: FfiConverterUInt64.read(from: &buf), 
                verifySmartContractWalletSignature: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiIdentityStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.publishIdentityUpdate, into: &buf)
        FfiConverterUInt64.write(value.getIdentityUpdatesV2, into: &buf)
        FfiConverterUInt64.write(value.getInboxIds, into: &buf)
        FfiConverterUInt64.write(value.verifySmartContractWalletSignature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentityStats_lift(_ buf: RustBuffer) throws -> FfiIdentityStats {
    return try FfiConverterTypeFfiIdentityStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentityStats_lower(_ value: FfiIdentityStats) -> RustBuffer {
    return FfiConverterTypeFfiIdentityStats.lower(value)
}


public struct FfiInbox {
    public var inboxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inboxId: String) {
        self.inboxId = inboxId
    }
}

#if compiler(>=6)
extension FfiInbox: Sendable {}
#endif


extension FfiInbox: Equatable, Hashable {
    public static func ==(lhs: FfiInbox, rhs: FfiInbox) -> Bool {
        if lhs.inboxId != rhs.inboxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inboxId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiInbox: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInbox {
        return
            try FfiInbox(
                inboxId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiInbox, into buf: inout [UInt8]) {
        FfiConverterString.write(value.inboxId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInbox_lift(_ buf: RustBuffer) throws -> FfiInbox {
    return try FfiConverterTypeFfiInbox.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInbox_lower(_ value: FfiInbox) -> RustBuffer {
    return FfiConverterTypeFfiInbox.lower(value)
}


public struct FfiInboxState {
    public var inboxId: String
    public var recoveryIdentity: FfiIdentifier
    public var installations: [FfiInstallation]
    public var accountIdentities: [FfiIdentifier]
    public var creationSignatureKind: FfiSignatureKind?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inboxId: String, recoveryIdentity: FfiIdentifier, installations: [FfiInstallation], accountIdentities: [FfiIdentifier], creationSignatureKind: FfiSignatureKind?) {
        self.inboxId = inboxId
        self.recoveryIdentity = recoveryIdentity
        self.installations = installations
        self.accountIdentities = accountIdentities
        self.creationSignatureKind = creationSignatureKind
    }
}

#if compiler(>=6)
extension FfiInboxState: Sendable {}
#endif


extension FfiInboxState: Equatable, Hashable {
    public static func ==(lhs: FfiInboxState, rhs: FfiInboxState) -> Bool {
        if lhs.inboxId != rhs.inboxId {
            return false
        }
        if lhs.recoveryIdentity != rhs.recoveryIdentity {
            return false
        }
        if lhs.installations != rhs.installations {
            return false
        }
        if lhs.accountIdentities != rhs.accountIdentities {
            return false
        }
        if lhs.creationSignatureKind != rhs.creationSignatureKind {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inboxId)
        hasher.combine(recoveryIdentity)
        hasher.combine(installations)
        hasher.combine(accountIdentities)
        hasher.combine(creationSignatureKind)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiInboxState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInboxState {
        return
            try FfiInboxState(
                inboxId: FfiConverterString.read(from: &buf), 
                recoveryIdentity: FfiConverterTypeFfiIdentifier.read(from: &buf), 
                installations: FfiConverterSequenceTypeFfiInstallation.read(from: &buf), 
                accountIdentities: FfiConverterSequenceTypeFfiIdentifier.read(from: &buf), 
                creationSignatureKind: FfiConverterOptionTypeFfiSignatureKind.read(from: &buf)
        )
    }

    public static func write(_ value: FfiInboxState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.inboxId, into: &buf)
        FfiConverterTypeFfiIdentifier.write(value.recoveryIdentity, into: &buf)
        FfiConverterSequenceTypeFfiInstallation.write(value.installations, into: &buf)
        FfiConverterSequenceTypeFfiIdentifier.write(value.accountIdentities, into: &buf)
        FfiConverterOptionTypeFfiSignatureKind.write(value.creationSignatureKind, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxState_lift(_ buf: RustBuffer) throws -> FfiInboxState {
    return try FfiConverterTypeFfiInboxState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxState_lower(_ value: FfiInboxState) -> RustBuffer {
    return FfiConverterTypeFfiInboxState.lower(value)
}


public struct FfiInstallation {
    public var id: Data
    public var clientTimestampNs: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, clientTimestampNs: UInt64?) {
        self.id = id
        self.clientTimestampNs = clientTimestampNs
    }
}

#if compiler(>=6)
extension FfiInstallation: Sendable {}
#endif


extension FfiInstallation: Equatable, Hashable {
    public static func ==(lhs: FfiInstallation, rhs: FfiInstallation) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.clientTimestampNs != rhs.clientTimestampNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(clientTimestampNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiInstallation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInstallation {
        return
            try FfiInstallation(
                id: FfiConverterData.read(from: &buf), 
                clientTimestampNs: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiInstallation, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterOptionUInt64.write(value.clientTimestampNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInstallation_lift(_ buf: RustBuffer) throws -> FfiInstallation {
    return try FfiConverterTypeFfiInstallation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInstallation_lower(_ value: FfiInstallation) -> RustBuffer {
    return FfiConverterTypeFfiInstallation.lower(value)
}


public struct FfiIntent {
    public var id: String
    public var actionId: String
    public var metadata: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, actionId: String, metadata: String?) {
        self.id = id
        self.actionId = actionId
        self.metadata = metadata
    }
}

#if compiler(>=6)
extension FfiIntent: Sendable {}
#endif


extension FfiIntent: Equatable, Hashable {
    public static func ==(lhs: FfiIntent, rhs: FfiIntent) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.actionId != rhs.actionId {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(actionId)
        hasher.combine(metadata)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiIntent {
        return
            try FfiIntent(
                id: FfiConverterString.read(from: &buf), 
                actionId: FfiConverterString.read(from: &buf), 
                metadata: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiIntent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.actionId, into: &buf)
        FfiConverterOptionString.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIntent_lift(_ buf: RustBuffer) throws -> FfiIntent {
    return try FfiConverterTypeFfiIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIntent_lower(_ value: FfiIntent) -> RustBuffer {
    return FfiConverterTypeFfiIntent.lower(value)
}


public struct FfiKeyPackageStatus {
    public var lifetime: FfiLifetime?
    public var validationError: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lifetime: FfiLifetime?, validationError: String?) {
        self.lifetime = lifetime
        self.validationError = validationError
    }
}

#if compiler(>=6)
extension FfiKeyPackageStatus: Sendable {}
#endif


extension FfiKeyPackageStatus: Equatable, Hashable {
    public static func ==(lhs: FfiKeyPackageStatus, rhs: FfiKeyPackageStatus) -> Bool {
        if lhs.lifetime != rhs.lifetime {
            return false
        }
        if lhs.validationError != rhs.validationError {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lifetime)
        hasher.combine(validationError)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiKeyPackageStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiKeyPackageStatus {
        return
            try FfiKeyPackageStatus(
                lifetime: FfiConverterOptionTypeFfiLifetime.read(from: &buf), 
                validationError: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiKeyPackageStatus, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiLifetime.write(value.lifetime, into: &buf)
        FfiConverterOptionString.write(value.validationError, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyPackageStatus_lift(_ buf: RustBuffer) throws -> FfiKeyPackageStatus {
    return try FfiConverterTypeFfiKeyPackageStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyPackageStatus_lower(_ value: FfiKeyPackageStatus) -> RustBuffer {
    return FfiConverterTypeFfiKeyPackageStatus.lower(value)
}


/**
 * Represents a leave request message sent when a user wants to leave a group.
 */
public struct FfiLeaveRequest {
    /**
     * Optional authenticated note for the leave request
     */
    public var authenticatedNote: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional authenticated note for the leave request
         */authenticatedNote: Data?) {
        self.authenticatedNote = authenticatedNote
    }
}

#if compiler(>=6)
extension FfiLeaveRequest: Sendable {}
#endif


extension FfiLeaveRequest: Equatable, Hashable {
    public static func ==(lhs: FfiLeaveRequest, rhs: FfiLeaveRequest) -> Bool {
        if lhs.authenticatedNote != rhs.authenticatedNote {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authenticatedNote)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiLeaveRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiLeaveRequest {
        return
            try FfiLeaveRequest(
                authenticatedNote: FfiConverterOptionData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiLeaveRequest, into buf: inout [UInt8]) {
        FfiConverterOptionData.write(value.authenticatedNote, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLeaveRequest_lift(_ buf: RustBuffer) throws -> FfiLeaveRequest {
    return try FfiConverterTypeFfiLeaveRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLeaveRequest_lower(_ value: FfiLeaveRequest) -> RustBuffer {
    return FfiConverterTypeFfiLeaveRequest.lower(value)
}


public struct FfiLifetime {
    public var notBefore: UInt64
    public var notAfter: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(notBefore: UInt64, notAfter: UInt64) {
        self.notBefore = notBefore
        self.notAfter = notAfter
    }
}

#if compiler(>=6)
extension FfiLifetime: Sendable {}
#endif


extension FfiLifetime: Equatable, Hashable {
    public static func ==(lhs: FfiLifetime, rhs: FfiLifetime) -> Bool {
        if lhs.notBefore != rhs.notBefore {
            return false
        }
        if lhs.notAfter != rhs.notAfter {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(notBefore)
        hasher.combine(notAfter)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiLifetime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiLifetime {
        return
            try FfiLifetime(
                notBefore: FfiConverterUInt64.read(from: &buf), 
                notAfter: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiLifetime, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.notBefore, into: &buf)
        FfiConverterUInt64.write(value.notAfter, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLifetime_lift(_ buf: RustBuffer) throws -> FfiLifetime {
    return try FfiConverterTypeFfiLifetime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLifetime_lower(_ value: FfiLifetime) -> RustBuffer {
    return FfiConverterTypeFfiLifetime.lower(value)
}


public struct FfiListConversationsOptions {
    public var createdAfterNs: Int64?
    public var createdBeforeNs: Int64?
    public var lastActivityBeforeNs: Int64?
    public var lastActivityAfterNs: Int64?
    public var orderBy: FfiGroupQueryOrderBy?
    public var limit: Int64?
    public var consentStates: [FfiConsentState]?
    public var includeDuplicateDms: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAfterNs: Int64?, createdBeforeNs: Int64?, lastActivityBeforeNs: Int64?, lastActivityAfterNs: Int64?, orderBy: FfiGroupQueryOrderBy?, limit: Int64?, consentStates: [FfiConsentState]?, includeDuplicateDms: Bool) {
        self.createdAfterNs = createdAfterNs
        self.createdBeforeNs = createdBeforeNs
        self.lastActivityBeforeNs = lastActivityBeforeNs
        self.lastActivityAfterNs = lastActivityAfterNs
        self.orderBy = orderBy
        self.limit = limit
        self.consentStates = consentStates
        self.includeDuplicateDms = includeDuplicateDms
    }
}

#if compiler(>=6)
extension FfiListConversationsOptions: Sendable {}
#endif


extension FfiListConversationsOptions: Equatable, Hashable {
    public static func ==(lhs: FfiListConversationsOptions, rhs: FfiListConversationsOptions) -> Bool {
        if lhs.createdAfterNs != rhs.createdAfterNs {
            return false
        }
        if lhs.createdBeforeNs != rhs.createdBeforeNs {
            return false
        }
        if lhs.lastActivityBeforeNs != rhs.lastActivityBeforeNs {
            return false
        }
        if lhs.lastActivityAfterNs != rhs.lastActivityAfterNs {
            return false
        }
        if lhs.orderBy != rhs.orderBy {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.consentStates != rhs.consentStates {
            return false
        }
        if lhs.includeDuplicateDms != rhs.includeDuplicateDms {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAfterNs)
        hasher.combine(createdBeforeNs)
        hasher.combine(lastActivityBeforeNs)
        hasher.combine(lastActivityAfterNs)
        hasher.combine(orderBy)
        hasher.combine(limit)
        hasher.combine(consentStates)
        hasher.combine(includeDuplicateDms)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiListConversationsOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListConversationsOptions {
        return
            try FfiListConversationsOptions(
                createdAfterNs: FfiConverterOptionInt64.read(from: &buf), 
                createdBeforeNs: FfiConverterOptionInt64.read(from: &buf), 
                lastActivityBeforeNs: FfiConverterOptionInt64.read(from: &buf), 
                lastActivityAfterNs: FfiConverterOptionInt64.read(from: &buf), 
                orderBy: FfiConverterOptionTypeFfiGroupQueryOrderBy.read(from: &buf), 
                limit: FfiConverterOptionInt64.read(from: &buf), 
                consentStates: FfiConverterOptionSequenceTypeFfiConsentState.read(from: &buf), 
                includeDuplicateDms: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiListConversationsOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.createdAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.createdBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.lastActivityBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.lastActivityAfterNs, into: &buf)
        FfiConverterOptionTypeFfiGroupQueryOrderBy.write(value.orderBy, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
        FfiConverterOptionSequenceTypeFfiConsentState.write(value.consentStates, into: &buf)
        FfiConverterBool.write(value.includeDuplicateDms, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListConversationsOptions_lift(_ buf: RustBuffer) throws -> FfiListConversationsOptions {
    return try FfiConverterTypeFfiListConversationsOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListConversationsOptions_lower(_ value: FfiListConversationsOptions) -> RustBuffer {
    return FfiConverterTypeFfiListConversationsOptions.lower(value)
}


public struct FfiListMessagesOptions {
    public var sentBeforeNs: Int64?
    public var sentAfterNs: Int64?
    public var limit: Int64?
    public var deliveryStatus: FfiDeliveryStatus?
    public var direction: FfiDirection?
    public var contentTypes: [FfiContentType]?
    public var excludeContentTypes: [FfiContentType]?
    public var excludeSenderInboxIds: [String]?
    public var sortBy: FfiSortBy?
    public var insertedAfterNs: Int64?
    public var insertedBeforeNs: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sentBeforeNs: Int64?, sentAfterNs: Int64?, limit: Int64?, deliveryStatus: FfiDeliveryStatus?, direction: FfiDirection?, contentTypes: [FfiContentType]?, excludeContentTypes: [FfiContentType]?, excludeSenderInboxIds: [String]?, sortBy: FfiSortBy?, insertedAfterNs: Int64?, insertedBeforeNs: Int64?) {
        self.sentBeforeNs = sentBeforeNs
        self.sentAfterNs = sentAfterNs
        self.limit = limit
        self.deliveryStatus = deliveryStatus
        self.direction = direction
        self.contentTypes = contentTypes
        self.excludeContentTypes = excludeContentTypes
        self.excludeSenderInboxIds = excludeSenderInboxIds
        self.sortBy = sortBy
        self.insertedAfterNs = insertedAfterNs
        self.insertedBeforeNs = insertedBeforeNs
    }
}

#if compiler(>=6)
extension FfiListMessagesOptions: Sendable {}
#endif


extension FfiListMessagesOptions: Equatable, Hashable {
    public static func ==(lhs: FfiListMessagesOptions, rhs: FfiListMessagesOptions) -> Bool {
        if lhs.sentBeforeNs != rhs.sentBeforeNs {
            return false
        }
        if lhs.sentAfterNs != rhs.sentAfterNs {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.deliveryStatus != rhs.deliveryStatus {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.contentTypes != rhs.contentTypes {
            return false
        }
        if lhs.excludeContentTypes != rhs.excludeContentTypes {
            return false
        }
        if lhs.excludeSenderInboxIds != rhs.excludeSenderInboxIds {
            return false
        }
        if lhs.sortBy != rhs.sortBy {
            return false
        }
        if lhs.insertedAfterNs != rhs.insertedAfterNs {
            return false
        }
        if lhs.insertedBeforeNs != rhs.insertedBeforeNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sentBeforeNs)
        hasher.combine(sentAfterNs)
        hasher.combine(limit)
        hasher.combine(deliveryStatus)
        hasher.combine(direction)
        hasher.combine(contentTypes)
        hasher.combine(excludeContentTypes)
        hasher.combine(excludeSenderInboxIds)
        hasher.combine(sortBy)
        hasher.combine(insertedAfterNs)
        hasher.combine(insertedBeforeNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiListMessagesOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListMessagesOptions {
        return
            try FfiListMessagesOptions(
                sentBeforeNs: FfiConverterOptionInt64.read(from: &buf), 
                sentAfterNs: FfiConverterOptionInt64.read(from: &buf), 
                limit: FfiConverterOptionInt64.read(from: &buf), 
                deliveryStatus: FfiConverterOptionTypeFfiDeliveryStatus.read(from: &buf), 
                direction: FfiConverterOptionTypeFfiDirection.read(from: &buf), 
                contentTypes: FfiConverterOptionSequenceTypeFfiContentType.read(from: &buf), 
                excludeContentTypes: FfiConverterOptionSequenceTypeFfiContentType.read(from: &buf), 
                excludeSenderInboxIds: FfiConverterOptionSequenceString.read(from: &buf), 
                sortBy: FfiConverterOptionTypeFfiSortBy.read(from: &buf), 
                insertedAfterNs: FfiConverterOptionInt64.read(from: &buf), 
                insertedBeforeNs: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiListMessagesOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.sentBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.sentAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
        FfiConverterOptionTypeFfiDeliveryStatus.write(value.deliveryStatus, into: &buf)
        FfiConverterOptionTypeFfiDirection.write(value.direction, into: &buf)
        FfiConverterOptionSequenceTypeFfiContentType.write(value.contentTypes, into: &buf)
        FfiConverterOptionSequenceTypeFfiContentType.write(value.excludeContentTypes, into: &buf)
        FfiConverterOptionSequenceString.write(value.excludeSenderInboxIds, into: &buf)
        FfiConverterOptionTypeFfiSortBy.write(value.sortBy, into: &buf)
        FfiConverterOptionInt64.write(value.insertedAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.insertedBeforeNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListMessagesOptions_lift(_ buf: RustBuffer) throws -> FfiListMessagesOptions {
    return try FfiConverterTypeFfiListMessagesOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListMessagesOptions_lower(_ value: FfiListMessagesOptions) -> RustBuffer {
    return FfiConverterTypeFfiListMessagesOptions.lower(value)
}


public struct FfiMarkdownContent {
    public var content: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(content: String) {
        self.content = content
    }
}

#if compiler(>=6)
extension FfiMarkdownContent: Sendable {}
#endif


extension FfiMarkdownContent: Equatable, Hashable {
    public static func ==(lhs: FfiMarkdownContent, rhs: FfiMarkdownContent) -> Bool {
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(content)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMarkdownContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMarkdownContent {
        return
            try FfiMarkdownContent(
                content: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMarkdownContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.content, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMarkdownContent_lift(_ buf: RustBuffer) throws -> FfiMarkdownContent {
    return try FfiConverterTypeFfiMarkdownContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMarkdownContent_lower(_ value: FfiMarkdownContent) -> RustBuffer {
    return FfiConverterTypeFfiMarkdownContent.lower(value)
}


public struct FfiMessage {
    public var id: Data
    public var sentAtNs: Int64
    public var conversationId: Data
    public var senderInboxId: String
    public var content: Data
    public var kind: FfiConversationMessageKind
    public var deliveryStatus: FfiDeliveryStatus
    public var sequenceId: UInt64
    public var originatorId: UInt32
    public var insertedAtNs: Int64
    public var expireAtNs: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, sentAtNs: Int64, conversationId: Data, senderInboxId: String, content: Data, kind: FfiConversationMessageKind, deliveryStatus: FfiDeliveryStatus, sequenceId: UInt64, originatorId: UInt32, insertedAtNs: Int64, expireAtNs: Int64?) {
        self.id = id
        self.sentAtNs = sentAtNs
        self.conversationId = conversationId
        self.senderInboxId = senderInboxId
        self.content = content
        self.kind = kind
        self.deliveryStatus = deliveryStatus
        self.sequenceId = sequenceId
        self.originatorId = originatorId
        self.insertedAtNs = insertedAtNs
        self.expireAtNs = expireAtNs
    }
}

#if compiler(>=6)
extension FfiMessage: Sendable {}
#endif


extension FfiMessage: Equatable, Hashable {
    public static func ==(lhs: FfiMessage, rhs: FfiMessage) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.sentAtNs != rhs.sentAtNs {
            return false
        }
        if lhs.conversationId != rhs.conversationId {
            return false
        }
        if lhs.senderInboxId != rhs.senderInboxId {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.deliveryStatus != rhs.deliveryStatus {
            return false
        }
        if lhs.sequenceId != rhs.sequenceId {
            return false
        }
        if lhs.originatorId != rhs.originatorId {
            return false
        }
        if lhs.insertedAtNs != rhs.insertedAtNs {
            return false
        }
        if lhs.expireAtNs != rhs.expireAtNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(sentAtNs)
        hasher.combine(conversationId)
        hasher.combine(senderInboxId)
        hasher.combine(content)
        hasher.combine(kind)
        hasher.combine(deliveryStatus)
        hasher.combine(sequenceId)
        hasher.combine(originatorId)
        hasher.combine(insertedAtNs)
        hasher.combine(expireAtNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessage {
        return
            try FfiMessage(
                id: FfiConverterData.read(from: &buf), 
                sentAtNs: FfiConverterInt64.read(from: &buf), 
                conversationId: FfiConverterData.read(from: &buf), 
                senderInboxId: FfiConverterString.read(from: &buf), 
                content: FfiConverterData.read(from: &buf), 
                kind: FfiConverterTypeFfiConversationMessageKind.read(from: &buf), 
                deliveryStatus: FfiConverterTypeFfiDeliveryStatus.read(from: &buf), 
                sequenceId: FfiConverterUInt64.read(from: &buf), 
                originatorId: FfiConverterUInt32.read(from: &buf), 
                insertedAtNs: FfiConverterInt64.read(from: &buf), 
                expireAtNs: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessage, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterInt64.write(value.sentAtNs, into: &buf)
        FfiConverterData.write(value.conversationId, into: &buf)
        FfiConverterString.write(value.senderInboxId, into: &buf)
        FfiConverterData.write(value.content, into: &buf)
        FfiConverterTypeFfiConversationMessageKind.write(value.kind, into: &buf)
        FfiConverterTypeFfiDeliveryStatus.write(value.deliveryStatus, into: &buf)
        FfiConverterUInt64.write(value.sequenceId, into: &buf)
        FfiConverterUInt32.write(value.originatorId, into: &buf)
        FfiConverterInt64.write(value.insertedAtNs, into: &buf)
        FfiConverterOptionInt64.write(value.expireAtNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessage_lift(_ buf: RustBuffer) throws -> FfiMessage {
    return try FfiConverterTypeFfiMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessage_lower(_ value: FfiMessage) -> RustBuffer {
    return FfiConverterTypeFfiMessage.lower(value)
}


/**
 * Settings for disappearing messages in a conversation.
 *
 * # Fields
 *
 * * `from_ns` - The timestamp (in nanoseconds) from when messages should be tracked for deletion.
 * * `in_ns` - The duration (in nanoseconds) after which tracked messages will be deleted.
 */
public struct FfiMessageDisappearingSettings {
    public var fromNs: Int64
    public var inNs: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fromNs: Int64, inNs: Int64) {
        self.fromNs = fromNs
        self.inNs = inNs
    }
}

#if compiler(>=6)
extension FfiMessageDisappearingSettings: Sendable {}
#endif


extension FfiMessageDisappearingSettings: Equatable, Hashable {
    public static func ==(lhs: FfiMessageDisappearingSettings, rhs: FfiMessageDisappearingSettings) -> Bool {
        if lhs.fromNs != rhs.fromNs {
            return false
        }
        if lhs.inNs != rhs.inNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fromNs)
        hasher.combine(inNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageDisappearingSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageDisappearingSettings {
        return
            try FfiMessageDisappearingSettings(
                fromNs: FfiConverterInt64.read(from: &buf), 
                inNs: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessageDisappearingSettings, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.fromNs, into: &buf)
        FfiConverterInt64.write(value.inNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageDisappearingSettings_lift(_ buf: RustBuffer) throws -> FfiMessageDisappearingSettings {
    return try FfiConverterTypeFfiMessageDisappearingSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageDisappearingSettings_lower(_ value: FfiMessageDisappearingSettings) -> RustBuffer {
    return FfiConverterTypeFfiMessageDisappearingSettings.lower(value)
}


public struct FfiMessageMetadata {
    public var cursor: FfiCursor
    public var createdNs: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cursor: FfiCursor, createdNs: Int64) {
        self.cursor = cursor
        self.createdNs = createdNs
    }
}

#if compiler(>=6)
extension FfiMessageMetadata: Sendable {}
#endif


extension FfiMessageMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiMessageMetadata, rhs: FfiMessageMetadata) -> Bool {
        if lhs.cursor != rhs.cursor {
            return false
        }
        if lhs.createdNs != rhs.createdNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cursor)
        hasher.combine(createdNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageMetadata {
        return
            try FfiMessageMetadata(
                cursor: FfiConverterTypeFfiCursor.read(from: &buf), 
                createdNs: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessageMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeFfiCursor.write(value.cursor, into: &buf)
        FfiConverterInt64.write(value.createdNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageMetadata_lift(_ buf: RustBuffer) throws -> FfiMessageMetadata {
    return try FfiConverterTypeFfiMessageMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageMetadata_lower(_ value: FfiMessageMetadata) -> RustBuffer {
    return FfiConverterTypeFfiMessageMetadata.lower(value)
}


public struct FfiMessageWithReactions {
    public var message: FfiMessage
    public var reactions: [FfiMessage]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: FfiMessage, reactions: [FfiMessage]) {
        self.message = message
        self.reactions = reactions
    }
}

#if compiler(>=6)
extension FfiMessageWithReactions: Sendable {}
#endif


extension FfiMessageWithReactions: Equatable, Hashable {
    public static func ==(lhs: FfiMessageWithReactions, rhs: FfiMessageWithReactions) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.reactions != rhs.reactions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(reactions)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageWithReactions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageWithReactions {
        return
            try FfiMessageWithReactions(
                message: FfiConverterTypeFfiMessage.read(from: &buf), 
                reactions: FfiConverterSequenceTypeFfiMessage.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessageWithReactions, into buf: inout [UInt8]) {
        FfiConverterTypeFfiMessage.write(value.message, into: &buf)
        FfiConverterSequenceTypeFfiMessage.write(value.reactions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageWithReactions_lift(_ buf: RustBuffer) throws -> FfiMessageWithReactions {
    return try FfiConverterTypeFfiMessageWithReactions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageWithReactions_lower(_ value: FfiMessageWithReactions) -> RustBuffer {
    return FfiConverterTypeFfiMessageWithReactions.lower(value)
}


public struct FfiMetadataFieldChange {
    public var fieldName: String
    public var oldValue: String?
    public var newValue: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fieldName: String, oldValue: String?, newValue: String?) {
        self.fieldName = fieldName
        self.oldValue = oldValue
        self.newValue = newValue
    }
}

#if compiler(>=6)
extension FfiMetadataFieldChange: Sendable {}
#endif


extension FfiMetadataFieldChange: Equatable, Hashable {
    public static func ==(lhs: FfiMetadataFieldChange, rhs: FfiMetadataFieldChange) -> Bool {
        if lhs.fieldName != rhs.fieldName {
            return false
        }
        if lhs.oldValue != rhs.oldValue {
            return false
        }
        if lhs.newValue != rhs.newValue {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fieldName)
        hasher.combine(oldValue)
        hasher.combine(newValue)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMetadataFieldChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMetadataFieldChange {
        return
            try FfiMetadataFieldChange(
                fieldName: FfiConverterString.read(from: &buf), 
                oldValue: FfiConverterOptionString.read(from: &buf), 
                newValue: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMetadataFieldChange, into buf: inout [UInt8]) {
        FfiConverterString.write(value.fieldName, into: &buf)
        FfiConverterOptionString.write(value.oldValue, into: &buf)
        FfiConverterOptionString.write(value.newValue, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMetadataFieldChange_lift(_ buf: RustBuffer) throws -> FfiMetadataFieldChange {
    return try FfiConverterTypeFfiMetadataFieldChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMetadataFieldChange_lower(_ value: FfiMetadataFieldChange) -> RustBuffer {
    return FfiConverterTypeFfiMetadataFieldChange.lower(value)
}


public struct FfiMultiRemoteAttachment {
    public var attachments: [FfiRemoteAttachment]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(attachments: [FfiRemoteAttachment]) {
        self.attachments = attachments
    }
}

#if compiler(>=6)
extension FfiMultiRemoteAttachment: Sendable {}
#endif


extension FfiMultiRemoteAttachment: Equatable, Hashable {
    public static func ==(lhs: FfiMultiRemoteAttachment, rhs: FfiMultiRemoteAttachment) -> Bool {
        if lhs.attachments != rhs.attachments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attachments)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMultiRemoteAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMultiRemoteAttachment {
        return
            try FfiMultiRemoteAttachment(
                attachments: FfiConverterSequenceTypeFfiRemoteAttachment.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMultiRemoteAttachment, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiRemoteAttachment.write(value.attachments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMultiRemoteAttachment_lift(_ buf: RustBuffer) throws -> FfiMultiRemoteAttachment {
    return try FfiConverterTypeFfiMultiRemoteAttachment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMultiRemoteAttachment_lower(_ value: FfiMultiRemoteAttachment) -> RustBuffer {
    return FfiConverterTypeFfiMultiRemoteAttachment.lower(value)
}


public struct FfiPasskeySignature {
    public var publicKey: Data
    public var signature: Data
    public var authenticatorData: Data
    public var clientDataJson: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: Data, signature: Data, authenticatorData: Data, clientDataJson: Data) {
        self.publicKey = publicKey
        self.signature = signature
        self.authenticatorData = authenticatorData
        self.clientDataJson = clientDataJson
    }
}

#if compiler(>=6)
extension FfiPasskeySignature: Sendable {}
#endif


extension FfiPasskeySignature: Equatable, Hashable {
    public static func ==(lhs: FfiPasskeySignature, rhs: FfiPasskeySignature) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.authenticatorData != rhs.authenticatorData {
            return false
        }
        if lhs.clientDataJson != rhs.clientDataJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(signature)
        hasher.combine(authenticatorData)
        hasher.combine(clientDataJson)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPasskeySignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPasskeySignature {
        return
            try FfiPasskeySignature(
                publicKey: FfiConverterData.read(from: &buf), 
                signature: FfiConverterData.read(from: &buf), 
                authenticatorData: FfiConverterData.read(from: &buf), 
                clientDataJson: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiPasskeySignature, into buf: inout [UInt8]) {
        FfiConverterData.write(value.publicKey, into: &buf)
        FfiConverterData.write(value.signature, into: &buf)
        FfiConverterData.write(value.authenticatorData, into: &buf)
        FfiConverterData.write(value.clientDataJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPasskeySignature_lift(_ buf: RustBuffer) throws -> FfiPasskeySignature {
    return try FfiConverterTypeFfiPasskeySignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPasskeySignature_lower(_ value: FfiPasskeySignature) -> RustBuffer {
    return FfiConverterTypeFfiPasskeySignature.lower(value)
}


public struct FfiPermissionPolicySet {
    public var addMemberPolicy: FfiPermissionPolicy
    public var removeMemberPolicy: FfiPermissionPolicy
    public var addAdminPolicy: FfiPermissionPolicy
    public var removeAdminPolicy: FfiPermissionPolicy
    public var updateGroupNamePolicy: FfiPermissionPolicy
    public var updateGroupDescriptionPolicy: FfiPermissionPolicy
    public var updateGroupImageUrlSquarePolicy: FfiPermissionPolicy
    public var updateMessageDisappearingPolicy: FfiPermissionPolicy
    public var updateAppDataPolicy: FfiPermissionPolicy

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addMemberPolicy: FfiPermissionPolicy, removeMemberPolicy: FfiPermissionPolicy, addAdminPolicy: FfiPermissionPolicy, removeAdminPolicy: FfiPermissionPolicy, updateGroupNamePolicy: FfiPermissionPolicy, updateGroupDescriptionPolicy: FfiPermissionPolicy, updateGroupImageUrlSquarePolicy: FfiPermissionPolicy, updateMessageDisappearingPolicy: FfiPermissionPolicy, updateAppDataPolicy: FfiPermissionPolicy) {
        self.addMemberPolicy = addMemberPolicy
        self.removeMemberPolicy = removeMemberPolicy
        self.addAdminPolicy = addAdminPolicy
        self.removeAdminPolicy = removeAdminPolicy
        self.updateGroupNamePolicy = updateGroupNamePolicy
        self.updateGroupDescriptionPolicy = updateGroupDescriptionPolicy
        self.updateGroupImageUrlSquarePolicy = updateGroupImageUrlSquarePolicy
        self.updateMessageDisappearingPolicy = updateMessageDisappearingPolicy
        self.updateAppDataPolicy = updateAppDataPolicy
    }
}

#if compiler(>=6)
extension FfiPermissionPolicySet: Sendable {}
#endif


extension FfiPermissionPolicySet: Equatable, Hashable {
    public static func ==(lhs: FfiPermissionPolicySet, rhs: FfiPermissionPolicySet) -> Bool {
        if lhs.addMemberPolicy != rhs.addMemberPolicy {
            return false
        }
        if lhs.removeMemberPolicy != rhs.removeMemberPolicy {
            return false
        }
        if lhs.addAdminPolicy != rhs.addAdminPolicy {
            return false
        }
        if lhs.removeAdminPolicy != rhs.removeAdminPolicy {
            return false
        }
        if lhs.updateGroupNamePolicy != rhs.updateGroupNamePolicy {
            return false
        }
        if lhs.updateGroupDescriptionPolicy != rhs.updateGroupDescriptionPolicy {
            return false
        }
        if lhs.updateGroupImageUrlSquarePolicy != rhs.updateGroupImageUrlSquarePolicy {
            return false
        }
        if lhs.updateMessageDisappearingPolicy != rhs.updateMessageDisappearingPolicy {
            return false
        }
        if lhs.updateAppDataPolicy != rhs.updateAppDataPolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addMemberPolicy)
        hasher.combine(removeMemberPolicy)
        hasher.combine(addAdminPolicy)
        hasher.combine(removeAdminPolicy)
        hasher.combine(updateGroupNamePolicy)
        hasher.combine(updateGroupDescriptionPolicy)
        hasher.combine(updateGroupImageUrlSquarePolicy)
        hasher.combine(updateMessageDisappearingPolicy)
        hasher.combine(updateAppDataPolicy)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionPolicySet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionPolicySet {
        return
            try FfiPermissionPolicySet(
                addMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                removeMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                addAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                removeAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateGroupNamePolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateGroupDescriptionPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateGroupImageUrlSquarePolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateMessageDisappearingPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateAppDataPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf)
        )
    }

    public static func write(_ value: FfiPermissionPolicySet, into buf: inout [UInt8]) {
        FfiConverterTypeFfiPermissionPolicy.write(value.addMemberPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.removeMemberPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.addAdminPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.removeAdminPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupNamePolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupDescriptionPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupImageUrlSquarePolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateMessageDisappearingPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateAppDataPolicy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicySet_lift(_ buf: RustBuffer) throws -> FfiPermissionPolicySet {
    return try FfiConverterTypeFfiPermissionPolicySet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicySet_lower(_ value: FfiPermissionPolicySet) -> RustBuffer {
    return FfiConverterTypeFfiPermissionPolicySet.lower(value)
}


public struct FfiReactionPayload {
    public var reference: String
    public var referenceInboxId: String
    public var action: FfiReactionAction
    public var content: String
    public var schema: FfiReactionSchema

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reference: String, referenceInboxId: String, action: FfiReactionAction, content: String, schema: FfiReactionSchema) {
        self.reference = reference
        self.referenceInboxId = referenceInboxId
        self.action = action
        self.content = content
        self.schema = schema
    }
}

#if compiler(>=6)
extension FfiReactionPayload: Sendable {}
#endif


extension FfiReactionPayload: Equatable, Hashable {
    public static func ==(lhs: FfiReactionPayload, rhs: FfiReactionPayload) -> Bool {
        if lhs.reference != rhs.reference {
            return false
        }
        if lhs.referenceInboxId != rhs.referenceInboxId {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.schema != rhs.schema {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reference)
        hasher.combine(referenceInboxId)
        hasher.combine(action)
        hasher.combine(content)
        hasher.combine(schema)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReactionPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReactionPayload {
        return
            try FfiReactionPayload(
                reference: FfiConverterString.read(from: &buf), 
                referenceInboxId: FfiConverterString.read(from: &buf), 
                action: FfiConverterTypeFfiReactionAction.read(from: &buf), 
                content: FfiConverterString.read(from: &buf), 
                schema: FfiConverterTypeFfiReactionSchema.read(from: &buf)
        )
    }

    public static func write(_ value: FfiReactionPayload, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reference, into: &buf)
        FfiConverterString.write(value.referenceInboxId, into: &buf)
        FfiConverterTypeFfiReactionAction.write(value.action, into: &buf)
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterTypeFfiReactionSchema.write(value.schema, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionPayload_lift(_ buf: RustBuffer) throws -> FfiReactionPayload {
    return try FfiConverterTypeFfiReactionPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionPayload_lower(_ value: FfiReactionPayload) -> RustBuffer {
    return FfiConverterTypeFfiReactionPayload.lower(value)
}


public struct FfiReadReceipt {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}

#if compiler(>=6)
extension FfiReadReceipt: Sendable {}
#endif


extension FfiReadReceipt: Equatable, Hashable {
    public static func ==(lhs: FfiReadReceipt, rhs: FfiReadReceipt) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReadReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReadReceipt {
        return
            FfiReadReceipt()
    }

    public static func write(_ value: FfiReadReceipt, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReadReceipt_lift(_ buf: RustBuffer) throws -> FfiReadReceipt {
    return try FfiConverterTypeFfiReadReceipt.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReadReceipt_lower(_ value: FfiReadReceipt) -> RustBuffer {
    return FfiConverterTypeFfiReadReceipt.lower(value)
}


public struct FfiRemoteAttachment {
    public var url: String
    public var contentDigest: String
    public var secret: Data
    public var salt: Data
    public var nonce: Data
    public var scheme: String
    public var contentLength: UInt32?
    public var filename: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, contentDigest: String, secret: Data, salt: Data, nonce: Data, scheme: String, contentLength: UInt32?, filename: String?) {
        self.url = url
        self.contentDigest = contentDigest
        self.secret = secret
        self.salt = salt
        self.nonce = nonce
        self.scheme = scheme
        self.contentLength = contentLength
        self.filename = filename
    }
}

#if compiler(>=6)
extension FfiRemoteAttachment: Sendable {}
#endif


extension FfiRemoteAttachment: Equatable, Hashable {
    public static func ==(lhs: FfiRemoteAttachment, rhs: FfiRemoteAttachment) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.contentDigest != rhs.contentDigest {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.salt != rhs.salt {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.scheme != rhs.scheme {
            return false
        }
        if lhs.contentLength != rhs.contentLength {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(contentDigest)
        hasher.combine(secret)
        hasher.combine(salt)
        hasher.combine(nonce)
        hasher.combine(scheme)
        hasher.combine(contentLength)
        hasher.combine(filename)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiRemoteAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiRemoteAttachment {
        return
            try FfiRemoteAttachment(
                url: FfiConverterString.read(from: &buf), 
                contentDigest: FfiConverterString.read(from: &buf), 
                secret: FfiConverterData.read(from: &buf), 
                salt: FfiConverterData.read(from: &buf), 
                nonce: FfiConverterData.read(from: &buf), 
                scheme: FfiConverterString.read(from: &buf), 
                contentLength: FfiConverterOptionUInt32.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiRemoteAttachment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.contentDigest, into: &buf)
        FfiConverterData.write(value.secret, into: &buf)
        FfiConverterData.write(value.salt, into: &buf)
        FfiConverterData.write(value.nonce, into: &buf)
        FfiConverterString.write(value.scheme, into: &buf)
        FfiConverterOptionUInt32.write(value.contentLength, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiRemoteAttachment_lift(_ buf: RustBuffer) throws -> FfiRemoteAttachment {
    return try FfiConverterTypeFfiRemoteAttachment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiRemoteAttachment_lower(_ value: FfiRemoteAttachment) -> RustBuffer {
    return FfiConverterTypeFfiRemoteAttachment.lower(value)
}


public struct FfiReply {
    public var reference: String
    public var referenceInboxId: String?
    public var content: FfiEncodedContent

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reference: String, referenceInboxId: String?, content: FfiEncodedContent) {
        self.reference = reference
        self.referenceInboxId = referenceInboxId
        self.content = content
    }
}

#if compiler(>=6)
extension FfiReply: Sendable {}
#endif


extension FfiReply: Equatable, Hashable {
    public static func ==(lhs: FfiReply, rhs: FfiReply) -> Bool {
        if lhs.reference != rhs.reference {
            return false
        }
        if lhs.referenceInboxId != rhs.referenceInboxId {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reference)
        hasher.combine(referenceInboxId)
        hasher.combine(content)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReply: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReply {
        return
            try FfiReply(
                reference: FfiConverterString.read(from: &buf), 
                referenceInboxId: FfiConverterOptionString.read(from: &buf), 
                content: FfiConverterTypeFfiEncodedContent.read(from: &buf)
        )
    }

    public static func write(_ value: FfiReply, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reference, into: &buf)
        FfiConverterOptionString.write(value.referenceInboxId, into: &buf)
        FfiConverterTypeFfiEncodedContent.write(value.content, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReply_lift(_ buf: RustBuffer) throws -> FfiReply {
    return try FfiConverterTypeFfiReply.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReply_lower(_ value: FfiReply) -> RustBuffer {
    return FfiConverterTypeFfiReply.lower(value)
}


public struct FfiSendMessageOpts {
    public var shouldPush: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(shouldPush: Bool) {
        self.shouldPush = shouldPush
    }
}

#if compiler(>=6)
extension FfiSendMessageOpts: Sendable {}
#endif


extension FfiSendMessageOpts: Equatable, Hashable {
    public static func ==(lhs: FfiSendMessageOpts, rhs: FfiSendMessageOpts) -> Bool {
        if lhs.shouldPush != rhs.shouldPush {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shouldPush)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSendMessageOpts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSendMessageOpts {
        return
            try FfiSendMessageOpts(
                shouldPush: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiSendMessageOpts, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.shouldPush, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSendMessageOpts_lift(_ buf: RustBuffer) throws -> FfiSendMessageOpts {
    return try FfiConverterTypeFfiSendMessageOpts.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSendMessageOpts_lower(_ value: FfiSendMessageOpts) -> RustBuffer {
    return FfiConverterTypeFfiSendMessageOpts.lower(value)
}


public struct FfiTextContent {
    public var content: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(content: String) {
        self.content = content
    }
}

#if compiler(>=6)
extension FfiTextContent: Sendable {}
#endif


extension FfiTextContent: Equatable, Hashable {
    public static func ==(lhs: FfiTextContent, rhs: FfiTextContent) -> Bool {
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(content)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTextContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTextContent {
        return
            try FfiTextContent(
                content: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTextContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.content, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextContent_lift(_ buf: RustBuffer) throws -> FfiTextContent {
    return try FfiConverterTypeFfiTextContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextContent_lower(_ value: FfiTextContent) -> RustBuffer {
    return FfiConverterTypeFfiTextContent.lower(value)
}


public struct FfiTransactionMetadata {
    public var transactionType: String
    public var currency: String
    public var amount: Double
    public var decimals: UInt32
    public var fromAddress: String
    public var toAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionType: String, currency: String, amount: Double, decimals: UInt32, fromAddress: String, toAddress: String) {
        self.transactionType = transactionType
        self.currency = currency
        self.amount = amount
        self.decimals = decimals
        self.fromAddress = fromAddress
        self.toAddress = toAddress
    }
}

#if compiler(>=6)
extension FfiTransactionMetadata: Sendable {}
#endif


extension FfiTransactionMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiTransactionMetadata, rhs: FfiTransactionMetadata) -> Bool {
        if lhs.transactionType != rhs.transactionType {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.fromAddress != rhs.fromAddress {
            return false
        }
        if lhs.toAddress != rhs.toAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionType)
        hasher.combine(currency)
        hasher.combine(amount)
        hasher.combine(decimals)
        hasher.combine(fromAddress)
        hasher.combine(toAddress)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTransactionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTransactionMetadata {
        return
            try FfiTransactionMetadata(
                transactionType: FfiConverterString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                amount: FfiConverterDouble.read(from: &buf), 
                decimals: FfiConverterUInt32.read(from: &buf), 
                fromAddress: FfiConverterString.read(from: &buf), 
                toAddress: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTransactionMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.transactionType, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterDouble.write(value.amount, into: &buf)
        FfiConverterUInt32.write(value.decimals, into: &buf)
        FfiConverterString.write(value.fromAddress, into: &buf)
        FfiConverterString.write(value.toAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionMetadata_lift(_ buf: RustBuffer) throws -> FfiTransactionMetadata {
    return try FfiConverterTypeFfiTransactionMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionMetadata_lower(_ value: FfiTransactionMetadata) -> RustBuffer {
    return FfiConverterTypeFfiTransactionMetadata.lower(value)
}


public struct FfiTransactionReference {
    public var namespace: String?
    public var networkId: String
    public var reference: String
    public var metadata: FfiTransactionMetadata?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(namespace: String?, networkId: String, reference: String, metadata: FfiTransactionMetadata?) {
        self.namespace = namespace
        self.networkId = networkId
        self.reference = reference
        self.metadata = metadata
    }
}

#if compiler(>=6)
extension FfiTransactionReference: Sendable {}
#endif


extension FfiTransactionReference: Equatable, Hashable {
    public static func ==(lhs: FfiTransactionReference, rhs: FfiTransactionReference) -> Bool {
        if lhs.namespace != rhs.namespace {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.reference != rhs.reference {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(namespace)
        hasher.combine(networkId)
        hasher.combine(reference)
        hasher.combine(metadata)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTransactionReference: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTransactionReference {
        return
            try FfiTransactionReference(
                namespace: FfiConverterOptionString.read(from: &buf), 
                networkId: FfiConverterString.read(from: &buf), 
                reference: FfiConverterString.read(from: &buf), 
                metadata: FfiConverterOptionTypeFfiTransactionMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTransactionReference, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.namespace, into: &buf)
        FfiConverterString.write(value.networkId, into: &buf)
        FfiConverterString.write(value.reference, into: &buf)
        FfiConverterOptionTypeFfiTransactionMetadata.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionReference_lift(_ buf: RustBuffer) throws -> FfiTransactionReference {
    return try FfiConverterTypeFfiTransactionReference.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionReference_lower(_ value: FfiTransactionReference) -> RustBuffer {
    return FfiConverterTypeFfiTransactionReference.lower(value)
}


public struct FfiUpdateGroupMembershipResult {
    public var addedMembers: [String: UInt64]
    public var removedMembers: [String]
    public var failedInstallations: [Data]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addedMembers: [String: UInt64], removedMembers: [String], failedInstallations: [Data]) {
        self.addedMembers = addedMembers
        self.removedMembers = removedMembers
        self.failedInstallations = failedInstallations
    }
}

#if compiler(>=6)
extension FfiUpdateGroupMembershipResult: Sendable {}
#endif


extension FfiUpdateGroupMembershipResult: Equatable, Hashable {
    public static func ==(lhs: FfiUpdateGroupMembershipResult, rhs: FfiUpdateGroupMembershipResult) -> Bool {
        if lhs.addedMembers != rhs.addedMembers {
            return false
        }
        if lhs.removedMembers != rhs.removedMembers {
            return false
        }
        if lhs.failedInstallations != rhs.failedInstallations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addedMembers)
        hasher.combine(removedMembers)
        hasher.combine(failedInstallations)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiUpdateGroupMembershipResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUpdateGroupMembershipResult {
        return
            try FfiUpdateGroupMembershipResult(
                addedMembers: FfiConverterDictionaryStringUInt64.read(from: &buf), 
                removedMembers: FfiConverterSequenceString.read(from: &buf), 
                failedInstallations: FfiConverterSequenceData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiUpdateGroupMembershipResult, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringUInt64.write(value.addedMembers, into: &buf)
        FfiConverterSequenceString.write(value.removedMembers, into: &buf)
        FfiConverterSequenceData.write(value.failedInstallations, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiUpdateGroupMembershipResult_lift(_ buf: RustBuffer) throws -> FfiUpdateGroupMembershipResult {
    return try FfiConverterTypeFfiUpdateGroupMembershipResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiUpdateGroupMembershipResult_lower(_ value: FfiUpdateGroupMembershipResult) -> RustBuffer {
    return FfiConverterTypeFfiUpdateGroupMembershipResult.lower(value)
}


public struct FfiWalletCall {
    public var to: String?
    public var data: String?
    public var value: String?
    public var gas: String?
    public var metadata: FfiWalletCallMetadata?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(to: String?, data: String?, value: String?, gas: String?, metadata: FfiWalletCallMetadata?) {
        self.to = to
        self.data = data
        self.value = value
        self.gas = gas
        self.metadata = metadata
    }
}

#if compiler(>=6)
extension FfiWalletCall: Sendable {}
#endif


extension FfiWalletCall: Equatable, Hashable {
    public static func ==(lhs: FfiWalletCall, rhs: FfiWalletCall) -> Bool {
        if lhs.to != rhs.to {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.gas != rhs.gas {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(to)
        hasher.combine(data)
        hasher.combine(value)
        hasher.combine(gas)
        hasher.combine(metadata)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiWalletCall: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWalletCall {
        return
            try FfiWalletCall(
                to: FfiConverterOptionString.read(from: &buf), 
                data: FfiConverterOptionString.read(from: &buf), 
                value: FfiConverterOptionString.read(from: &buf), 
                gas: FfiConverterOptionString.read(from: &buf), 
                metadata: FfiConverterOptionTypeFfiWalletCallMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: FfiWalletCall, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.to, into: &buf)
        FfiConverterOptionString.write(value.data, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
        FfiConverterOptionString.write(value.gas, into: &buf)
        FfiConverterOptionTypeFfiWalletCallMetadata.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWalletCall_lift(_ buf: RustBuffer) throws -> FfiWalletCall {
    return try FfiConverterTypeFfiWalletCall.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWalletCall_lower(_ value: FfiWalletCall) -> RustBuffer {
    return FfiConverterTypeFfiWalletCall.lower(value)
}


public struct FfiWalletCallMetadata {
    public var description: String
    public var transactionType: String
    public var extra: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String, transactionType: String, extra: [String: String]) {
        self.description = description
        self.transactionType = transactionType
        self.extra = extra
    }
}

#if compiler(>=6)
extension FfiWalletCallMetadata: Sendable {}
#endif


extension FfiWalletCallMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiWalletCallMetadata, rhs: FfiWalletCallMetadata) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.transactionType != rhs.transactionType {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(transactionType)
        hasher.combine(extra)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiWalletCallMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWalletCallMetadata {
        return
            try FfiWalletCallMetadata(
                description: FfiConverterString.read(from: &buf), 
                transactionType: FfiConverterString.read(from: &buf), 
                extra: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiWalletCallMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.transactionType, into: &buf)
        FfiConverterDictionaryStringString.write(value.extra, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWalletCallMetadata_lift(_ buf: RustBuffer) throws -> FfiWalletCallMetadata {
    return try FfiConverterTypeFfiWalletCallMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWalletCallMetadata_lower(_ value: FfiWalletCallMetadata) -> RustBuffer {
    return FfiConverterTypeFfiWalletCallMetadata.lower(value)
}


public struct FfiWalletSendCalls {
    public var version: String
    public var chainId: String
    public var from: String
    public var calls: [FfiWalletCall]
    public var capabilities: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: String, chainId: String, from: String, calls: [FfiWalletCall], capabilities: [String: String]?) {
        self.version = version
        self.chainId = chainId
        self.from = from
        self.calls = calls
        self.capabilities = capabilities
    }
}

#if compiler(>=6)
extension FfiWalletSendCalls: Sendable {}
#endif


extension FfiWalletSendCalls: Equatable, Hashable {
    public static func ==(lhs: FfiWalletSendCalls, rhs: FfiWalletSendCalls) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.chainId != rhs.chainId {
            return false
        }
        if lhs.from != rhs.from {
            return false
        }
        if lhs.calls != rhs.calls {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(chainId)
        hasher.combine(from)
        hasher.combine(calls)
        hasher.combine(capabilities)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiWalletSendCalls: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWalletSendCalls {
        return
            try FfiWalletSendCalls(
                version: FfiConverterString.read(from: &buf), 
                chainId: FfiConverterString.read(from: &buf), 
                from: FfiConverterString.read(from: &buf), 
                calls: FfiConverterSequenceTypeFfiWalletCall.read(from: &buf), 
                capabilities: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiWalletSendCalls, into buf: inout [UInt8]) {
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterString.write(value.chainId, into: &buf)
        FfiConverterString.write(value.from, into: &buf)
        FfiConverterSequenceTypeFfiWalletCall.write(value.calls, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.capabilities, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWalletSendCalls_lift(_ buf: RustBuffer) throws -> FfiWalletSendCalls {
    return try FfiConverterTypeFfiWalletSendCalls.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWalletSendCalls_lower(_ value: FfiWalletSendCalls) -> RustBuffer {
    return FfiConverterTypeFfiWalletSendCalls.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiActionStyle {
    
    case primary
    case secondary
    case danger
}


#if compiler(>=6)
extension FfiActionStyle: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiActionStyle: FfiConverterRustBuffer {
    typealias SwiftType = FfiActionStyle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiActionStyle {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .primary
        
        case 2: return .secondary
        
        case 3: return .danger
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiActionStyle, into buf: inout [UInt8]) {
        switch value {
        
        
        case .primary:
            writeInt(&buf, Int32(1))
        
        
        case .secondary:
            writeInt(&buf, Int32(2))
        
        
        case .danger:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiActionStyle_lift(_ buf: RustBuffer) throws -> FfiActionStyle {
    return try FfiConverterTypeFfiActionStyle.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiActionStyle_lower(_ value: FfiActionStyle) -> RustBuffer {
    return FfiConverterTypeFfiActionStyle.lower(value)
}


extension FfiActionStyle: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiBackupElementSelection {
    
    case messages
    case consent
}


#if compiler(>=6)
extension FfiBackupElementSelection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiBackupElementSelection: FfiConverterRustBuffer {
    typealias SwiftType = FfiBackupElementSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBackupElementSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messages
        
        case 2: return .consent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiBackupElementSelection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .messages:
            writeInt(&buf, Int32(1))
        
        
        case .consent:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupElementSelection_lift(_ buf: RustBuffer) throws -> FfiBackupElementSelection {
    return try FfiConverterTypeFfiBackupElementSelection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupElementSelection_lower(_ value: FfiBackupElementSelection) -> RustBuffer {
    return FfiConverterTypeFfiBackupElementSelection.lower(value)
}


extension FfiBackupElementSelection: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiClientMode {
    
    case `default`
    case notification
}


#if compiler(>=6)
extension FfiClientMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiClientMode: FfiConverterRustBuffer {
    typealias SwiftType = FfiClientMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiClientMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .notification
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiClientMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .notification:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiClientMode_lift(_ buf: RustBuffer) throws -> FfiClientMode {
    return try FfiConverterTypeFfiClientMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiClientMode_lower(_ value: FfiClientMode) -> RustBuffer {
    return FfiConverterTypeFfiClientMode.lower(value)
}


extension FfiClientMode: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConsentEntityType {
    
    case conversationId
    case inboxId
}


#if compiler(>=6)
extension FfiConsentEntityType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsentEntityType: FfiConverterRustBuffer {
    typealias SwiftType = FfiConsentEntityType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentEntityType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .conversationId
        
        case 2: return .inboxId
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConsentEntityType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .conversationId:
            writeInt(&buf, Int32(1))
        
        
        case .inboxId:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentEntityType_lift(_ buf: RustBuffer) throws -> FfiConsentEntityType {
    return try FfiConverterTypeFfiConsentEntityType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentEntityType_lower(_ value: FfiConsentEntityType) -> RustBuffer {
    return FfiConverterTypeFfiConsentEntityType.lower(value)
}


extension FfiConsentEntityType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConsentState {
    
    case unknown
    case allowed
    case denied
}


#if compiler(>=6)
extension FfiConsentState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsentState: FfiConverterRustBuffer {
    typealias SwiftType = FfiConsentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .allowed
        
        case 3: return .denied
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConsentState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .allowed:
            writeInt(&buf, Int32(2))
        
        
        case .denied:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentState_lift(_ buf: RustBuffer) throws -> FfiConsentState {
    return try FfiConverterTypeFfiConsentState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentState_lower(_ value: FfiConsentState) -> RustBuffer {
    return FfiConverterTypeFfiConsentState.lower(value)
}


extension FfiConsentState: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiContentType {
    
    case unknown
    case text
    case groupMembershipChange
    case groupUpdated
    case reaction
    case readReceipt
    case reply
    case attachment
    case remoteAttachment
    case transactionReference
    case walletSendCalls
    case leaveRequest
    case markdown
    case actions
    case intent
    case multiRemoteAttachment
}


#if compiler(>=6)
extension FfiContentType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiContentType: FfiConverterRustBuffer {
    typealias SwiftType = FfiContentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiContentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .text
        
        case 3: return .groupMembershipChange
        
        case 4: return .groupUpdated
        
        case 5: return .reaction
        
        case 6: return .readReceipt
        
        case 7: return .reply
        
        case 8: return .attachment
        
        case 9: return .remoteAttachment
        
        case 10: return .transactionReference
        
        case 11: return .walletSendCalls
        
        case 12: return .leaveRequest
        
        case 13: return .markdown
        
        case 14: return .actions
        
        case 15: return .intent
        
        case 16: return .multiRemoteAttachment
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiContentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .text:
            writeInt(&buf, Int32(2))
        
        
        case .groupMembershipChange:
            writeInt(&buf, Int32(3))
        
        
        case .groupUpdated:
            writeInt(&buf, Int32(4))
        
        
        case .reaction:
            writeInt(&buf, Int32(5))
        
        
        case .readReceipt:
            writeInt(&buf, Int32(6))
        
        
        case .reply:
            writeInt(&buf, Int32(7))
        
        
        case .attachment:
            writeInt(&buf, Int32(8))
        
        
        case .remoteAttachment:
            writeInt(&buf, Int32(9))
        
        
        case .transactionReference:
            writeInt(&buf, Int32(10))
        
        
        case .walletSendCalls:
            writeInt(&buf, Int32(11))
        
        
        case .leaveRequest:
            writeInt(&buf, Int32(12))
        
        
        case .markdown:
            writeInt(&buf, Int32(13))
        
        
        case .actions:
            writeInt(&buf, Int32(14))
        
        
        case .intent:
            writeInt(&buf, Int32(15))
        
        
        case .multiRemoteAttachment:
            writeInt(&buf, Int32(16))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiContentType_lift(_ buf: RustBuffer) throws -> FfiContentType {
    return try FfiConverterTypeFfiContentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiContentType_lower(_ value: FfiContentType) -> RustBuffer {
    return FfiConverterTypeFfiContentType.lower(value)
}


extension FfiContentType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConversationMessageKind {
    
    case application
    case membershipChange
}


#if compiler(>=6)
extension FfiConversationMessageKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationMessageKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiConversationMessageKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationMessageKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .application
        
        case 2: return .membershipChange
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConversationMessageKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .application:
            writeInt(&buf, Int32(1))
        
        
        case .membershipChange:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMessageKind_lift(_ buf: RustBuffer) throws -> FfiConversationMessageKind {
    return try FfiConverterTypeFfiConversationMessageKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMessageKind_lower(_ value: FfiConversationMessageKind) -> RustBuffer {
    return FfiConverterTypeFfiConversationMessageKind.lower(value)
}


extension FfiConversationMessageKind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConversationType {
    
    case group
    case dm
    case sync
    case oneshot
}


#if compiler(>=6)
extension FfiConversationType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationType: FfiConverterRustBuffer {
    typealias SwiftType = FfiConversationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .group
        
        case 2: return .dm
        
        case 3: return .sync
        
        case 4: return .oneshot
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConversationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .group:
            writeInt(&buf, Int32(1))
        
        
        case .dm:
            writeInt(&buf, Int32(2))
        
        
        case .sync:
            writeInt(&buf, Int32(3))
        
        
        case .oneshot:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationType_lift(_ buf: RustBuffer) throws -> FfiConversationType {
    return try FfiConverterTypeFfiConversationType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationType_lower(_ value: FfiConversationType) -> RustBuffer {
    return FfiConverterTypeFfiConversationType.lower(value)
}


extension FfiConversationType: Equatable, Hashable {}







public enum FfiCryptoError: Swift.Error {

    
    
    case InvalidLength
    case InvalidKey
    case SignFailure
    case DecompressFailure
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCryptoError: FfiConverterRustBuffer {
    typealias SwiftType = FfiCryptoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCryptoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidLength
        case 2: return .InvalidKey
        case 3: return .SignFailure
        case 4: return .DecompressFailure

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiCryptoError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidLength:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidKey:
            writeInt(&buf, Int32(2))
        
        
        case .SignFailure:
            writeInt(&buf, Int32(3))
        
        
        case .DecompressFailure:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCryptoError_lift(_ buf: RustBuffer) throws -> FfiCryptoError {
    return try FfiConverterTypeFfiCryptoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCryptoError_lower(_ value: FfiCryptoError) -> RustBuffer {
    return FfiConverterTypeFfiCryptoError.lower(value)
}


extension FfiCryptoError: Equatable, Hashable {}




extension FfiCryptoError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDecodedMessageBody {
    
    case text(FfiTextContent
    )
    case markdown(FfiMarkdownContent
    )
    case reaction(FfiReactionPayload
    )
    case attachment(FfiAttachment
    )
    case remoteAttachment(FfiRemoteAttachment
    )
    case multiRemoteAttachment(FfiMultiRemoteAttachment
    )
    case transactionReference(FfiTransactionReference
    )
    case groupUpdated(FfiGroupUpdated
    )
    case readReceipt(FfiReadReceipt
    )
    case walletSendCalls(FfiWalletSendCalls
    )
    case intent(FfiIntent
    )
    case actions(FfiActions
    )
    case leaveRequest(FfiLeaveRequest
    )
    case deletedMessage(FfiDeletedMessage
    )
    case custom(FfiEncodedContent
    )
}


#if compiler(>=6)
extension FfiDecodedMessageBody: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDecodedMessageBody: FfiConverterRustBuffer {
    typealias SwiftType = FfiDecodedMessageBody

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDecodedMessageBody {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(try FfiConverterTypeFfiTextContent.read(from: &buf)
        )
        
        case 2: return .markdown(try FfiConverterTypeFfiMarkdownContent.read(from: &buf)
        )
        
        case 3: return .reaction(try FfiConverterTypeFfiReactionPayload.read(from: &buf)
        )
        
        case 4: return .attachment(try FfiConverterTypeFfiAttachment.read(from: &buf)
        )
        
        case 5: return .remoteAttachment(try FfiConverterTypeFfiRemoteAttachment.read(from: &buf)
        )
        
        case 6: return .multiRemoteAttachment(try FfiConverterTypeFfiMultiRemoteAttachment.read(from: &buf)
        )
        
        case 7: return .transactionReference(try FfiConverterTypeFfiTransactionReference.read(from: &buf)
        )
        
        case 8: return .groupUpdated(try FfiConverterTypeFfiGroupUpdated.read(from: &buf)
        )
        
        case 9: return .readReceipt(try FfiConverterTypeFfiReadReceipt.read(from: &buf)
        )
        
        case 10: return .walletSendCalls(try FfiConverterTypeFfiWalletSendCalls.read(from: &buf)
        )
        
        case 11: return .intent(try FfiConverterTypeFfiIntent.read(from: &buf)
        )
        
        case 12: return .actions(try FfiConverterTypeFfiActions.read(from: &buf)
        )
        
        case 13: return .leaveRequest(try FfiConverterTypeFfiLeaveRequest.read(from: &buf)
        )
        
        case 14: return .deletedMessage(try FfiConverterTypeFfiDeletedMessage.read(from: &buf)
        )
        
        case 15: return .custom(try FfiConverterTypeFfiEncodedContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDecodedMessageBody, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFfiTextContent.write(v1, into: &buf)
            
        
        case let .markdown(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFfiMarkdownContent.write(v1, into: &buf)
            
        
        case let .reaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFfiReactionPayload.write(v1, into: &buf)
            
        
        case let .attachment(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFfiAttachment.write(v1, into: &buf)
            
        
        case let .remoteAttachment(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFfiRemoteAttachment.write(v1, into: &buf)
            
        
        case let .multiRemoteAttachment(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFfiMultiRemoteAttachment.write(v1, into: &buf)
            
        
        case let .transactionReference(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFfiTransactionReference.write(v1, into: &buf)
            
        
        case let .groupUpdated(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeFfiGroupUpdated.write(v1, into: &buf)
            
        
        case let .readReceipt(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeFfiReadReceipt.write(v1, into: &buf)
            
        
        case let .walletSendCalls(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeFfiWalletSendCalls.write(v1, into: &buf)
            
        
        case let .intent(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeFfiIntent.write(v1, into: &buf)
            
        
        case let .actions(v1):
            writeInt(&buf, Int32(12))
            FfiConverterTypeFfiActions.write(v1, into: &buf)
            
        
        case let .leaveRequest(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeFfiLeaveRequest.write(v1, into: &buf)
            
        
        case let .deletedMessage(v1):
            writeInt(&buf, Int32(14))
            FfiConverterTypeFfiDeletedMessage.write(v1, into: &buf)
            
        
        case let .custom(v1):
            writeInt(&buf, Int32(15))
            FfiConverterTypeFfiEncodedContent.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessageBody_lift(_ buf: RustBuffer) throws -> FfiDecodedMessageBody {
    return try FfiConverterTypeFfiDecodedMessageBody.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessageBody_lower(_ value: FfiDecodedMessageBody) -> RustBuffer {
    return FfiConverterTypeFfiDecodedMessageBody.lower(value)
}


extension FfiDecodedMessageBody: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDecodedMessageContent {
    
    case text(FfiTextContent
    )
    case markdown(FfiMarkdownContent
    )
    case reply(FfiEnrichedReply
    )
    case reaction(FfiReactionPayload
    )
    case attachment(FfiAttachment
    )
    case remoteAttachment(FfiRemoteAttachment
    )
    case multiRemoteAttachment(FfiMultiRemoteAttachment
    )
    case transactionReference(FfiTransactionReference
    )
    case groupUpdated(FfiGroupUpdated
    )
    case readReceipt(FfiReadReceipt
    )
    case walletSendCalls(FfiWalletSendCalls
    )
    case intent(FfiIntent?
    )
    case actions(FfiActions?
    )
    case leaveRequest(FfiLeaveRequest
    )
    case deletedMessage(FfiDeletedMessage
    )
    case custom(FfiEncodedContent
    )
}


#if compiler(>=6)
extension FfiDecodedMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDecodedMessageContent: FfiConverterRustBuffer {
    typealias SwiftType = FfiDecodedMessageContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDecodedMessageContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(try FfiConverterTypeFfiTextContent.read(from: &buf)
        )
        
        case 2: return .markdown(try FfiConverterTypeFfiMarkdownContent.read(from: &buf)
        )
        
        case 3: return .reply(try FfiConverterTypeFfiEnrichedReply.read(from: &buf)
        )
        
        case 4: return .reaction(try FfiConverterTypeFfiReactionPayload.read(from: &buf)
        )
        
        case 5: return .attachment(try FfiConverterTypeFfiAttachment.read(from: &buf)
        )
        
        case 6: return .remoteAttachment(try FfiConverterTypeFfiRemoteAttachment.read(from: &buf)
        )
        
        case 7: return .multiRemoteAttachment(try FfiConverterTypeFfiMultiRemoteAttachment.read(from: &buf)
        )
        
        case 8: return .transactionReference(try FfiConverterTypeFfiTransactionReference.read(from: &buf)
        )
        
        case 9: return .groupUpdated(try FfiConverterTypeFfiGroupUpdated.read(from: &buf)
        )
        
        case 10: return .readReceipt(try FfiConverterTypeFfiReadReceipt.read(from: &buf)
        )
        
        case 11: return .walletSendCalls(try FfiConverterTypeFfiWalletSendCalls.read(from: &buf)
        )
        
        case 12: return .intent(try FfiConverterOptionTypeFfiIntent.read(from: &buf)
        )
        
        case 13: return .actions(try FfiConverterOptionTypeFfiActions.read(from: &buf)
        )
        
        case 14: return .leaveRequest(try FfiConverterTypeFfiLeaveRequest.read(from: &buf)
        )
        
        case 15: return .deletedMessage(try FfiConverterTypeFfiDeletedMessage.read(from: &buf)
        )
        
        case 16: return .custom(try FfiConverterTypeFfiEncodedContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDecodedMessageContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFfiTextContent.write(v1, into: &buf)
            
        
        case let .markdown(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFfiMarkdownContent.write(v1, into: &buf)
            
        
        case let .reply(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFfiEnrichedReply.write(v1, into: &buf)
            
        
        case let .reaction(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFfiReactionPayload.write(v1, into: &buf)
            
        
        case let .attachment(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFfiAttachment.write(v1, into: &buf)
            
        
        case let .remoteAttachment(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFfiRemoteAttachment.write(v1, into: &buf)
            
        
        case let .multiRemoteAttachment(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFfiMultiRemoteAttachment.write(v1, into: &buf)
            
        
        case let .transactionReference(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeFfiTransactionReference.write(v1, into: &buf)
            
        
        case let .groupUpdated(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeFfiGroupUpdated.write(v1, into: &buf)
            
        
        case let .readReceipt(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeFfiReadReceipt.write(v1, into: &buf)
            
        
        case let .walletSendCalls(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeFfiWalletSendCalls.write(v1, into: &buf)
            
        
        case let .intent(v1):
            writeInt(&buf, Int32(12))
            FfiConverterOptionTypeFfiIntent.write(v1, into: &buf)
            
        
        case let .actions(v1):
            writeInt(&buf, Int32(13))
            FfiConverterOptionTypeFfiActions.write(v1, into: &buf)
            
        
        case let .leaveRequest(v1):
            writeInt(&buf, Int32(14))
            FfiConverterTypeFfiLeaveRequest.write(v1, into: &buf)
            
        
        case let .deletedMessage(v1):
            writeInt(&buf, Int32(15))
            FfiConverterTypeFfiDeletedMessage.write(v1, into: &buf)
            
        
        case let .custom(v1):
            writeInt(&buf, Int32(16))
            FfiConverterTypeFfiEncodedContent.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessageContent_lift(_ buf: RustBuffer) throws -> FfiDecodedMessageContent {
    return try FfiConverterTypeFfiDecodedMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDecodedMessageContent_lower(_ value: FfiDecodedMessageContent) -> RustBuffer {
    return FfiConverterTypeFfiDecodedMessageContent.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDeletedBy {
    
    case sender
    case admin(inboxId: String
    )
}


#if compiler(>=6)
extension FfiDeletedBy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDeletedBy: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeletedBy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeletedBy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sender
        
        case 2: return .admin(inboxId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDeletedBy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sender:
            writeInt(&buf, Int32(1))
        
        
        case let .admin(inboxId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(inboxId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeletedBy_lift(_ buf: RustBuffer) throws -> FfiDeletedBy {
    return try FfiConverterTypeFfiDeletedBy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeletedBy_lower(_ value: FfiDeletedBy) -> RustBuffer {
    return FfiConverterTypeFfiDeletedBy.lower(value)
}


extension FfiDeletedBy: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDeliveryStatus {
    
    case unpublished
    case published
    case failed
}


#if compiler(>=6)
extension FfiDeliveryStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDeliveryStatus: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeliveryStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeliveryStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unpublished
        
        case 2: return .published
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDeliveryStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unpublished:
            writeInt(&buf, Int32(1))
        
        
        case .published:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeliveryStatus_lift(_ buf: RustBuffer) throws -> FfiDeliveryStatus {
    return try FfiConverterTypeFfiDeliveryStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeliveryStatus_lower(_ value: FfiDeliveryStatus) -> RustBuffer {
    return FfiConverterTypeFfiDeliveryStatus.lower(value)
}


extension FfiDeliveryStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDeviceSyncMode {
    
    case enabled
    case disabled
}


#if compiler(>=6)
extension FfiDeviceSyncMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDeviceSyncMode: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeviceSyncMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeviceSyncMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .enabled
        
        case 2: return .disabled
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDeviceSyncMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .enabled:
            writeInt(&buf, Int32(1))
        
        
        case .disabled:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeviceSyncMode_lift(_ buf: RustBuffer) throws -> FfiDeviceSyncMode {
    return try FfiConverterTypeFfiDeviceSyncMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeviceSyncMode_lower(_ value: FfiDeviceSyncMode) -> RustBuffer {
    return FfiConverterTypeFfiDeviceSyncMode.lower(value)
}


extension FfiDeviceSyncMode: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDirection {
    
    case ascending
    case descending
}


#if compiler(>=6)
extension FfiDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDirection: FfiConverterRustBuffer {
    typealias SwiftType = FfiDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ascending
        
        case 2: return .descending
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ascending:
            writeInt(&buf, Int32(1))
        
        
        case .descending:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDirection_lift(_ buf: RustBuffer) throws -> FfiDirection {
    return try FfiConverterTypeFfiDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDirection_lower(_ value: FfiDirection) -> RustBuffer {
    return FfiConverterTypeFfiDirection.lower(value)
}


extension FfiDirection: Equatable, Hashable {}







/**
 * Wrapper that formats errors as `[error_code] message` for mobile SDKs.
 * UniFFI uses Display to convert errors to strings, so this wrapper
 * ensures mobile clients receive machine-readable error codes.
 */
public enum FfiError: Swift.Error {

    
    
    case Error(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiError: FfiConverterRustBuffer {
    typealias SwiftType = FfiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Error(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Error(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiError_lift(_ buf: RustBuffer) throws -> FfiError {
    return try FfiConverterTypeFfiError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiError_lower(_ value: FfiError) -> RustBuffer {
    return FfiConverterTypeFfiError.lower(value)
}


extension FfiError: Equatable, Hashable {}




extension FfiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiForkRecoveryPolicy {
    
    case none
    case allowlistedGroups
    case all
}


#if compiler(>=6)
extension FfiForkRecoveryPolicy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiForkRecoveryPolicy: FfiConverterRustBuffer {
    typealias SwiftType = FfiForkRecoveryPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiForkRecoveryPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .allowlistedGroups
        
        case 3: return .all
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiForkRecoveryPolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .allowlistedGroups:
            writeInt(&buf, Int32(2))
        
        
        case .all:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiForkRecoveryPolicy_lift(_ buf: RustBuffer) throws -> FfiForkRecoveryPolicy {
    return try FfiConverterTypeFfiForkRecoveryPolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiForkRecoveryPolicy_lower(_ value: FfiForkRecoveryPolicy) -> RustBuffer {
    return FfiConverterTypeFfiForkRecoveryPolicy.lower(value)
}


extension FfiForkRecoveryPolicy: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiGroupMembershipState {
    
    case allowed
    case rejected
    case pending
    case restored
    case pendingRemove
}


#if compiler(>=6)
extension FfiGroupMembershipState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupMembershipState: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupMembershipState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupMembershipState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allowed
        
        case 2: return .rejected
        
        case 3: return .pending
        
        case 4: return .restored
        
        case 5: return .pendingRemove
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiGroupMembershipState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allowed:
            writeInt(&buf, Int32(1))
        
        
        case .rejected:
            writeInt(&buf, Int32(2))
        
        
        case .pending:
            writeInt(&buf, Int32(3))
        
        
        case .restored:
            writeInt(&buf, Int32(4))
        
        
        case .pendingRemove:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupMembershipState_lift(_ buf: RustBuffer) throws -> FfiGroupMembershipState {
    return try FfiConverterTypeFfiGroupMembershipState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupMembershipState_lower(_ value: FfiGroupMembershipState) -> RustBuffer {
    return FfiConverterTypeFfiGroupMembershipState.lower(value)
}


extension FfiGroupMembershipState: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiGroupMessageKind {
    
    case application
    case membershipChange
}


#if compiler(>=6)
extension FfiGroupMessageKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupMessageKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupMessageKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupMessageKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .application
        
        case 2: return .membershipChange
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiGroupMessageKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .application:
            writeInt(&buf, Int32(1))
        
        
        case .membershipChange:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupMessageKind_lift(_ buf: RustBuffer) throws -> FfiGroupMessageKind {
    return try FfiConverterTypeFfiGroupMessageKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupMessageKind_lower(_ value: FfiGroupMessageKind) -> RustBuffer {
    return FfiConverterTypeFfiGroupMessageKind.lower(value)
}


extension FfiGroupMessageKind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiGroupPermissionsOptions {
    
    case `default`
    case adminOnly
    case customPolicy
}


#if compiler(>=6)
extension FfiGroupPermissionsOptions: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupPermissionsOptions: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupPermissionsOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupPermissionsOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .adminOnly
        
        case 3: return .customPolicy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiGroupPermissionsOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .adminOnly:
            writeInt(&buf, Int32(2))
        
        
        case .customPolicy:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissionsOptions_lift(_ buf: RustBuffer) throws -> FfiGroupPermissionsOptions {
    return try FfiConverterTypeFfiGroupPermissionsOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissionsOptions_lower(_ value: FfiGroupPermissionsOptions) -> RustBuffer {
    return FfiConverterTypeFfiGroupPermissionsOptions.lower(value)
}


extension FfiGroupPermissionsOptions: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiGroupQueryOrderBy {
    
    case createdAt
    case lastActivity
}


#if compiler(>=6)
extension FfiGroupQueryOrderBy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupQueryOrderBy: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupQueryOrderBy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupQueryOrderBy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .createdAt
        
        case 2: return .lastActivity
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiGroupQueryOrderBy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .createdAt:
            writeInt(&buf, Int32(1))
        
        
        case .lastActivity:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupQueryOrderBy_lift(_ buf: RustBuffer) throws -> FfiGroupQueryOrderBy {
    return try FfiConverterTypeFfiGroupQueryOrderBy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupQueryOrderBy_lower(_ value: FfiGroupQueryOrderBy) -> RustBuffer {
    return FfiConverterTypeFfiGroupQueryOrderBy.lower(value)
}


extension FfiGroupQueryOrderBy: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiIdentifierKind {
    
    case ethereum
    case passkey
}


#if compiler(>=6)
extension FfiIdentifierKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiIdentifierKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiIdentifierKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiIdentifierKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ethereum
        
        case 2: return .passkey
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiIdentifierKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ethereum:
            writeInt(&buf, Int32(1))
        
        
        case .passkey:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifierKind_lift(_ buf: RustBuffer) throws -> FfiIdentifierKind {
    return try FfiConverterTypeFfiIdentifierKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifierKind_lower(_ value: FfiIdentifierKind) -> RustBuffer {
    return FfiConverterTypeFfiIdentifierKind.lower(value)
}


extension FfiIdentifierKind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing log levels
 */

public enum FfiLogLevel {
    
    /**
     * Error level logs only
     */
    case error
    /**
     * Warning level and above
     */
    case warn
    /**
     * Info level and above
     */
    case info
    /**
     * Debug level and above
     */
    case debug
    /**
     * Trace level and all logs
     */
    case trace
}


#if compiler(>=6)
extension FfiLogLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = FfiLogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiLogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiLogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogLevel_lift(_ buf: RustBuffer) throws -> FfiLogLevel {
    return try FfiConverterTypeFfiLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogLevel_lower(_ value: FfiLogLevel) -> RustBuffer {
    return FfiConverterTypeFfiLogLevel.lower(value)
}


extension FfiLogLevel: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing log file rotation options
 */

public enum FfiLogRotation {
    
    /**
     * Rotate log files every minute
     */
    case minutely
    /**
     * Rotate log files every hour
     */
    case hourly
    /**
     * Rotate log files every day
     */
    case daily
    /**
     * Never rotate log files
     */
    case never
}


#if compiler(>=6)
extension FfiLogRotation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiLogRotation: FfiConverterRustBuffer {
    typealias SwiftType = FfiLogRotation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiLogRotation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .minutely
        
        case 2: return .hourly
        
        case 3: return .daily
        
        case 4: return .never
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiLogRotation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .minutely:
            writeInt(&buf, Int32(1))
        
        
        case .hourly:
            writeInt(&buf, Int32(2))
        
        
        case .daily:
            writeInt(&buf, Int32(3))
        
        
        case .never:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogRotation_lift(_ buf: RustBuffer) throws -> FfiLogRotation {
    return try FfiConverterTypeFfiLogRotation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogRotation_lower(_ value: FfiLogRotation) -> RustBuffer {
    return FfiConverterTypeFfiLogRotation.lower(value)
}


extension FfiLogRotation: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiMetadataField {
    
    case groupName
    case description
    case imageUrlSquare
    case appData
}


#if compiler(>=6)
extension FfiMetadataField: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMetadataField: FfiConverterRustBuffer {
    typealias SwiftType = FfiMetadataField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMetadataField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .groupName
        
        case 2: return .description
        
        case 3: return .imageUrlSquare
        
        case 4: return .appData
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiMetadataField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .groupName:
            writeInt(&buf, Int32(1))
        
        
        case .description:
            writeInt(&buf, Int32(2))
        
        
        case .imageUrlSquare:
            writeInt(&buf, Int32(3))
        
        
        case .appData:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMetadataField_lift(_ buf: RustBuffer) throws -> FfiMetadataField {
    return try FfiConverterTypeFfiMetadataField.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMetadataField_lower(_ value: FfiMetadataField) -> RustBuffer {
    return FfiConverterTypeFfiMetadataField.lower(value)
}


extension FfiMetadataField: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionLevel {
    
    case member
    case admin
    case superAdmin
}


#if compiler(>=6)
extension FfiPermissionLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionLevel: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .member
        
        case 2: return .admin
        
        case 3: return .superAdmin
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .member:
            writeInt(&buf, Int32(1))
        
        
        case .admin:
            writeInt(&buf, Int32(2))
        
        
        case .superAdmin:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionLevel_lift(_ buf: RustBuffer) throws -> FfiPermissionLevel {
    return try FfiConverterTypeFfiPermissionLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionLevel_lower(_ value: FfiPermissionLevel) -> RustBuffer {
    return FfiConverterTypeFfiPermissionLevel.lower(value)
}


extension FfiPermissionLevel: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionPolicy {
    
    case allow
    case deny
    case admin
    case superAdmin
    case doesNotExist
    case other
}


#if compiler(>=6)
extension FfiPermissionPolicy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionPolicy: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allow
        
        case 2: return .deny
        
        case 3: return .admin
        
        case 4: return .superAdmin
        
        case 5: return .doesNotExist
        
        case 6: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionPolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allow:
            writeInt(&buf, Int32(1))
        
        
        case .deny:
            writeInt(&buf, Int32(2))
        
        
        case .admin:
            writeInt(&buf, Int32(3))
        
        
        case .superAdmin:
            writeInt(&buf, Int32(4))
        
        
        case .doesNotExist:
            writeInt(&buf, Int32(5))
        
        
        case .other:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicy_lift(_ buf: RustBuffer) throws -> FfiPermissionPolicy {
    return try FfiConverterTypeFfiPermissionPolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicy_lower(_ value: FfiPermissionPolicy) -> RustBuffer {
    return FfiConverterTypeFfiPermissionPolicy.lower(value)
}


extension FfiPermissionPolicy: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionUpdateType {
    
    case addMember
    case removeMember
    case addAdmin
    case removeAdmin
    case updateMetadata
}


#if compiler(>=6)
extension FfiPermissionUpdateType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionUpdateType: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionUpdateType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionUpdateType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .addMember
        
        case 2: return .removeMember
        
        case 3: return .addAdmin
        
        case 4: return .removeAdmin
        
        case 5: return .updateMetadata
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionUpdateType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .addMember:
            writeInt(&buf, Int32(1))
        
        
        case .removeMember:
            writeInt(&buf, Int32(2))
        
        
        case .addAdmin:
            writeInt(&buf, Int32(3))
        
        
        case .removeAdmin:
            writeInt(&buf, Int32(4))
        
        
        case .updateMetadata:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionUpdateType_lift(_ buf: RustBuffer) throws -> FfiPermissionUpdateType {
    return try FfiConverterTypeFfiPermissionUpdateType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionUpdateType_lower(_ value: FfiPermissionUpdateType) -> RustBuffer {
    return FfiConverterTypeFfiPermissionUpdateType.lower(value)
}


extension FfiPermissionUpdateType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPreferenceUpdate {
    
    case hmac(key: Data
    )
}


#if compiler(>=6)
extension FfiPreferenceUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = FfiPreferenceUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPreferenceUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hmac(key: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPreferenceUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .hmac(key):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(key, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceUpdate_lift(_ buf: RustBuffer) throws -> FfiPreferenceUpdate {
    return try FfiConverterTypeFfiPreferenceUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceUpdate_lower(_ value: FfiPreferenceUpdate) -> RustBuffer {
    return FfiConverterTypeFfiPreferenceUpdate.lower(value)
}


extension FfiPreferenceUpdate: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing process types for logging
 */

public enum FfiProcessType {
    
    /**
     * Main application process
     */
    case main
    /**
     * Notification extension/service process
     */
    case notificationExtension
}


#if compiler(>=6)
extension FfiProcessType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiProcessType: FfiConverterRustBuffer {
    typealias SwiftType = FfiProcessType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiProcessType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .main
        
        case 2: return .notificationExtension
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiProcessType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .main:
            writeInt(&buf, Int32(1))
        
        
        case .notificationExtension:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiProcessType_lift(_ buf: RustBuffer) throws -> FfiProcessType {
    return try FfiConverterTypeFfiProcessType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiProcessType_lower(_ value: FfiProcessType) -> RustBuffer {
    return FfiConverterTypeFfiProcessType.lower(value)
}


extension FfiProcessType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiReactionAction {
    
    case unknown
    case added
    case removed
}


#if compiler(>=6)
extension FfiReactionAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReactionAction: FfiConverterRustBuffer {
    typealias SwiftType = FfiReactionAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReactionAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .added
        
        case 3: return .removed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiReactionAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .added:
            writeInt(&buf, Int32(2))
        
        
        case .removed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionAction_lift(_ buf: RustBuffer) throws -> FfiReactionAction {
    return try FfiConverterTypeFfiReactionAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionAction_lower(_ value: FfiReactionAction) -> RustBuffer {
    return FfiConverterTypeFfiReactionAction.lower(value)
}


extension FfiReactionAction: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiReactionSchema {
    
    case unknown
    case unicode
    case shortcode
    case custom
}


#if compiler(>=6)
extension FfiReactionSchema: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReactionSchema: FfiConverterRustBuffer {
    typealias SwiftType = FfiReactionSchema

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReactionSchema {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .unicode
        
        case 3: return .shortcode
        
        case 4: return .custom
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiReactionSchema, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .unicode:
            writeInt(&buf, Int32(2))
        
        
        case .shortcode:
            writeInt(&buf, Int32(3))
        
        
        case .custom:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionSchema_lift(_ buf: RustBuffer) throws -> FfiReactionSchema {
    return try FfiConverterTypeFfiReactionSchema.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionSchema_lower(_ value: FfiReactionSchema) -> RustBuffer {
    return FfiConverterTypeFfiReactionSchema.lower(value)
}


extension FfiReactionSchema: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Signature kind used in identity operations
 */

public enum FfiSignatureKind {
    
    /**
     * ERC-191 signature (Externally Owned Account/EOA)
     */
    case erc191
    /**
     * ERC-1271 signature (Smart Contract Wallet/SCW)
     */
    case erc1271
    /**
     * Installation key signature
     */
    case installationKey
    /**
     * Legacy delegated signature
     */
    case legacyDelegated
    /**
     * P256 passkey signature
     */
    case p256
}


#if compiler(>=6)
extension FfiSignatureKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSignatureKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiSignatureKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSignatureKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .erc191
        
        case 2: return .erc1271
        
        case 3: return .installationKey
        
        case 4: return .legacyDelegated
        
        case 5: return .p256
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSignatureKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .erc191:
            writeInt(&buf, Int32(1))
        
        
        case .erc1271:
            writeInt(&buf, Int32(2))
        
        
        case .installationKey:
            writeInt(&buf, Int32(3))
        
        
        case .legacyDelegated:
            writeInt(&buf, Int32(4))
        
        
        case .p256:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignatureKind_lift(_ buf: RustBuffer) throws -> FfiSignatureKind {
    return try FfiConverterTypeFfiSignatureKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignatureKind_lower(_ value: FfiSignatureKind) -> RustBuffer {
    return FfiConverterTypeFfiSignatureKind.lower(value)
}


extension FfiSignatureKind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiSortBy {
    
    case sentAt
    case insertedAt
}


#if compiler(>=6)
extension FfiSortBy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSortBy: FfiConverterRustBuffer {
    typealias SwiftType = FfiSortBy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSortBy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sentAt
        
        case 2: return .insertedAt
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSortBy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sentAt:
            writeInt(&buf, Int32(1))
        
        
        case .insertedAt:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSortBy_lift(_ buf: RustBuffer) throws -> FfiSortBy {
    return try FfiConverterTypeFfiSortBy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSortBy_lower(_ value: FfiSortBy) -> RustBuffer {
    return FfiConverterTypeFfiSortBy.lower(value)
}


extension FfiSortBy: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiSyncMetric {
    
    case `init`
    case syncGroupCreated
    case syncGroupWelcomesProcessed
    case requestReceived
    case payloadSent
    case payloadProcessed
    case hmacSent
    case hmacReceived
    case consentSent
    case consentReceived
}


#if compiler(>=6)
extension FfiSyncMetric: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSyncMetric: FfiConverterRustBuffer {
    typealias SwiftType = FfiSyncMetric

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSyncMetric {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`init`
        
        case 2: return .syncGroupCreated
        
        case 3: return .syncGroupWelcomesProcessed
        
        case 4: return .requestReceived
        
        case 5: return .payloadSent
        
        case 6: return .payloadProcessed
        
        case 7: return .hmacSent
        
        case 8: return .hmacReceived
        
        case 9: return .consentSent
        
        case 10: return .consentReceived
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSyncMetric, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`init`:
            writeInt(&buf, Int32(1))
        
        
        case .syncGroupCreated:
            writeInt(&buf, Int32(2))
        
        
        case .syncGroupWelcomesProcessed:
            writeInt(&buf, Int32(3))
        
        
        case .requestReceived:
            writeInt(&buf, Int32(4))
        
        
        case .payloadSent:
            writeInt(&buf, Int32(5))
        
        
        case .payloadProcessed:
            writeInt(&buf, Int32(6))
        
        
        case .hmacSent:
            writeInt(&buf, Int32(7))
        
        
        case .hmacReceived:
            writeInt(&buf, Int32(8))
        
        
        case .consentSent:
            writeInt(&buf, Int32(9))
        
        
        case .consentReceived:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncMetric_lift(_ buf: RustBuffer) throws -> FfiSyncMetric {
    return try FfiConverterTypeFfiSyncMetric.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncMetric_lower(_ value: FfiSyncMetric) -> RustBuffer {
    return FfiConverterTypeFfiSyncMetric.lower(value)
}


extension FfiSyncMetric: Equatable, Hashable {}







public enum IdentityValidationError: Swift.Error {

    
    
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityValidationError: FfiConverterRustBuffer {
    typealias SwiftType = IdentityValidationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityValidationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IdentityValidationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityValidationError_lift(_ buf: RustBuffer) throws -> IdentityValidationError {
    return try FfiConverterTypeIdentityValidationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityValidationError_lower(_ value: IdentityValidationError) -> RustBuffer {
    return FfiConverterTypeIdentityValidationError.lower(value)
}


extension IdentityValidationError: Equatable, Hashable {}




extension IdentityValidationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum SigningError: Swift.Error {

    
    
    case Generic
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSigningError: FfiConverterRustBuffer {
    typealias SwiftType = SigningError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SigningError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SigningError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Generic:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningError_lift(_ buf: RustBuffer) throws -> SigningError {
    return try FfiConverterTypeSigningError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningError_lower(_ value: SigningError) -> RustBuffer {
    return FfiConverterTypeSigningError.lower(value)
}


extension SigningError: Equatable, Hashable {}




extension SigningError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiAuthCallback: FfiConverterRustBuffer {
    typealias SwiftType = FfiAuthCallback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiAuthCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiAuthCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiAuthHandle: FfiConverterRustBuffer {
    typealias SwiftType = FfiAuthHandle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiAuthHandle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiAuthHandle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiDecodedMessage: FfiConverterRustBuffer {
    typealias SwiftType = FfiDecodedMessage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDecodedMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDecodedMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiSignatureRequest: FfiConverterRustBuffer {
    typealias SwiftType = FfiSignatureRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiSignatureRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiSignatureRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiActions: FfiConverterRustBuffer {
    typealias SwiftType = FfiActions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiActions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiActions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiContentTypeId: FfiConverterRustBuffer {
    typealias SwiftType = FfiContentTypeId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiContentTypeId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiContentTypeId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiForkRecoveryOpts: FfiConverterRustBuffer {
    typealias SwiftType = FfiForkRecoveryOpts?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiForkRecoveryOpts.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiForkRecoveryOpts.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiIntent: FfiConverterRustBuffer {
    typealias SwiftType = FfiIntent?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiIntent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiIntent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiLifetime: FfiConverterRustBuffer {
    typealias SwiftType = FfiLifetime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiLifetime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiLifetime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiMessage: FfiConverterRustBuffer {
    typealias SwiftType = FfiMessage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiMessageDisappearingSettings: FfiConverterRustBuffer {
    typealias SwiftType = FfiMessageDisappearingSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiMessageDisappearingSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiMessageDisappearingSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiPermissionPolicySet: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionPolicySet?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiPermissionPolicySet.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiPermissionPolicySet.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiTransactionMetadata: FfiConverterRustBuffer {
    typealias SwiftType = FfiTransactionMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiTransactionMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiTransactionMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiWalletCallMetadata: FfiConverterRustBuffer {
    typealias SwiftType = FfiWalletCallMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiWalletCallMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiWalletCallMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiActionStyle: FfiConverterRustBuffer {
    typealias SwiftType = FfiActionStyle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiActionStyle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiActionStyle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiClientMode: FfiConverterRustBuffer {
    typealias SwiftType = FfiClientMode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiClientMode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiClientMode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiConversationType: FfiConverterRustBuffer {
    typealias SwiftType = FfiConversationType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiConversationType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiConversationType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiDecodedMessageBody: FfiConverterRustBuffer {
    typealias SwiftType = FfiDecodedMessageBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDecodedMessageBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDecodedMessageBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiDeliveryStatus: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeliveryStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDeliveryStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDeliveryStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiDeviceSyncMode: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeviceSyncMode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDeviceSyncMode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDeviceSyncMode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiDirection: FfiConverterRustBuffer {
    typealias SwiftType = FfiDirection?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDirection.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDirection.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiGroupPermissionsOptions: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupPermissionsOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiGroupPermissionsOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiGroupPermissionsOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiGroupQueryOrderBy: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupQueryOrderBy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiGroupQueryOrderBy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiGroupQueryOrderBy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiMetadataField: FfiConverterRustBuffer {
    typealias SwiftType = FfiMetadataField?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiMetadataField.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiMetadataField.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiSignatureKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiSignatureKind?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiSignatureKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiSignatureKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiSortBy: FfiConverterRustBuffer {
    typealias SwiftType = FfiSortBy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiSortBy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiSortBy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeFfiConsentState: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConsentState]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFfiConsentState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFfiConsentState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeFfiContentType: FfiConverterRustBuffer {
    typealias SwiftType = [FfiContentType]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFfiContentType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFfiContentType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConversation: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConversation]

    public static func write(_ value: [FfiConversation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConversation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConversation] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConversation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConversation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConversationListItem: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConversationListItem]

    public static func write(_ value: [FfiConversationListItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConversationListItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConversationListItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConversationListItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConversationListItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiDecodedMessage: FfiConverterRustBuffer {
    typealias SwiftType = [FfiDecodedMessage]

    public static func write(_ value: [FfiDecodedMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiDecodedMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiDecodedMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiDecodedMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiDecodedMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiAction: FfiConverterRustBuffer {
    typealias SwiftType = [FfiAction]

    public static func write(_ value: [FfiAction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiAction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiAction] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiAction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiAction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiAvailableArchive: FfiConverterRustBuffer {
    typealias SwiftType = [FfiAvailableArchive]

    public static func write(_ value: [FfiAvailableArchive], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiAvailableArchive.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiAvailableArchive] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiAvailableArchive]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiAvailableArchive.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConsent: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConsent]

    public static func write(_ value: [FfiConsent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConsent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConsent] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConsent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConsent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConversationMember: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConversationMember]

    public static func write(_ value: [FfiConversationMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConversationMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConversationMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConversationMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConversationMember.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiCursor: FfiConverterRustBuffer {
    typealias SwiftType = [FfiCursor]

    public static func write(_ value: [FfiCursor], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiCursor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiCursor] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiCursor]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiCursor.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiHmacKey: FfiConverterRustBuffer {
    typealias SwiftType = [FfiHmacKey]

    public static func write(_ value: [FfiHmacKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiHmacKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiHmacKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiHmacKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiHmacKey.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [FfiIdentifier]

    public static func write(_ value: [FfiIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiIdentifier.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiInbox: FfiConverterRustBuffer {
    typealias SwiftType = [FfiInbox]

    public static func write(_ value: [FfiInbox], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiInbox.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiInbox] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiInbox]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiInbox.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiInboxState: FfiConverterRustBuffer {
    typealias SwiftType = [FfiInboxState]

    public static func write(_ value: [FfiInboxState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiInboxState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiInboxState] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiInboxState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiInboxState.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiInstallation: FfiConverterRustBuffer {
    typealias SwiftType = [FfiInstallation]

    public static func write(_ value: [FfiInstallation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiInstallation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiInstallation] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiInstallation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiInstallation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiMessage: FfiConverterRustBuffer {
    typealias SwiftType = [FfiMessage]

    public static func write(_ value: [FfiMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiMessageWithReactions: FfiConverterRustBuffer {
    typealias SwiftType = [FfiMessageWithReactions]

    public static func write(_ value: [FfiMessageWithReactions], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiMessageWithReactions.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiMessageWithReactions] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiMessageWithReactions]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiMessageWithReactions.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiMetadataFieldChange: FfiConverterRustBuffer {
    typealias SwiftType = [FfiMetadataFieldChange]

    public static func write(_ value: [FfiMetadataFieldChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiMetadataFieldChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiMetadataFieldChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiMetadataFieldChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiMetadataFieldChange.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiRemoteAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [FfiRemoteAttachment]

    public static func write(_ value: [FfiRemoteAttachment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiRemoteAttachment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiRemoteAttachment] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiRemoteAttachment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiRemoteAttachment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiWalletCall: FfiConverterRustBuffer {
    typealias SwiftType = [FfiWalletCall]

    public static func write(_ value: [FfiWalletCall], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiWalletCall.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiWalletCall] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiWalletCall]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiWalletCall.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiBackupElementSelection: FfiConverterRustBuffer {
    typealias SwiftType = [FfiBackupElementSelection]

    public static func write(_ value: [FfiBackupElementSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiBackupElementSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiBackupElementSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiBackupElementSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiBackupElementSelection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConsentState: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConsentState]

    public static func write(_ value: [FfiConsentState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConsentState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConsentState] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConsentState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConsentState.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiContentType: FfiConverterRustBuffer {
    typealias SwiftType = [FfiContentType]

    public static func write(_ value: [FfiContentType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiContentType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiContentType] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiContentType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiContentType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiPreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [FfiPreferenceUpdate]

    public static func write(_ value: [FfiPreferenceUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiPreferenceUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiPreferenceUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiPreferenceUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiPreferenceUpdate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringUInt32: FfiConverterRustBuffer {
    public static func write(_ value: [String: UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterUInt32.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: UInt32] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: UInt32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterUInt32.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringUInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterUInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: UInt64] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: UInt64]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterUInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int64] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int64]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryDataTypeFfiKeyPackageStatus: FfiConverterRustBuffer {
    public static func write(_ value: [Data: FfiKeyPackageStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterData.write(key, into: &buf)
            FfiConverterTypeFfiKeyPackageStatus.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data: FfiKeyPackageStatus] {
        let len: Int32 = try readInt(&buf)
        var dict = [Data: FfiKeyPackageStatus]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterData.read(from: &buf)
            let value = try FfiConverterTypeFfiKeyPackageStatus.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryDataTypeFfiMessageMetadata: FfiConverterRustBuffer {
    public static func write(_ value: [Data: FfiMessageMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterData.write(key, into: &buf)
            FfiConverterTypeFfiMessageMetadata.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data: FfiMessageMetadata] {
        let len: Int32 = try readInt(&buf)
        var dict = [Data: FfiMessageMetadata]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterData.read(from: &buf)
            let value = try FfiConverterTypeFfiMessageMetadata.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryDataSequenceTypeFfiHmacKey: FfiConverterRustBuffer {
    public static func write(_ value: [Data: [FfiHmacKey]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterData.write(key, into: &buf)
            FfiConverterSequenceTypeFfiHmacKey.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data: [FfiHmacKey]] {
        let len: Int32 = try readInt(&buf)
        var dict = [Data: [FfiHmacKey]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterData.read(from: &buf)
            let value = try FfiConverterSequenceTypeFfiHmacKey.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeFfiIdentifierBool: FfiConverterRustBuffer {
    public static func write(_ value: [FfiIdentifier: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeFfiIdentifier.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiIdentifier: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [FfiIdentifier: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeFfiIdentifier.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureXmtpv3Initialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        // Note: it's important we call either `handleSuccess` or `handleError` exactly once.  Each
        // call consumes an Arc reference, which means there should be no possibility of a double
        // call.  The following code is structured so that will will never call both `handleSuccess`
        // and `handleError`, even in the face of weird errors.
        //
        // On platforms that need extra machinery to make C-ABI calls, like JNA or ctypes, it's
        // possible that we fail to make either call.  However, it doesn't seem like this is
        // possible on Swift since swift can just make the C call directly.
        var callResult: T
        do {
            callResult = try await makeCall()
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
            return
        }
        handleSuccess(callResult)
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        // See the note in uniffiTraitInterfaceCallAsync for details on `handleSuccess` and
        // `handleError`.
        var callResult: T
        do {
            callResult = try await makeCall()
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
            return
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
            return
        }
        handleSuccess(callResult)
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountXmtpv3() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * * Static apply a signature request
 */
public func applySignatureRequest(api: XmtpApiClient, signatureRequest: FfiSignatureRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_apply_signature_request(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterTypeFfiSignatureRequest_lower(signatureRequest)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
/**
 * connect to the XMTP backend
 * specifying `gateway_host` enables the D14n backend
 * and assumes `host` is set to the correct
 * d14n backend url.
 */
public func connectToBackend(v3Host: String, gatewayHost: String?, isSecure: Bool, clientMode: FfiClientMode?, appVersion: String?, authCallback: FfiAuthCallback?, authHandle: FfiAuthHandle?)async throws  -> XmtpApiClient  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_connect_to_backend(FfiConverterString.lower(v3Host),FfiConverterOptionString.lower(gatewayHost),FfiConverterBool.lower(isSecure),FfiConverterOptionTypeFfiClientMode.lower(clientMode),FfiConverterOptionString.lower(appVersion),FfiConverterOptionTypeFfiAuthCallback.lower(authCallback),FfiConverterOptionTypeFfiAuthHandle.lower(authHandle)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeXmtpApiClient_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
/**
 * It returns a new client of the specified `inbox_id`.
 * Note that the `inbox_id` must be either brand new or already associated with the `account_identifier`.
 * i.e. `inbox_id` cannot be associated with another account address.
 *
 * Prior to calling this function, it's suggested to form `inbox_id`, `account_identifier`, and `nonce` like below.
 *
 * ```text
 * inbox_id = get_inbox_id_for_address(account_identifier)
 * nonce = 0
 *
 * // if inbox_id is not associated, we will create new one.
 * if !inbox_id {
 * if !legacy_key { nonce = random_u64() }
 * inbox_id = generate_inbox_id(account_identifier, nonce)
 * } // Otherwise, we will just use the inbox and ignore the nonce.
 * db_path = $inbox_id-$env
 *
 * xmtp.create_client(account_identifier, nonce, inbox_id, Option<legacy_signed_private_key_proto>)
 * ```
 */
public func createClient(api: XmtpApiClient, syncApi: XmtpApiClient, db: DbOptions, inboxId: String, accountIdentifier: FfiIdentifier, nonce: UInt64, legacySignedPrivateKeyProto: Data?, deviceSyncMode: FfiDeviceSyncMode?, allowOffline: Bool?, forkRecoveryOpts: FfiForkRecoveryOpts?)async throws  -> FfiXmtpClient  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_create_client(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterTypeXmtpApiClient_lower(syncApi),FfiConverterTypeDbOptions_lower(db),FfiConverterString.lower(inboxId),FfiConverterTypeFfiIdentifier_lower(accountIdentifier),FfiConverterUInt64.lower(nonce),FfiConverterOptionData.lower(legacySignedPrivateKeyProto),FfiConverterOptionTypeFfiDeviceSyncMode.lower(deviceSyncMode),FfiConverterOptionBool.lower(allowOffline),FfiConverterOptionTypeFfiForkRecoveryOpts.lower(forkRecoveryOpts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiXmtpClient_lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
public func decodeActions(bytes: Data)throws  -> FfiActions  {
    return try  FfiConverterTypeFfiActions_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_actions(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeAttachment(bytes: Data)throws  -> FfiAttachment  {
    return try  FfiConverterTypeFfiAttachment_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_attachment(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeDeleteMessage(bytes: Data)throws  -> FfiDeleteMessage  {
    return try  FfiConverterTypeFfiDeleteMessage_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_delete_message(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeGroupUpdated(bytes: Data)throws  -> FfiGroupUpdated  {
    return try  FfiConverterTypeFfiGroupUpdated_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_group_updated(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeIntent(bytes: Data)throws  -> FfiIntent  {
    return try  FfiConverterTypeFfiIntent_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_intent(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeLeaveRequest(bytes: Data)throws  -> FfiLeaveRequest  {
    return try  FfiConverterTypeFfiLeaveRequest_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_leave_request(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeMarkdown(bytes: Data)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_markdown(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeMultiRemoteAttachment(bytes: Data)throws  -> FfiMultiRemoteAttachment  {
    return try  FfiConverterTypeFfiMultiRemoteAttachment_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_multi_remote_attachment(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeReaction(bytes: Data)throws  -> FfiReactionPayload  {
    return try  FfiConverterTypeFfiReactionPayload_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_reaction(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeReadReceipt(bytes: Data)throws  -> FfiReadReceipt  {
    return try  FfiConverterTypeFfiReadReceipt_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_read_receipt(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeRemoteAttachment(bytes: Data)throws  -> FfiRemoteAttachment  {
    return try  FfiConverterTypeFfiRemoteAttachment_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_remote_attachment(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeReply(bytes: Data)throws  -> FfiReply  {
    return try  FfiConverterTypeFfiReply_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_reply(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeText(bytes: Data)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_text(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeTransactionReference(bytes: Data)throws  -> FfiTransactionReference  {
    return try  FfiConverterTypeFfiTransactionReference_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_transaction_reference(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeWalletSendCalls(bytes: Data)throws  -> FfiWalletSendCalls  {
    return try  FfiConverterTypeFfiWalletSendCalls_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_decode_wallet_send_calls(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func encodeActions(actions: FfiActions)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_actions(
        FfiConverterTypeFfiActions_lower(actions),$0
    )
})
}
public func encodeAttachment(attachment: FfiAttachment)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_attachment(
        FfiConverterTypeFfiAttachment_lower(attachment),$0
    )
})
}
public func encodeDeleteMessage(request: FfiDeleteMessage)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_delete_message(
        FfiConverterTypeFfiDeleteMessage_lower(request),$0
    )
})
}
public func encodeIntent(intent: FfiIntent)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_intent(
        FfiConverterTypeFfiIntent_lower(intent),$0
    )
})
}
public func encodeLeaveRequest(request: FfiLeaveRequest)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_leave_request(
        FfiConverterTypeFfiLeaveRequest_lower(request),$0
    )
})
}
public func encodeMarkdown(text: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_markdown(
        FfiConverterString.lower(text),$0
    )
})
}
public func encodeMultiRemoteAttachment(ffiMultiRemoteAttachment: FfiMultiRemoteAttachment)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_multi_remote_attachment(
        FfiConverterTypeFfiMultiRemoteAttachment_lower(ffiMultiRemoteAttachment),$0
    )
})
}
public func encodeReaction(reaction: FfiReactionPayload)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_reaction(
        FfiConverterTypeFfiReactionPayload_lower(reaction),$0
    )
})
}
public func encodeReadReceipt(readReceipt: FfiReadReceipt)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_read_receipt(
        FfiConverterTypeFfiReadReceipt_lower(readReceipt),$0
    )
})
}
public func encodeRemoteAttachment(remoteAttachment: FfiRemoteAttachment)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_remote_attachment(
        FfiConverterTypeFfiRemoteAttachment_lower(remoteAttachment),$0
    )
})
}
public func encodeReply(reply: FfiReply)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_reply(
        FfiConverterTypeFfiReply_lower(reply),$0
    )
})
}
public func encodeText(text: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_text(
        FfiConverterString.lower(text),$0
    )
})
}
public func encodeTransactionReference(reference: FfiTransactionReference)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_transaction_reference(
        FfiConverterTypeFfiTransactionReference_lower(reference),$0
    )
})
}
public func encodeWalletSendCalls(walletSendCalls: FfiWalletSendCalls)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_encode_wallet_send_calls(
        FfiConverterTypeFfiWalletSendCalls_lower(walletSendCalls),$0
    )
})
}
/**
 * turns on logging to a file on-disk in the directory specified.
 * files will be prefixed with 'libxmtp-v{version}.{commit}.{process_type}.{pid}.log' and suffixed with the timestamp,
 * i.e "libxmtp-v1.6.0.abc123.main.12345.log.2025-04-02"
 * A maximum of 'max_files' log files are kept.
 */
public func enterDebugWriter(directory: String, logLevel: FfiLogLevel, rotation: FfiLogRotation, maxFiles: UInt32, processType: FfiProcessType)throws   {try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_enter_debug_writer(
        FfiConverterString.lower(directory),
        FfiConverterTypeFfiLogLevel_lower(logLevel),
        FfiConverterTypeFfiLogRotation_lower(rotation),
        FfiConverterUInt32.lower(maxFiles),
        FfiConverterTypeFfiProcessType_lower(processType),$0
    )
}
}
/**
 * turns on logging to a file on-disk with a specified log level.
 * files will be prefixed with 'libxmtp-v{version}.{commit}.{process_type}.{pid}.log' and suffixed with the timestamp,
 * i.e "libxmtp-v1.6.0.abc123.notif.67890.log.2025-04-02"
 * A maximum of 'max_files' log files are kept.
 */
public func enterDebugWriterWithLevel(directory: String, rotation: FfiLogRotation, maxFiles: UInt32, logLevel: FfiLogLevel, processType: FfiProcessType)throws   {try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_enter_debug_writer_with_level(
        FfiConverterString.lower(directory),
        FfiConverterTypeFfiLogRotation_lower(rotation),
        FfiConverterUInt32.lower(maxFiles),
        FfiConverterTypeFfiLogLevel_lower(logLevel),
        FfiConverterTypeFfiProcessType_lower(processType),$0
    )
}
}
/**
 * 3) Ethereum address from public key (accepts 65-byte 0x04||XY or 64-byte XY).
 */
public func ethereumAddressFromPubkey(pubkey: Data)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiCryptoError_lift) {
    uniffi_xmtpv3_fn_func_ethereum_address_from_pubkey(
        FfiConverterData.lower(pubkey),$0
    )
})
}
/**
 * 1) Ethereum compatible public key from 32-byte private key.
 * Returns **65-byte uncompressed** (0x04 || X || Y)
 * Private key is automatically zeroized after use for security
 */
public func ethereumGeneratePublicKey(privateKey32: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiCryptoError_lift) {
    uniffi_xmtpv3_fn_func_ethereum_generate_public_key(
        FfiConverterData.lower(privateKey32),$0
    )
})
}
/**
 * 4) EIP-191 personal message hash: keccak256("\x19Ethereum Signed Message:\n{len}" || message)
 */
public func ethereumHashPersonal(message: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiCryptoError_lift) {
    uniffi_xmtpv3_fn_func_ethereum_hash_personal(
        FfiConverterString.lower(message),$0
    )
})
}
/**
 * 2) Ethereum recoverable signature (FFI).
 * Returns 65 bytes `r || s || v`, with **v  {27,28}**
 * (legacy/Electrum encoding where **v = 27 + parity**, parity  {0,1}).
 * - If `hashing == true`: signs per **EIP-191**
 * ("Ethereum Signed Message:\n{len(msg)}" || msg, then keccak256).
 * - If `hashing == false`: `msg` must be a **32-byte** prehash (e.g., keccak256/EIP-712 digest).
 * - Private key is automatically zeroized after signing for security
 */
public func ethereumSignRecoverable(msg: Data, privateKey32: Data, hashing: Bool)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFfiCryptoError_lift) {
    uniffi_xmtpv3_fn_func_ethereum_sign_recoverable(
        FfiConverterData.lower(msg),
        FfiConverterData.lower(privateKey32),
        FfiConverterBool.lower(hashing),$0
    )
})
}
/**
 * Flush loglines from libxmtp log writer to the file, ensuring logs are written.
 * This should be called before the program exits, to ensure all the logs in memory have been
 * written. this ends the writer thread.
 */
public func exitDebugWriter()throws   {try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_exit_debug_writer($0
    )
}
}
public func generateInboxId(accountIdentifier: FfiIdentifier, nonce: UInt64)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_generate_inbox_id(
        FfiConverterTypeFfiIdentifier_lower(accountIdentifier),
        FfiConverterUInt64.lower(nonce),$0
    )
})
}
public func getInboxIdForIdentifier(api: XmtpApiClient, accountIdentifier: FfiIdentifier)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_get_inbox_id_for_identifier(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterTypeFfiIdentifier_lower(accountIdentifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
public func getNewestMessageMetadata(api: XmtpApiClient, groupIds: [Data])async throws  -> [Data: FfiMessageMetadata]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_get_newest_message_metadata(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterSequenceData.lower(groupIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryDataTypeFfiMessageMetadata.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
public func getVersionInfo() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_func_get_version_info($0
    )
})
}
/**
 * * Static Get the inbox state for each `inbox_id`.
 */
public func inboxStateFromInboxIds(api: XmtpApiClient, inboxIds: [String])async throws  -> [FfiInboxState]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_inbox_state_from_inbox_ids(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiInboxState.lift,
            errorHandler: FfiConverterTypeFfiError_lift
        )
}
public func isConnected(api: XmtpApiClient)async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_is_connected(FfiConverterTypeXmtpApiClient_lower(api)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_i8,
            completeFunc: ffi_xmtpv3_rust_future_complete_i8,
            freeFunc: ffi_xmtpv3_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
/**
 * Parse an error string like `[ErrorCode] message` into a structured error info.
 */
public func parseXmtpError(message: String) -> FfiErrorInfo  {
    return try!  FfiConverterTypeFfiErrorInfo_lift(try! rustCall() {
    uniffi_xmtpv3_fn_func_parse_xmtp_error(
        FfiConverterString.lower(message),$0
    )
})
}
/**
 * * Static revoke a list of installations
 */
public func revokeInstallations(api: XmtpApiClient, recoveryIdentifier: FfiIdentifier, inboxId: String, installationIds: [Data])throws  -> FfiSignatureRequest  {
    return try  FfiConverterTypeFfiSignatureRequest_lift(try rustCallWithError(FfiConverterTypeFfiError_lift) {
    uniffi_xmtpv3_fn_func_revoke_installations(
        FfiConverterTypeXmtpApiClient_lower(api),
        FfiConverterTypeFfiIdentifier_lower(recoveryIdentifier),
        FfiConverterString.lower(inboxId),
        FfiConverterSequenceData.lower(installationIds),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_xmtpv3_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_xmtpv3_checksum_func_apply_signature_request() != 5495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_connect_to_backend() != 63000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_create_client() != 7276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_actions() != 48968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_attachment() != 8697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_delete_message() != 63471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_group_updated() != 51824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_intent() != 59375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_leave_request() != 14629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_markdown() != 20635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_multi_remote_attachment() != 49952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_reaction() != 22136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_read_receipt() != 27191) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_remote_attachment() != 21885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_reply() != 634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_text() != 8275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_transaction_reference() != 61157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_wallet_send_calls() != 48334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_actions() != 42882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_attachment() != 42159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_delete_message() != 6766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_intent() != 29847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_leave_request() != 33190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_markdown() != 45065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_multi_remote_attachment() != 41160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_reaction() != 56943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_read_receipt() != 16585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_remote_attachment() != 62508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_reply() != 21560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_text() != 31759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_transaction_reference() != 62574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_wallet_send_calls() != 55402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_enter_debug_writer() != 17248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_enter_debug_writer_with_level() != 18287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_ethereum_address_from_pubkey() != 12568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_ethereum_generate_public_key() != 36134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_ethereum_hash_personal() != 43764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_ethereum_sign_recoverable() != 58098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_exit_debug_writer() != 27560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_generate_inbox_id() != 42067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_get_inbox_id_for_identifier() != 61855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_get_newest_message_metadata() != 27949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_get_version_info() != 29277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_inbox_state_from_inbox_ids() != 9472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_is_connected() != 17295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_parse_xmtp_error() != 57286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_revoke_installations() != 64481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffiauthcallback_on_auth_required() != 29742) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffiauthhandle_id() != 11318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffiauthhandle_set() != 2395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonsentcallback_on_consent_update() != 12532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonsentcallback_on_error() != 56475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonsentcallback_on_close() != 18566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_admin() != 14149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_members() != 40357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_members_by_identity() != 56401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_super_admin() != 57341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_added_by_inbox_id() != 56785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_admin_list() != 44882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_app_data() != 26219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_consent_state() != 3821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_conversation_debug_info() != 23207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_conversation_message_disappearing_settings() != 48701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_conversation_type() != 43322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_count_messages() != 243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_created_at_ns() != 17973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_delete_message() != 34540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_dm_peer_inbox_id() != 2178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_find_duplicate_dms() != 52) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_find_enriched_messages() != 59362) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_find_messages() != 54046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_find_messages_with_reactions() != 14034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_get_hmac_keys() != 49256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_get_last_read_times() != 24795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_description() != 6993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_image_url_square() != 22193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_metadata() != 17919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_name() != 16617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_permissions() != 47434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_id() != 5542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_active() != 52886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_admin() != 2121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_conversation_message_disappearing_enabled() != 65312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_super_admin() != 38152) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_leave_group() != 64752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_list_members() != 33630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_membership_state() != 23889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_paused_for_version() != 35645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_prepare_message() != 17501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_process_streamed_conversation_message() != 25980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_publish_messages() != 29588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_publish_stored_message() != 5747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_admin() != 5640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_conversation_message_disappearing_settings() != 62483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_members() != 24740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_members_by_identity() != 1043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_super_admin() != 8802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_send() != 5758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_send_optimistic() != 50020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_send_text() != 61657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_stream() != 26870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_super_admin_list() != 1368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_sync() != 64532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_app_data() != 49116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_consent_state() != 55592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_conversation_message_disappearing_settings() != 59303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_group_description() != 26687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_group_image_url_square() != 23989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_group_name() != 25195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_permission_policy() != 43445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation() != 25316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationcallback_on_error() != 17078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationcallback_on_close() != 26905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationlistitem_conversation() != 20525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationlistitem_is_commit_log_forked() != 16358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationlistitem_last_message() != 42510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationmetadata_conversation_type() != 22241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationmetadata_creator_inbox_id() != 61067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_create_group() != 11757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_create_group_by_identity() != 40956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_create_group_optimistic() != 7796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm() != 25156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm_by_identity() != 632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_get_hmac_keys() != 60241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_list() != 45877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_list_dms() != 14878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_list_groups() != 13236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message() != 47818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream() != 31576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_all_dm_messages() != 7006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_all_group_messages() != 16815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages() != 34596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_consent() != 27123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_dms() != 52710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_groups() != 11064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_message_deletions() != 47172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_messages() != 45879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_preferences() != 37452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_sync() != 44913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_sync_all_conversations() != 7672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_content() != 6416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_content_type_id() != 63211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_conversation_id() != 1070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_delivery_status() != 10321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_expires_at_ns() != 54265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_fallback_text() != 1914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_has_reactions() != 60219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_id() != 41676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_inserted_at_ns() != 46609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_kind() != 55657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_num_replies() != 35773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_reaction_count() != 7084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_reactions() != 53291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_inbox_id() != 12782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_installation_id() != 58886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffidecodedmessage_sent_at_ns() != 54409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set() != 56212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type() != 31831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffiinboxowner_get_identifier() != 4926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffiinboxowner_sign() != 10423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message() != 5286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffimessagecallback_on_error() != 60750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffimessagecallback_on_close() != 9150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffimessagedeletioncallback_on_message_deleted() != 60335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_preference_update() != 19900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_error() != 23172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_close() != 48198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature() != 23442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_passkey_signature() != 57092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature() != 35063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready() != 65051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures() != 46165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text() != 22797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_end() != 11040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait() != 32223) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed() != 62423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_wait_for_ready() != 38545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisyncworker_wait() != 27531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_add_identity() != 16903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_addresses_from_inbox_id() != 24531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_api_aggregate_statistics() != 18475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_api_identity_statistics() != 47055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_api_statistics() != 31059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request() != 27496) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_archive_metadata() != 9006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message() != 44069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_change_recovery_identifier() != 2778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_clear_all_statistics() != 38737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_conversation() != 54250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations() != 47463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_create_archive() != 32355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect() != 61877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_delete_message() != 18971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_dm_conversation() != 6444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_enriched_message() != 25161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_fetch_inbox_updates_count() != 12507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_fetch_own_inbox_updates_count() != 4788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id() != 48840) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state() != 10787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_get_key_package_statuses_for_installation_ids() != 46014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state() != 54337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_import_archive() != 56828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id() != 25128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state() != 7500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id() != 37173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_list_available_archives() != 47380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_message() != 51724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_process_sync_archive() != 57506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity() != 15231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection() != 45722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations_signature_request() != 4877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_identity() != 48860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_installations() != 2461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_archive() != 860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_request() != 63511) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_states() != 8012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_sign_with_installation_key() != 7127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request() != 18270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_all_device_sync_groups() != 5558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_preferences() != 11661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_installation_key() != 40247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_public_key() != 6101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_constructor_ffiauthhandle_new() != 11700) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitFfiAuthCallback()
    uniffiCallbackInitFfiConsentCallback()
    uniffiCallbackInitFfiConversationCallback()
    uniffiCallbackInitFfiInboxOwner()
    uniffiCallbackInitFfiMessageCallback()
    uniffiCallbackInitFfiMessageDeletionCallback()
    uniffiCallbackInitFfiPreferenceCallback()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureXmtpv3Initialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all