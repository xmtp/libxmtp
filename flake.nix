# Flake Shell for building release artifacts for swift and kotlin
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    fenix = {
      url = "github:nix-community/fenix";
      inputs = {
        nixpkgs.follows = "nixpkgs";
      };
    };
    flake-parts = {
      url = "github:hercules-ci/flake-parts";
    };
    foundry.url = "github:shazow/foundry.nix/stable";
    crane = {
      url = "github:ipetkov/crane";
    };
    rust-flake.url = "github:juspay/rust-flake";
    rust-manifest = {
      url = "https://static.rust-lang.org/dist/channel-rust-1.92.0.toml";
      flake = false;
    };
  };

  outputs =
    inputs@{ flake-parts, self, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [
        "aarch64-darwin"
        "x86_64-linux"
      ];
      imports = [
        ./nix/lib
        flake-parts.flakeModules.easyOverlay
        inputs.rust-flake.flakeModules.default
        inputs.rust-flake.flakeModules.nixpkgs
        ./nix/rust-defaults.nix
        ./nix/rust.nix
        ./nix/musl-docker.nix
      ];
      perSystem =
        { pkgs, lib, ... }:
        {
          nixpkgs = self.lib.pkgConfig;
          devShells = {
            # lib.mkForce overrides the devShells.rust auto-generated by rust-flake
            rust = lib.mkForce (pkgs.callPackage ./nix/shells/rust.nix { });
            default = pkgs.callPackage ./nix/shells/local.nix { };
            android = pkgs.callPackage ./nix/shells/android.nix { };
            js = pkgs.callPackage ./nix/js.nix { };
            wasm = (pkgs.callPackage ./nix/package/wasm.nix { }).devShell;
          }
          // lib.optionalAttrs pkgs.stdenv.isDarwin {
            ios = pkgs.callPackage ./nix/shells/ios.nix { };
          };
          packages =
            let
              android = pkgs.callPackage ./nix/package/android.nix { };
              inherit (pkgs.xmtp) androidEnv;
            in
            {
              inherit (pkgs.xmtp) ffi-uniffi-bindgen;
              wasm-bindings = (pkgs.callPackage ./nix/package/wasm.nix { }).bin;
              wasm-bindgen-cli = pkgs.callPackage ./nix/lib/packages/wasm-bindgen-cli.nix { };
              # Android bindings (.so libraries + Kotlin bindings)
              android-libs = android.aggregate;
              # Android bindings - host-matching target only (fast dev/CI builds)
              android-libs-fast = (android.mkAndroid [ androidEnv.hostAndroidTarget ]).aggregate;
            }
            // lib.optionalAttrs pkgs.stdenv.isDarwin {
              # stdenvNoCC is passed to callPackage (for the aggregate derivation).
              # This avoids Nix's apple-sdk and cc-wrapper,
              # which inject -mmacos-version-min flags that
              # conflict with iOS cross-compilation. The builds are impure (__noChroot)
              # and use the system Xcode SDK directly via ios-env.nix paths.
              ios-libs =
                (pkgs.callPackage ./nix/package/ios.nix {
                  stdenv = pkgs.stdenvNoCC;
                }).aggregate;
              # iOS bindings - simulator + host macOS only (fast dev/CI builds)
              ios-libs-fast =
                ((pkgs.callPackage ./nix/package/ios.nix {
                  stdenv = pkgs.stdenvNoCC;
                }).mkIos [ "aarch64-apple-darwin" "aarch64-apple-ios-sim" ]).aggregate;
            };
        };
    };
}
